{"version":3,"file":"shaderCodeNode.js","sourceRoot":"","sources":["../../../../../dev/core/src/Engines/Processors/shaderCodeNode.ts"],"names":[],"mappings":"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","sourcesContent":["import type { ProcessingOptions } from \"./shaderProcessingOptions\";\r\n\r\nconst defaultAttributeKeywordName = \"attribute\";\r\nconst defaultVaryingKeywordName = \"varying\";\r\n\r\n/** @internal */\r\nexport class ShaderCodeNode {\r\n    line: string;\r\n    children: ShaderCodeNode[] = [];\r\n    additionalDefineKey?: string;\r\n    additionalDefineValue?: string;\r\n\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    isValid(preprocessors: { [key: string]: string }): boolean {\r\n        return true;\r\n    }\r\n\r\n    process(preprocessors: { [key: string]: string }, options: ProcessingOptions): string {\r\n        let result = \"\";\r\n        if (this.line) {\r\n            let value: string = this.line;\r\n            const processor = options.processor;\r\n            if (processor) {\r\n                // This must be done before other replacements to avoid mistakenly changing something that was already changed.\r\n                if (processor.lineProcessor) {\r\n                    value = processor.lineProcessor(value, options.isFragment, options.processingContext);\r\n                }\r\n\r\n                const attributeKeyword = options.processor?.attributeKeywordName ?? defaultAttributeKeywordName;\r\n                const varyingKeyword =\r\n                    options.isFragment && options.processor?.varyingFragmentKeywordName\r\n                        ? options.processor?.varyingFragmentKeywordName\r\n                        : !options.isFragment && options.processor?.varyingVertexKeywordName\r\n                        ? options.processor?.varyingVertexKeywordName\r\n                        : defaultVaryingKeywordName;\r\n\r\n                if (!options.isFragment && processor.attributeProcessor && this.line.startsWith(attributeKeyword)) {\r\n                    value = processor.attributeProcessor(this.line, preprocessors, options.processingContext);\r\n                } else if (\r\n                    processor.varyingProcessor &&\r\n                    (processor.varyingCheck?.(this.line, options.isFragment) || (!processor.varyingCheck && this.line.startsWith(varyingKeyword)))\r\n                ) {\r\n                    value = processor.varyingProcessor(this.line, options.isFragment, preprocessors, options.processingContext);\r\n                } else if (processor.uniformProcessor && processor.uniformRegexp && processor.uniformRegexp.test(this.line)) {\r\n                    if (!options.lookForClosingBracketForUniformBuffer) {\r\n                        value = processor.uniformProcessor(this.line, options.isFragment, preprocessors, options.processingContext);\r\n                    }\r\n                } else if (processor.uniformBufferProcessor && processor.uniformBufferRegexp && processor.uniformBufferRegexp.test(this.line)) {\r\n                    if (!options.lookForClosingBracketForUniformBuffer) {\r\n                        value = processor.uniformBufferProcessor(this.line, options.isFragment, options.processingContext);\r\n                        options.lookForClosingBracketForUniformBuffer = true;\r\n                    }\r\n                } else if (processor.textureProcessor && processor.textureRegexp && processor.textureRegexp.test(this.line)) {\r\n                    value = processor.textureProcessor(this.line, options.isFragment, preprocessors, options.processingContext);\r\n                } else if ((processor.uniformProcessor || processor.uniformBufferProcessor) && this.line.startsWith(\"uniform\") && !options.lookForClosingBracketForUniformBuffer) {\r\n                    const regex = /uniform\\s+(?:(?:highp)?|(?:lowp)?)\\s*(\\S+)\\s+(\\S+)\\s*;/;\r\n\r\n                    if (regex.test(this.line)) {\r\n                        // uniform\r\n                        if (processor.uniformProcessor) {\r\n                            value = processor.uniformProcessor(this.line, options.isFragment, preprocessors, options.processingContext);\r\n                        }\r\n                    } else {\r\n                        // Uniform buffer\r\n                        if (processor.uniformBufferProcessor) {\r\n                            value = processor.uniformBufferProcessor(this.line, options.isFragment, options.processingContext);\r\n                            options.lookForClosingBracketForUniformBuffer = true;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                if (options.lookForClosingBracketForUniformBuffer && this.line.indexOf(\"}\") !== -1) {\r\n                    options.lookForClosingBracketForUniformBuffer = false;\r\n                    if (processor.endOfUniformBufferProcessor) {\r\n                        value = processor.endOfUniformBufferProcessor(this.line, options.isFragment, options.processingContext);\r\n                    }\r\n                }\r\n            }\r\n\r\n            result += value + \"\\n\";\r\n        }\r\n\r\n        this.children.forEach((child) => {\r\n            result += child.process(preprocessors, options);\r\n        });\r\n\r\n        if (this.additionalDefineKey) {\r\n            preprocessors[this.additionalDefineKey] = this.additionalDefineValue || \"true\";\r\n        }\r\n\r\n        return result;\r\n    }\r\n}\r\n"]}