{"version":3,"file":"IPhysicsEnginePlugin.js","sourceRoot":"","sources":["../../../../../dev/core/src/Physics/v2/IPhysicsEnginePlugin.ts"],"names":[],"mappings":"AAYA,6CAA6C;AAC7C,MAAM,CAAN,IAAY,8BAaX;AAbD,WAAY,8BAA8B;IACtC;;OAEG;IACH,mFAAI,CAAA;IACJ;;OAEG;IACH,yFAAO,CAAA;IACP;;OAEG;IACH,uFAAM,CAAA;AACV,CAAC,EAbW,8BAA8B,KAA9B,8BAA8B,QAazC;AAED,2GAA2G;AAC3G,MAAM,CAAN,IAAY,qBAqCX;AArCD,WAAY,qBAAqB;IAC7B;;;OAGG;IACH,yEAAQ,CAAA;IACR;;;OAGG;IACH,yEAAQ,CAAA;IACR;;;OAGG;IACH,yEAAQ,CAAA;IACR;;;OAGG;IACH,2EAAS,CAAA;IACT;;;OAGG;IACH,2EAAS,CAAA;IACT;;;OAGG;IACH,2EAAS,CAAA;IACT;;;;OAIG;IACH,uFAAe,CAAA;AACnB,CAAC,EArCW,qBAAqB,KAArB,qBAAqB,QAqChC;AAED,yBAAyB;AACzB,MAAM,CAAN,IAAY,qBAsCX;AAtCD,WAAY,qBAAqB;IAC7B;;;OAGG;IACH,uFAAmB,CAAA;IACnB;;;OAGG;IACH,yEAAY,CAAA;IACZ;;;OAGG;IACH,mEAAS,CAAA;IACT;;;;OAIG;IACH,qEAAU,CAAA;IACV;;;OAGG;IACH,iEAAQ,CAAA;IACR;;;OAGG;IACH,2EAAa,CAAA;IACb;;;;OAIG;IACH,uEAAW,CAAA;AACf,CAAC,EAtCW,qBAAqB,KAArB,qBAAqB,QAsChC;AAED,oBAAoB;AACpB,MAAM,CAAN,IAAY,gBASX;AATD,WAAY,gBAAgB;IACxB,2DAAM,CAAA;IACN,6DAAO,CAAA;IACP,+DAAQ,CAAA;IACR,qDAAG,CAAA;IACH,qEAAW,CAAA;IACX,iEAAS,CAAA;IACT,uDAAI,CAAA;IACJ,qEAAW,CAAA;AACf,CAAC,EATW,gBAAgB,KAAhB,gBAAgB,QAS3B;AAED,qGAAqG;AACrG,MAAM,CAAN,IAAY,0BAIX;AAJD,WAAY,0BAA0B;IAClC,2EAAI,CAAA;IACJ,mFAAQ,CAAA;IACR,mFAAQ,CAAA;AACZ,CAAC,EAJW,0BAA0B,KAA1B,0BAA0B,QAIrC;AAED,MAAM,CAAN,IAAY,gBAMX;AAND,WAAY,gBAAgB;IACxB,2DAAuC,CAAA;IACvC,+DAA2C,CAAA;IAC3C,6DAAyC,CAAA;IACzC,uDAAmC,CAAA;IACnC,qDAAiC,CAAA;AACrC,CAAC,EANW,gBAAgB,KAAhB,gBAAgB,QAM3B;AAyLD;;GAEG;AACH,MAAM,CAAN,IAAY,iBAIX;AAJD,WAAY,iBAAiB;IACzB,6DAAM,CAAA;IACN,iEAAQ,CAAA;IACR,+DAAO,CAAA;AACX,CAAC,EAJW,iBAAiB,KAAjB,iBAAiB,QAI5B","sourcesContent":["import type { Vector3, Quaternion } from \"../../Maths/math.vector\";\r\nimport type { IRaycastQuery, PhysicsRaycastResult } from \"../physicsRaycastResult\";\r\nimport type { PhysicsBody } from \"./physicsBody\";\r\nimport type { PhysicsShape } from \"./physicsShape\";\r\nimport type { PhysicsConstraint } from \"./physicsConstraint\";\r\nimport type { BoundingBox } from \"../../Culling/boundingBox\";\r\nimport type { TransformNode } from \"../../Meshes/transformNode\";\r\nimport type { PhysicsMaterial } from \"./physicsMaterial\";\r\nimport type { Mesh } from \"../../Meshes/mesh\";\r\nimport type { Nullable } from \"core/types\";\r\nimport type { Observable } from \"core/Misc/observable\";\r\n\r\n/** How a specific axis can be constrained */\r\nexport enum PhysicsConstraintAxisLimitMode {\r\n    /*\r\n     * The axis is not restricted at all\r\n     */\r\n    FREE,\r\n    /*\r\n     * The axis has a minimum/maximum limit\r\n     */\r\n    LIMITED,\r\n    /*\r\n     * The axis allows no relative movement of the pivots\r\n     */\r\n    LOCKED,\r\n}\r\n\r\n/** The constraint specific axis to use when setting Friction, `ConstraintAxisLimitMode`, max force, ... */\r\nexport enum PhysicsConstraintAxis {\r\n    /*\r\n     * Translation along the primary axis of the constraint (i.e. the\r\n     * direction specified by PhysicsConstraintParameters.axisA/axisB)\r\n     */\r\n    LINEAR_X,\r\n    /*\r\n     * Translation along the second axis of the constraint (i.e. the\r\n     * direction specified by PhysicsConstraintParameters.perpAxisA/perpAxisB)\r\n     */\r\n    LINEAR_Y,\r\n    /*\r\n     * Translation along the third axis of the constraint. This axis is\r\n     * computed from the cross product of axisA/axisB and perpAxisA/perpAxisB)\r\n     */\r\n    LINEAR_Z,\r\n    /*\r\n     * Rotation around the primary axis of the constraint (i.e. the\r\n     * axis specified by PhysicsConstraintParameters.axisA/axisB)\r\n     */\r\n    ANGULAR_X,\r\n    /*\r\n     * Rotation around the second axis of the constraint (i.e. the\r\n     * axis specified by PhysicsConstraintParameters.perpAxisA/perpAxisB)\r\n     */\r\n    ANGULAR_Y,\r\n    /*\r\n     * Rotation around the third axis of the constraint. This axis is\r\n     * computed from the cross product of axisA/axisB and perpAxisA/perpAxisB)\r\n     */\r\n    ANGULAR_Z,\r\n    /*\r\n     * A 3D distance limit; similar to specifying the LINEAR_X/Y/Z axes\r\n     * individually, but the distance calculation uses all three axes\r\n     * simultaneously, instead of individually.\r\n     */\r\n    LINEAR_DISTANCE,\r\n}\r\n\r\n/** Type of Constraint */\r\nexport enum PhysicsConstraintType {\r\n    /**\r\n     * A ball and socket constraint will attempt to line up the pivot\r\n     * positions in each body, and have no restrictions on rotation\r\n     */\r\n    BALL_AND_SOCKET = 1,\r\n    /**\r\n     * A distance constraint will attempt to keep the pivot locations\r\n     * within a specified distance.\r\n     */\r\n    DISTANCE = 2,\r\n    /**\r\n     * A hinge constraint will keep the pivot positions aligned as well\r\n     * as two angular axes. The remaining angular axis will be free to rotate.\r\n     */\r\n    HINGE = 3,\r\n    /**\r\n     * A slider constraint allows bodies to translate along one axis and\r\n     * rotate about the same axis. The remaining two axes are locked in\r\n     * place\r\n     */\r\n    SLIDER = 4,\r\n    /**\r\n     * A lock constraint will attempt to keep the pivots completely lined\r\n     * up between both bodies, allowing no relative movement.\r\n     */\r\n    LOCK = 5,\r\n    /*\r\n     * A prismatic will lock the rotations of the bodies, and allow translation\r\n     * only along one axis\r\n     */\r\n    PRISMATIC = 6,\r\n    /*\r\n     * A generic constraint; this starts with no limits on how the bodies can\r\n     * move relative to each other, but limits can be added via the PhysicsConstraint\r\n     * interfaces. This can be used to specify a large variety of constraints\r\n     */\r\n    SIX_DOF = 7,\r\n}\r\n\r\n/** Type of Shape */\r\nexport enum PhysicsShapeType {\r\n    SPHERE,\r\n    CAPSULE,\r\n    CYLINDER,\r\n    BOX,\r\n    CONVEX_HULL,\r\n    CONTAINER,\r\n    MESH,\r\n    HEIGHTFIELD,\r\n}\r\n\r\n/** Optional motor which attempts to move a body at a specific velocity, or at a specific position */\r\nexport enum PhysicsConstraintMotorType {\r\n    NONE,\r\n    VELOCITY,\r\n    POSITION,\r\n}\r\n\r\nexport enum PhysicsEventType {\r\n    COLLISION_STARTED = \"COLLISION_STARTED\",\r\n    COLLISION_CONTINUED = \"COLLISION_CONTINUED\",\r\n    COLLISION_FINISHED = \"COLLISION_FINISHED\",\r\n    TRIGGER_ENTERED = \"TRIGGER_ENTERED\",\r\n    TRIGGER_EXITED = \"TRIGGER_EXITED\",\r\n}\r\n\r\n/**\r\n * Base collision object\r\n */\r\nexport interface IBasePhysicsCollisionEvent {\r\n    /**\r\n     * 1st physics body that collided\r\n     */\r\n    collider: PhysicsBody;\r\n    /**\r\n     * 2nd physics body that collided\r\n     */\r\n    collidedAgainst: PhysicsBody;\r\n    /**\r\n     * index in instances array for the collider\r\n     */\r\n    colliderIndex: number;\r\n    /**\r\n     * index in instances array for the collidedAgainst\r\n     */\r\n    collidedAgainstIndex: number;\r\n    /**\r\n     * Event type\r\n     */\r\n    type: PhysicsEventType;\r\n}\r\n\r\n/**\r\n * Collision object that is the parameter when notification for collision fires.\r\n */\r\nexport interface IPhysicsCollisionEvent extends IBasePhysicsCollisionEvent {\r\n    /**\r\n     * World position where the collision occured\r\n     */\r\n    point: Nullable<Vector3>;\r\n    /**\r\n     * Penetration distance\r\n     */\r\n    distance: number;\r\n    /**\r\n     * Impulse value computed by the solver response\r\n     */\r\n    impulse: number;\r\n    /**\r\n     * Collision world normal direction\r\n     */\r\n    normal: Nullable<Vector3>;\r\n}\r\n\r\n/**\r\n * Parameters used to describe the Shape\r\n */\r\nexport interface PhysicsShapeParameters {\r\n    /**\r\n     * Shape center position\r\n     */\r\n    center?: Vector3;\r\n    /**\r\n     * Radius for cylinder, shape and capsule\r\n     */\r\n    radius?: number;\r\n    /**\r\n     * First point position that defines the cylinder or capsule\r\n     */\r\n    pointA?: Vector3;\r\n    /**\r\n     * Second point position that defines the cylinder or capsule\r\n     */\r\n    pointB?: Vector3;\r\n    /**\r\n     * Shape orientation\r\n     */\r\n    rotation?: Quaternion;\r\n    /**\r\n     * Dimesion extention for the box\r\n     */\r\n    extents?: Vector3;\r\n    /**\r\n     * Mesh used for Mesh shape or convex hull. It can be different than the mesh the body is attached to.\r\n     */\r\n    mesh?: Mesh;\r\n    /**\r\n     * Use children hierarchy\r\n     */\r\n    includeChildMeshes?: boolean;\r\n}\r\n\r\n/**\r\n * Parameters used to describe a Constraint\r\n */\r\nexport interface PhysicsConstraintParameters {\r\n    /**\r\n     * Location of the constraint pivot in the space of first body\r\n     */\r\n    pivotA?: Vector3;\r\n    /**\r\n     * Location of the constraint pivot in the space of the second body\r\n     */\r\n    pivotB?: Vector3;\r\n    /**\r\n     * An axis in the space of the first body which determines how\r\n     * distances/angles are measured for LINEAR_X/ANGULAR_X limits.\r\n     */\r\n    axisA?: Vector3;\r\n    /**\r\n     * An axis in the space of the second body which determines how\r\n     * distances/angles are measured for LINEAR_X/ANGULAR_X limits.\r\n     */\r\n    axisB?: Vector3;\r\n\r\n    /**\r\n     * An axis in the space of the first body which determines how\r\n     * distances/angles are measured for LINEAR_Y/ANGULAR_Y limits.\r\n     */\r\n    perpAxisA?: Vector3;\r\n\r\n    /**\r\n     * An axis in the space of the second body which determines how\r\n     * distances/angles are measured for LINEAR_Y/ANGULAR_Y limits.\r\n     */\r\n    perpAxisB?: Vector3;\r\n\r\n    /**\r\n     * The maximum distance that can seperate the two pivots.\r\n     * Only used for DISTANCE constraints\r\n     */\r\n    maxDistance?: number;\r\n\r\n    /**\r\n     * Determines if the connected bodies should collide. Generally,\r\n     * it is preferable to set this to false, especially if the constraint\r\n     * positions the bodies so that they overlap. Otherwise, the constraint\r\n     * will \"fight\" the collision detection and may cause jitter.\r\n     */\r\n    collision?: boolean;\r\n}\r\n\r\n/**\r\n * Parameters used to describe mass and inertia of the Physics Body\r\n */\r\nexport interface PhysicsMassProperties {\r\n    /**\r\n     * The center of mass, in local space. This is The\r\n     * point the body will rotate around when applying\r\n     * an angular velocity.\r\n     *\r\n     * If not provided, the physics engine will compute\r\n     * an appropriate value.\r\n     */\r\n    centerOfMass?: Vector3;\r\n    /**\r\n     * The total mass of this object, in kilograms. This\r\n     * affects how easy it is to move the body. A value\r\n     * of zero will be used as an infinite mass.\r\n     *\r\n     * If not provided, the physics engine will compute\r\n     * an appropriate value.\r\n     */\r\n    mass?: number;\r\n    /**\r\n     * The principal moments of inertia of this object\r\n     * for a unit mass. This determines how easy it is\r\n     * for the body to rotate. A value of zero on any\r\n     * axis will be used as infinite interia about that\r\n     * axis.\r\n     *\r\n     * If not provided, the physics engine will compute\r\n     * an appropriate value.\r\n     */\r\n    inertia?: Vector3;\r\n    /**\r\n     * The rotation rotating from inertia major axis space\r\n     * to parent space (i.e., the rotation which, when\r\n     * applied to the 3x3 inertia tensor causes the inertia\r\n     * tensor to become a diagonal matrix). This determines\r\n     * how the values of inertia are aligned with the parent\r\n     * object.\r\n     *\r\n     * If not provided, the physics engine will compute\r\n     * an appropriate value.\r\n     */\r\n    inertiaOrientation?: Quaternion;\r\n}\r\n\r\n/**\r\n * Indicates how the body will behave.\r\n */\r\nexport enum PhysicsMotionType {\r\n    STATIC,\r\n    ANIMATED,\r\n    DYNAMIC,\r\n}\r\n\r\n/**\r\n * Represents a pair of bodies connected by a constraint.\r\n */\r\nexport type ConstrainedBodyPair = { parentBody: PhysicsBody; parentBodyIndex: number; childBody: PhysicsBody; childBodyIndex: number };\r\n\r\n/** @internal */\r\nexport interface IPhysicsEnginePluginV2 {\r\n    /**\r\n     * Physics plugin world instance\r\n     */\r\n    world: any;\r\n    /**\r\n     * Physics plugin name\r\n     */\r\n    name: string;\r\n\r\n    /**\r\n     * Collision observable\r\n     */\r\n    onCollisionObservable: Observable<IPhysicsCollisionEvent>;\r\n    /**\r\n     * Collision ended observable\r\n     */\r\n    onCollisionEndedObservable: Observable<IBasePhysicsCollisionEvent>;\r\n    /**\r\n     * Trigger observable\r\n     */\r\n    onTriggerCollisionObservable: Observable<IBasePhysicsCollisionEvent>;\r\n\r\n    setGravity(gravity: Vector3): void;\r\n    setTimeStep(timeStep: number): void;\r\n    getTimeStep(): number;\r\n    executeStep(delta: number, bodies: Array<PhysicsBody>): void; //not forgetting pre and post events\r\n    getPluginVersion(): number;\r\n\r\n    // body\r\n    initBody(body: PhysicsBody, motionType: PhysicsMotionType, position: Vector3, orientation: Quaternion): void;\r\n    initBodyInstances(body: PhysicsBody, motionType: PhysicsMotionType, mesh: Mesh): void;\r\n    updateBodyInstances(body: PhysicsBody, mesh: Mesh): void;\r\n    removeBody(body: PhysicsBody): void;\r\n    sync(body: PhysicsBody): void;\r\n    syncTransform(body: PhysicsBody, transformNode: TransformNode): void;\r\n    setShape(body: PhysicsBody, shape: Nullable<PhysicsShape>): void;\r\n    getShape(body: PhysicsBody): Nullable<PhysicsShape>;\r\n    getShapeType(shape: PhysicsShape): PhysicsShapeType;\r\n    setEventMask(body: PhysicsBody, eventMask: number, instanceIndex?: number): void;\r\n    getEventMask(body: PhysicsBody, instanceIndex?: number): number;\r\n    setMotionType(body: PhysicsBody, motionType: PhysicsMotionType, instanceIndex?: number): void;\r\n    getMotionType(body: PhysicsBody, instanceIndex?: number): PhysicsMotionType;\r\n    computeMassProperties(body: PhysicsBody, instanceIndex?: number): PhysicsMassProperties;\r\n    setMassProperties(body: PhysicsBody, massProps: PhysicsMassProperties, instanceIndex?: number): void;\r\n    getMassProperties(body: PhysicsBody, instanceIndex?: number): PhysicsMassProperties;\r\n    setLinearDamping(body: PhysicsBody, damping: number, instanceIndex?: number): void;\r\n    getLinearDamping(body: PhysicsBody, instanceIndex?: number): number;\r\n    setAngularDamping(body: PhysicsBody, damping: number, instanceIndex?: number): void;\r\n    getAngularDamping(body: PhysicsBody, instanceIndex?: number): number;\r\n    setLinearVelocity(body: PhysicsBody, linVel: Vector3, instanceIndex?: number): void;\r\n    getLinearVelocityToRef(body: PhysicsBody, linVel: Vector3, instanceIndex?: number): void;\r\n    applyImpulse(body: PhysicsBody, impulse: Vector3, location: Vector3, instanceIndex?: number): void;\r\n    applyForce(body: PhysicsBody, force: Vector3, location: Vector3, instanceIndex?: number): void;\r\n    setAngularVelocity(body: PhysicsBody, angVel: Vector3, instanceIndex?: number): void;\r\n    getAngularVelocityToRef(body: PhysicsBody, angVel: Vector3, instanceIndex?: number): void;\r\n    getBodyGeometry(body: PhysicsBody): {};\r\n    disposeBody(body: PhysicsBody): void;\r\n    setCollisionCallbackEnabled(body: PhysicsBody, enabled: boolean, instanceIndex?: number): void;\r\n    setCollisionEndedCallbackEnabled(body: PhysicsBody, enabled: boolean, instanceIndex?: number): void;\r\n    addConstraint(body: PhysicsBody, childBody: PhysicsBody, constraint: PhysicsConstraint, instanceIndex?: number, childInstanceIndex?: number): void;\r\n    getCollisionObservable(body: PhysicsBody, instanceIndex?: number): Observable<IPhysicsCollisionEvent>;\r\n    getCollisionEndedObservable(body: PhysicsBody, instanceIndex?: number): Observable<IBasePhysicsCollisionEvent>;\r\n    setGravityFactor(body: PhysicsBody, factor: number, instanceIndex?: number): void;\r\n    getGravityFactor(body: PhysicsBody, instanceIndex?: number): number;\r\n    setTargetTransform(body: PhysicsBody, position: Vector3, rotation: Quaternion, instanceIndex?: number): void;\r\n\r\n    // shape\r\n    initShape(shape: PhysicsShape, type: PhysicsShapeType, options: PhysicsShapeParameters): void;\r\n    setShapeFilterMembershipMask(shape: PhysicsShape, membershipMask: number): void;\r\n    getShapeFilterMembershipMask(shape: PhysicsShape): number;\r\n    setShapeFilterCollideMask(shape: PhysicsShape, collideMask: number): void;\r\n    getShapeFilterCollideMask(shape: PhysicsShape): number;\r\n    setMaterial(shape: PhysicsShape, material: PhysicsMaterial): void;\r\n    setDensity(shape: PhysicsShape, density: number): void;\r\n    getDensity(shape: PhysicsShape): number;\r\n    addChild(shape: PhysicsShape, newChild: PhysicsShape, translation?: Vector3, rotation?: Quaternion, scale?: Vector3): void;\r\n    removeChild(shape: PhysicsShape, childIndex: number): void;\r\n    getNumChildren(shape: PhysicsShape): number;\r\n    getBoundingBox(shape: PhysicsShape): BoundingBox;\r\n    disposeShape(shape: PhysicsShape): void;\r\n    setTrigger(shape: PhysicsShape, isTrigger: boolean): void;\r\n\r\n    // constraint\r\n    initConstraint(constraint: PhysicsConstraint, body: PhysicsBody, childBody: PhysicsBody): void;\r\n    setEnabled(constraint: PhysicsConstraint, isEnabled: boolean): void;\r\n    getEnabled(constraint: PhysicsConstraint): boolean;\r\n    setCollisionsEnabled(constraint: PhysicsConstraint, isEnabled: boolean): void;\r\n    getCollisionsEnabled(constraint: PhysicsConstraint): boolean;\r\n    setAxisFriction(constraint: PhysicsConstraint, axis: PhysicsConstraintAxis, friction: number): void;\r\n    getAxisFriction(constraint: PhysicsConstraint, axis: PhysicsConstraintAxis): Nullable<number>;\r\n    setAxisMode(constraint: PhysicsConstraint, axis: PhysicsConstraintAxis, limitMode: PhysicsConstraintAxisLimitMode): void;\r\n    getAxisMode(constraint: PhysicsConstraint, axis: PhysicsConstraintAxis): Nullable<PhysicsConstraintAxisLimitMode>;\r\n    setAxisMinLimit(constraint: PhysicsConstraint, axis: PhysicsConstraintAxis, minLimit: number): void;\r\n    getAxisMinLimit(constraint: PhysicsConstraint, axis: PhysicsConstraintAxis): Nullable<number>;\r\n    setAxisMaxLimit(constraint: PhysicsConstraint, axis: PhysicsConstraintAxis, limit: number): void;\r\n    getAxisMaxLimit(constraint: PhysicsConstraint, axis: PhysicsConstraintAxis): Nullable<number>;\r\n    setAxisMotorType(constraint: PhysicsConstraint, axis: PhysicsConstraintAxis, motorType: PhysicsConstraintMotorType): void;\r\n    getAxisMotorType(constraint: PhysicsConstraint, axis: PhysicsConstraintAxis): Nullable<PhysicsConstraintMotorType>;\r\n    setAxisMotorTarget(constraint: PhysicsConstraint, axis: PhysicsConstraintAxis, target: number): void;\r\n    getAxisMotorTarget(constraint: PhysicsConstraint, axis: PhysicsConstraintAxis): Nullable<number>;\r\n    setAxisMotorMaxForce(constraint: PhysicsConstraint, axis: PhysicsConstraintAxis, maxForce: number): void;\r\n    getAxisMotorMaxForce(constraint: PhysicsConstraint, axis: PhysicsConstraintAxis): Nullable<number>;\r\n    disposeConstraint(constraint: PhysicsConstraint): void;\r\n    getBodiesUsingConstraint(constraint: PhysicsConstraint): ConstrainedBodyPair[];\r\n\r\n    // raycast\r\n    raycast(from: Vector3, to: Vector3, result: PhysicsRaycastResult, query?: IRaycastQuery): void;\r\n\r\n    dispose(): void;\r\n}\r\n"]}