{"version":3,"file":"joinedPhysicsEngineComponent.js","sourceRoot":"","sources":["../../../../dev/core/src/Physics/joinedPhysicsEngineComponent.ts"],"names":[],"mappings":"AACA,OAAO,EAAE,MAAM,EAAE,MAAM,gBAAgB,CAAC;AACxC,OAAO,EAAE,UAAU,EAAE,MAAM,oBAAoB,CAAC;AAIhD,OAAO,EAAE,uBAAuB,EAAE,MAAM,mBAAmB,CAAC;AAC5D,OAAO,EAAE,KAAK,EAAE,MAAM,UAAU,CAAC;AAIjC,OAAO,EAAE,aAAa,IAAI,eAAe,EAAE,MAAM,oBAAoB,CAAC;AACtE,OAAO,EAAE,aAAa,IAAI,eAAe,EAAE,MAAM,oBAAoB,CAAC;AAuDtE;;;GAGG;AACH,KAAK,CAAC,SAAS,CAAC,gBAAgB,GAAG;IAC/B,OAAO,IAAI,CAAC,cAAc,CAAC;AAC/B,CAAC,CAAC;AAEF;;;;;GAKG;AACH,KAAK,CAAC,SAAS,CAAC,aAAa,GAAG,UAAU,UAA6B,IAAI,EAAE,MAAwD;IACjI,IAAI,IAAI,CAAC,cAAc,EAAE;QACrB,OAAO,IAAI,CAAC;KACf;IAED,sCAAsC;IACtC,IAAI,SAAS,GAAG,IAAI,CAAC,aAAa,CAAC,uBAAuB,CAAC,kBAAkB,CAAgC,CAAC;IAC9G,IAAI,CAAC,SAAS,EAAE;QACZ,SAAS,GAAG,IAAI,2BAA2B,CAAC,IAAI,CAAC,CAAC;QAClD,IAAI,CAAC,aAAa,CAAC,SAAS,CAAC,CAAC;KACjC;IAED,IAAI;QACA,IAAI,CAAC,MAAM,IAAI,CAAA,MAAM,aAAN,MAAM,uBAAN,MAAM,CAAE,gBAAgB,EAAE,MAAK,CAAC,EAAE;YAC7C,IAAI,CAAC,cAAc,GAAG,IAAI,eAAe,CAAC,OAAO,EAAE,MAAgC,CAAC,CAAC;SACxF;aAAM,IAAI,CAAA,MAAM,aAAN,MAAM,uBAAN,MAAM,CAAE,gBAAgB,EAAE,MAAK,CAAC,EAAE;YACzC,IAAI,CAAC,cAAc,GAAG,IAAI,eAAe,CAAC,OAAO,EAAE,MAAgC,CAAC,CAAC;SACxF;aAAM;YACH,MAAM,IAAI,KAAK,CAAC,qCAAqC,CAAC,CAAC;SAC1D;QACD,IAAI,CAAC,uBAAuB,GAAG,CAAC,CAAC;QACjC,OAAO,IAAI,CAAC;KACf;IAAC,OAAO,CAAC,EAAE;QACR,MAAM,CAAC,KAAK,CAAC,CAAC,CAAC,OAAO,CAAC,CAAC;QACxB,OAAO,KAAK,CAAC;KAChB;AACL,CAAC,CAAC;AAEF;;GAEG;AACH,KAAK,CAAC,SAAS,CAAC,oBAAoB,GAAG;IACnC,IAAI,CAAC,IAAI,CAAC,cAAc,EAAE;QACtB,OAAO;KACV;IAED,IAAI,CAAC,cAAc,CAAC,OAAO,EAAE,CAAC;IAC9B,IAAI,CAAC,cAAc,GAAG,IAAI,CAAC;AAC/B,CAAC,CAAC;AAEF;;;GAGG;AACH,KAAK,CAAC,SAAS,CAAC,gBAAgB,GAAG;IAC/B,OAAO,IAAI,CAAC,cAAc,KAAK,SAAS,CAAC;AAC7C,CAAC,CAAC;AAEF;;;GAGG;AACH,KAAK,CAAC,SAAS,CAAC,sBAAsB,GAAG,UAAU,QAAa;IAC5D,MAAM,IAAI,GAAiB,QAAQ,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC;IAElD,IAAI,IAAI,CAAC,eAAe,EAAE;QACtB,IAAI,CAAC,eAAe,CAAC,OAAO,EAAC,QAAQ,CAAC,CAAC;QACvC,IAAI,CAAC,eAAe,GAAG,IAAI,CAAC;KAC/B;AACL,CAAC,CAAC;AAEF;;GAEG;AACH,KAAK,CAAC,SAAS,CAAC,yBAAyB,GAAG,UAAU,IAAY;IAC9D,IAAI,IAAI,CAAC,cAAc,EAAE;QACrB,MAAM,OAAO,GAAG,IAAI,CAAC,cAAc,CAAC,cAAc,EAAE,CAAC;QACrD,IAAI,OAAO,GAAG,CAAC,EAAE;YACb,IAAI,CAAC,uBAAuB,IAAI,IAAI,CAAC;YACrC,OAAO,IAAI,CAAC,uBAAuB,GAAG,OAAO,EAAE;gBAC3C,IAAI,CAAC,yBAAyB,CAAC,eAAe,CAAC,IAAI,CAAC,CAAC;gBACrD,IAAI,CAAC,cAAc,CAAC,KAAK,CAAC,OAAO,GAAG,IAAI,CAAC,CAAC;gBAC1C,IAAI,CAAC,wBAAwB,CAAC,eAAe,CAAC,IAAI,CAAC,CAAC;gBACpD,IAAI,CAAC,uBAAuB,IAAI,OAAO,CAAC;aAC3C;SACJ;aAAM;YACH,IAAI,CAAC,yBAAyB,CAAC,eAAe,CAAC,IAAI,CAAC,CAAC;YACrD,IAAI,CAAC,cAAc,CAAC,KAAK,CAAC,IAAI,GAAG,IAAI,CAAC,CAAC;YACvC,IAAI,CAAC,wBAAwB,CAAC,eAAe,CAAC,IAAI,CAAC,CAAC;SACvD;KACJ;AACL,CAAC,CAAC;AAEF;;GAEG;AACH,MAAM,OAAO,2BAA2B;IAWpC;;;OAGG;IACH,YAAY,KAAY;QAdxB;;WAEG;QACa,SAAI,GAAG,uBAAuB,CAAC,kBAAkB,CAAC;QAY9D,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC;QACnB,IAAI,CAAC,KAAK,CAAC,yBAAyB,GAAG,IAAI,UAAU,EAAS,CAAC;QAC/D,IAAI,CAAC,KAAK,CAAC,wBAAwB,GAAG,IAAI,UAAU,EAAS,CAAC;QAE9D,gEAAgE;QAChE,IAAI,CAAC,KAAK,CAAC,yBAAyB,GAAG,GAAG,EAAE;YACxC,IAAI,IAAI,CAAC,KAAK,CAAC,cAAc,EAAE;gBAC3B,OAAO,IAAI,CAAC,KAAK,CAAC,cAAc,CAAC,WAAW,EAAE,GAAG,IAAI,CAAC;aACzD;YAED,OAAO,MAAM,GAAG,IAAI,CAAC;QACzB,CAAC,CAAC;IACN,CAAC;IAED;;OAEG;IACI,QAAQ,KAAU,CAAC;IAE1B;;;OAGG;IACI,OAAO;QACV,mCAAmC;IACvC,CAAC;IAED;;OAEG;IACI,OAAO;QACV,IAAI,CAAC,KAAK,CAAC,yBAAyB,CAAC,KAAK,EAAE,CAAC;QAC7C,IAAI,CAAC,KAAK,CAAC,wBAAwB,CAAC,KAAK,EAAE,CAAC;QAE5C,IAAI,IAAI,CAAC,KAAK,CAAC,cAAc,EAAE;YAC3B,IAAI,CAAC,KAAK,CAAC,oBAAoB,EAAE,CAAC;SACrC;IACL,CAAC;CACJ","sourcesContent":["import type { Nullable } from \"../types\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport type { Vector3 } from \"../Maths/math.vector\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport type { ISceneComponent } from \"../sceneComponent\";\r\nimport { SceneComponentConstants } from \"../sceneComponent\";\r\nimport { Scene } from \"../scene\";\r\nimport type { IPhysicsEngine } from \"./IPhysicsEngine\";\r\nimport type { IPhysicsEnginePlugin as IPhysicsEnginePluginV1 } from \"./v1/IPhysicsEnginePlugin\";\r\nimport type { IPhysicsEnginePluginV2 } from \"./v2/IPhysicsEnginePlugin\";\r\nimport { PhysicsEngine as PhysicsEngineV1 } from \"./v1/physicsEngine\";\r\nimport { PhysicsEngine as PhysicsEngineV2 } from \"./v2/physicsEngine\";\r\n\r\ndeclare module \"../scene\" {\r\n    /**\r\n     *\r\n     */\r\n    export interface Scene {\r\n        /** @internal (Backing field) */\r\n        _physicsEngine: Nullable<IPhysicsEngine>;\r\n        /** @internal */\r\n        _physicsTimeAccumulator: number;\r\n\r\n        /**\r\n         * Gets the current physics engine\r\n         * @returns a IPhysicsEngine or null if none attached\r\n         */\r\n        getPhysicsEngine(): Nullable<IPhysicsEngine>;\r\n\r\n        /**\r\n         * Enables physics to the current scene\r\n         * @param gravity defines the scene's gravity for the physics engine. defaults to real earth gravity : (0, -9.81, 0)\r\n         * @param plugin defines the physics engine to be used. defaults to CannonJS.\r\n         * @returns a boolean indicating if the physics engine was initialized\r\n         */\r\n        enablePhysics(gravity?: Nullable<Vector3>, plugin?: IPhysicsEnginePluginV1 | IPhysicsEnginePluginV2): boolean;\r\n\r\n        /**\r\n         * Disables and disposes the physics engine associated with the scene\r\n         */\r\n        disablePhysicsEngine(): void;\r\n\r\n        /**\r\n         * Gets a boolean indicating if there is an active physics engine\r\n         * @returns a boolean indicating if there is an active physics engine\r\n         */\r\n        isPhysicsEnabled(): boolean;\r\n\r\n        /**\r\n         * Deletes a physics compound impostor\r\n         * @param compound defines the compound to delete\r\n         */\r\n        deleteCompoundImpostor(compound: any): void;\r\n\r\n        /**\r\n         * An event triggered when physic simulation is about to be run\r\n         */\r\n        onBeforePhysicsObservable: Observable<Scene>;\r\n\r\n        /**\r\n         * An event triggered when physic simulation has been done\r\n         */\r\n        onAfterPhysicsObservable: Observable<Scene>;\r\n    }\r\n}\r\n\r\n/**\r\n * Gets the current physics engine\r\n * @returns a IPhysicsEngine or null if none attached\r\n */\r\nScene.prototype.getPhysicsEngine = function (): Nullable<IPhysicsEngine> {\r\n    return this._physicsEngine;\r\n};\r\n\r\n/**\r\n * Enables physics to the current scene\r\n * @param gravity defines the scene's gravity for the physics engine\r\n * @param plugin defines the physics engine to be used. defaults to CannonJS.\r\n * @returns a boolean indicating if the physics engine was initialized\r\n */\r\nScene.prototype.enablePhysics = function (gravity: Nullable<Vector3> = null, plugin?: IPhysicsEnginePluginV1 | IPhysicsEnginePluginV2): boolean {\r\n    if (this._physicsEngine) {\r\n        return true;\r\n    }\r\n\r\n    // Register the component to the scene\r\n    let component = this._getComponent(SceneComponentConstants.NAME_PHYSICSENGINE) as PhysicsEngineSceneComponent;\r\n    if (!component) {\r\n        component = new PhysicsEngineSceneComponent(this);\r\n        this._addComponent(component);\r\n    }\r\n\r\n    try {\r\n        if (!plugin || plugin?.getPluginVersion() === 1) {\r\n            this._physicsEngine = new PhysicsEngineV1(gravity, plugin as IPhysicsEnginePluginV1);\r\n        } else if (plugin?.getPluginVersion() === 2) {\r\n            this._physicsEngine = new PhysicsEngineV2(gravity, plugin as IPhysicsEnginePluginV2);\r\n        } else {\r\n            throw new Error(\"Unsupported Physics plugin version.\");\r\n        }\r\n        this._physicsTimeAccumulator = 0;\r\n        return true;\r\n    } catch (e) {\r\n        Logger.Error(e.message);\r\n        return false;\r\n    }\r\n};\r\n\r\n/**\r\n * Disables and disposes the physics engine associated with the scene\r\n */\r\nScene.prototype.disablePhysicsEngine = function (): void {\r\n    if (!this._physicsEngine) {\r\n        return;\r\n    }\r\n\r\n    this._physicsEngine.dispose();\r\n    this._physicsEngine = null;\r\n};\r\n\r\n/**\r\n * Gets a boolean indicating if there is an active physics engine\r\n * @returns a boolean indicating if there is an active physics engine\r\n */\r\nScene.prototype.isPhysicsEnabled = function (): boolean {\r\n    return this._physicsEngine !== undefined;\r\n};\r\n\r\n/**\r\n * Deletes a physics compound impostor\r\n * @param compound defines the compound to delete\r\n */\r\nScene.prototype.deleteCompoundImpostor = function (compound: any): void {\r\n    const mesh: AbstractMesh = compound.parts[0].mesh;\r\n\r\n    if (mesh.physicsImpostor) {\r\n        mesh.physicsImpostor.dispose(/*true*/);\r\n        mesh.physicsImpostor = null;\r\n    }\r\n};\r\n\r\n/**\r\n * @internal\r\n */\r\nScene.prototype._advancePhysicsEngineStep = function (step: number) {\r\n    if (this._physicsEngine) {\r\n        const subTime = this._physicsEngine.getSubTimeStep();\r\n        if (subTime > 0) {\r\n            this._physicsTimeAccumulator += step;\r\n            while (this._physicsTimeAccumulator > subTime) {\r\n                this.onBeforePhysicsObservable.notifyObservers(this);\r\n                this._physicsEngine._step(subTime / 1000);\r\n                this.onAfterPhysicsObservable.notifyObservers(this);\r\n                this._physicsTimeAccumulator -= subTime;\r\n            }\r\n        } else {\r\n            this.onBeforePhysicsObservable.notifyObservers(this);\r\n            this._physicsEngine._step(step / 1000);\r\n            this.onAfterPhysicsObservable.notifyObservers(this);\r\n        }\r\n    }\r\n};\r\n\r\n/**\r\n * Defines the physics engine scene component responsible to manage a physics engine\r\n */\r\nexport class PhysicsEngineSceneComponent implements ISceneComponent {\r\n    /**\r\n     * The component name helpful to identify the component in the list of scene components.\r\n     */\r\n    public readonly name = SceneComponentConstants.NAME_PHYSICSENGINE;\r\n\r\n    /**\r\n     * The scene the component belongs to.\r\n     */\r\n    public scene: Scene;\r\n\r\n    /**\r\n     * Creates a new instance of the component for the given scene\r\n     * @param scene Defines the scene to register the component in\r\n     */\r\n    constructor(scene: Scene) {\r\n        this.scene = scene;\r\n        this.scene.onBeforePhysicsObservable = new Observable<Scene>();\r\n        this.scene.onAfterPhysicsObservable = new Observable<Scene>();\r\n\r\n        // Replace the function used to get the deterministic frame time\r\n        this.scene.getDeterministicFrameTime = () => {\r\n            if (this.scene._physicsEngine) {\r\n                return this.scene._physicsEngine.getTimeStep() * 1000;\r\n            }\r\n\r\n            return 1000.0 / 60.0;\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Registers the component in a given scene\r\n     */\r\n    public register(): void {}\r\n\r\n    /**\r\n     * Rebuilds the elements related to this component in case of\r\n     * context lost for instance.\r\n     */\r\n    public rebuild(): void {\r\n        // Nothing to do for this component\r\n    }\r\n\r\n    /**\r\n     * Disposes the component and the associated resources\r\n     */\r\n    public dispose(): void {\r\n        this.scene.onBeforePhysicsObservable.clear();\r\n        this.scene.onAfterPhysicsObservable.clear();\r\n\r\n        if (this.scene._physicsEngine) {\r\n            this.scene.disablePhysicsEngine();\r\n        }\r\n    }\r\n}\r\n"]}