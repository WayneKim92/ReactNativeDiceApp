{"version":3,"file":"mesh.vertexData.js","sourceRoot":"","sources":["../../../../dev/core/src/Meshes/mesh.vertexData.ts"],"names":[],"mappings":"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","sourcesContent":["/* eslint-disable @typescript-eslint/no-unused-vars */\r\nimport type { Nullable, FloatArray, IndicesArray, DeepImmutable } from \"../types\";\r\nimport type { Matrix, Vector2 } from \"../Maths/math.vector\";\r\nimport { Vector3, Vector4, TmpVectors } from \"../Maths/math.vector\";\r\nimport { VertexBuffer } from \"../Buffers/buffer\";\r\nimport { _WarnImport } from \"../Misc/devTools\";\r\nimport type { Color3 } from \"../Maths/math.color\";\r\nimport { Color4 } from \"../Maths/math.color\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport { nativeOverride } from \"../Misc/decorators\";\r\nimport type { Coroutine } from \"../Misc/coroutine\";\r\nimport { makeSyncFunction, runCoroutineSync } from \"../Misc/coroutine\";\r\nimport type { ICreateCapsuleOptions } from \"./Builders/capsuleBuilder\";\r\nimport { RuntimeError, ErrorCodes } from \"../Misc/error\";\r\n\r\nimport type { Geometry } from \"../Meshes/geometry\";\r\nimport type { Mesh } from \"../Meshes/mesh\";\r\nimport { SubMesh } from \"./subMesh\";\r\n\r\n/**\r\n * Define an interface for all classes that will get and set the data on vertices\r\n */\r\nexport interface IGetSetVerticesData {\r\n    /**\r\n     * Gets a boolean indicating if specific vertex data is present\r\n     * @param kind defines the vertex data kind to use\r\n     * @returns true is data kind is present\r\n     */\r\n    isVerticesDataPresent(kind: string): boolean;\r\n    /**\r\n     * Gets a specific vertex data attached to this geometry. Float data is constructed if the vertex buffer data cannot be returned directly.\r\n     * @param kind defines the data kind (Position, normal, etc...)\r\n     * @param copyWhenShared defines if the returned array must be cloned upon returning it if the current geometry is shared between multiple meshes\r\n     * @param forceCopy defines a boolean indicating that the returned array must be cloned upon returning it\r\n     * @returns a float array containing vertex data\r\n     */\r\n    getVerticesData(kind: string, copyWhenShared?: boolean, forceCopy?: boolean): Nullable<FloatArray>;\r\n    /**\r\n     * Returns an array of integers or a typed array (Int32Array, Uint32Array, Uint16Array) populated with the mesh indices.\r\n     * @param copyWhenShared If true (default false) and and if the mesh geometry is shared among some other meshes, the returned array is a copy of the internal one.\r\n     * @param forceCopy defines a boolean indicating that the returned array must be cloned upon returning it\r\n     * @returns the indices array or an empty array if the mesh has no geometry\r\n     */\r\n    getIndices(copyWhenShared?: boolean, forceCopy?: boolean): Nullable<IndicesArray>;\r\n    /**\r\n     * Set specific vertex data\r\n     * @param kind defines the data kind (Position, normal, etc...)\r\n     * @param data defines the vertex data to use\r\n     * @param updatable defines if the vertex must be flagged as updatable (false as default)\r\n     * @param stride defines the stride to use (0 by default). This value is deduced from the kind value if not specified\r\n     */\r\n    setVerticesData(kind: string, data: FloatArray, updatable: boolean): void;\r\n    /**\r\n     * Update a specific associated vertex buffer\r\n     * @param kind defines which buffer to write to (positions, indices, normals, etc). Possible `kind` values :\r\n     * - VertexBuffer.PositionKind\r\n     * - VertexBuffer.UVKind\r\n     * - VertexBuffer.UV2Kind\r\n     * - VertexBuffer.UV3Kind\r\n     * - VertexBuffer.UV4Kind\r\n     * - VertexBuffer.UV5Kind\r\n     * - VertexBuffer.UV6Kind\r\n     * - VertexBuffer.ColorKind\r\n     * - VertexBuffer.MatricesIndicesKind\r\n     * - VertexBuffer.MatricesIndicesExtraKind\r\n     * - VertexBuffer.MatricesWeightsKind\r\n     * - VertexBuffer.MatricesWeightsExtraKind\r\n     * @param data defines the data source\r\n     * @param updateExtends defines if extends info of the mesh must be updated (can be null). This is mostly useful for \"position\" kind\r\n     * @param makeItUnique defines if the geometry associated with the mesh must be cloned to make the change only for this mesh (and not all meshes associated with the same geometry)\r\n     */\r\n    updateVerticesData(kind: string, data: FloatArray, updateExtends?: boolean, makeItUnique?: boolean): void;\r\n    /**\r\n     * Creates a new index buffer\r\n     * @param indices defines the indices to store in the index buffer\r\n     * @param totalVertices defines the total number of vertices (could be null)\r\n     * @param updatable defines if the index buffer must be flagged as updatable (false by default)\r\n     */\r\n    setIndices(indices: IndicesArray, totalVertices: Nullable<number>, updatable?: boolean): void;\r\n}\r\n\r\n/** Class used to attach material info to sub section of a vertex data class */\r\nexport class VertexDataMaterialInfo {\r\n    /** Defines the material index to use */\r\n    public materialIndex: number;\r\n    /** Defines vertex index start*/\r\n    public verticesStart: number;\r\n    /** Defines vertices count */\r\n    public verticesCount: number;\r\n    /** Defines index start */\r\n    public indexStart: number;\r\n    /** Defines indices count */\r\n    public indexCount: number;\r\n}\r\n\r\n/**\r\n * This class contains the various kinds of data on every vertex of a mesh used in determining its shape and appearance\r\n */\r\nexport class VertexData {\r\n    /**\r\n     * Mesh side orientation : usually the external or front surface\r\n     */\r\n    public static readonly FRONTSIDE = 0;\r\n    /**\r\n     * Mesh side orientation : usually the internal or back surface\r\n     */\r\n    public static readonly BACKSIDE = 1;\r\n    /**\r\n     * Mesh side orientation : both internal and external or front and back surfaces\r\n     */\r\n    public static readonly DOUBLESIDE = 2;\r\n    /**\r\n     * Mesh side orientation : by default, `FRONTSIDE`\r\n     */\r\n    public static readonly DEFAULTSIDE = 0;\r\n\r\n    private static _UniqueIDGenerator = 0;\r\n\r\n    /**\r\n     * An array of the x, y, z position of each vertex  [...., x, y, z, .....]\r\n     */\r\n    public positions: Nullable<FloatArray>;\r\n\r\n    /**\r\n     * An array of the x, y, z normal vector of each vertex  [...., x, y, z, .....]\r\n     */\r\n    public normals: Nullable<FloatArray>;\r\n\r\n    /**\r\n     * An array of the x, y, z tangent vector of each vertex  [...., x, y, z, .....]\r\n     */\r\n    public tangents: Nullable<FloatArray>;\r\n\r\n    /**\r\n     * An array of u,v which maps a texture image onto each vertex  [...., u, v, .....]\r\n     */\r\n    public uvs: Nullable<FloatArray>;\r\n\r\n    /**\r\n     * A second array of u,v which maps a texture image onto each vertex  [...., u, v, .....]\r\n     */\r\n    public uvs2: Nullable<FloatArray>;\r\n\r\n    /**\r\n     * A third array of u,v which maps a texture image onto each vertex  [...., u, v, .....]\r\n     */\r\n    public uvs3: Nullable<FloatArray>;\r\n\r\n    /**\r\n     * A fourth array of u,v which maps a texture image onto each vertex  [...., u, v, .....]\r\n     */\r\n    public uvs4: Nullable<FloatArray>;\r\n\r\n    /**\r\n     * A fifth array of u,v which maps a texture image onto each vertex  [...., u, v, .....]\r\n     */\r\n    public uvs5: Nullable<FloatArray>;\r\n\r\n    /**\r\n     * A sixth array of u,v which maps a texture image onto each vertex  [...., u, v, .....]\r\n     */\r\n    public uvs6: Nullable<FloatArray>;\r\n\r\n    /**\r\n     * An array of the r, g, b, a, color of each vertex  [...., r, g, b, a, .....]\r\n     */\r\n    public colors: Nullable<FloatArray>;\r\n\r\n    /**\r\n     * An array containing the list of indices to the array of matrices produced by bones, each vertex have up to 4 indices (8 if the matricesIndicesExtra is set).\r\n     */\r\n    public matricesIndices: Nullable<FloatArray>;\r\n\r\n    /**\r\n     * An array containing the list of weights defining the weight of each indexed matrix in the final computation\r\n     */\r\n    public matricesWeights: Nullable<FloatArray>;\r\n\r\n    /**\r\n     * An array extending the number of possible indices\r\n     */\r\n    public matricesIndicesExtra: Nullable<FloatArray>;\r\n\r\n    /**\r\n     * An array extending the number of possible weights when the number of indices is extended\r\n     */\r\n    public matricesWeightsExtra: Nullable<FloatArray>;\r\n\r\n    /**\r\n     * An array of i, j, k the three vertex indices required for each triangular facet  [...., i, j, k .....]\r\n     */\r\n    public indices: Nullable<IndicesArray>;\r\n\r\n    /**\r\n     * An array defining material association for sub sections of the vertex data\r\n     */\r\n    public materialInfos: Nullable<Array<VertexDataMaterialInfo>>;\r\n\r\n    /**\r\n     * Gets the unique ID of this vertex Data\r\n     */\r\n    public uniqueId = 0;\r\n\r\n    /**\r\n     * Metadata used to store contextual values\r\n     */\r\n    public metadata: any = {};\r\n\r\n    /**\r\n     * Creates a new VertexData\r\n     */\r\n    public constructor() {\r\n        this.uniqueId = VertexData._UniqueIDGenerator;\r\n        VertexData._UniqueIDGenerator++;\r\n    }\r\n\r\n    /**\r\n     * Uses the passed data array to set the set the values for the specified kind of data\r\n     * @param data a linear array of floating numbers\r\n     * @param kind the type of data that is being set, eg positions, colors etc\r\n     */\r\n    public set(data: FloatArray, kind: string) {\r\n        if (!data.length) {\r\n            Logger.Warn(`Setting vertex data kind '${kind}' with an empty array`);\r\n        }\r\n\r\n        switch (kind) {\r\n            case VertexBuffer.PositionKind:\r\n                this.positions = data;\r\n                break;\r\n            case VertexBuffer.NormalKind:\r\n                this.normals = data;\r\n                break;\r\n            case VertexBuffer.TangentKind:\r\n                this.tangents = data;\r\n                break;\r\n            case VertexBuffer.UVKind:\r\n                this.uvs = data;\r\n                break;\r\n            case VertexBuffer.UV2Kind:\r\n                this.uvs2 = data;\r\n                break;\r\n            case VertexBuffer.UV3Kind:\r\n                this.uvs3 = data;\r\n                break;\r\n            case VertexBuffer.UV4Kind:\r\n                this.uvs4 = data;\r\n                break;\r\n            case VertexBuffer.UV5Kind:\r\n                this.uvs5 = data;\r\n                break;\r\n            case VertexBuffer.UV6Kind:\r\n                this.uvs6 = data;\r\n                break;\r\n            case VertexBuffer.ColorKind:\r\n                this.colors = data;\r\n                break;\r\n            case VertexBuffer.MatricesIndicesKind:\r\n                this.matricesIndices = data;\r\n                break;\r\n            case VertexBuffer.MatricesWeightsKind:\r\n                this.matricesWeights = data;\r\n                break;\r\n            case VertexBuffer.MatricesIndicesExtraKind:\r\n                this.matricesIndicesExtra = data;\r\n                break;\r\n            case VertexBuffer.MatricesWeightsExtraKind:\r\n                this.matricesWeightsExtra = data;\r\n                break;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Associates the vertexData to the passed Mesh.\r\n     * Sets it as updatable or not (default `false`)\r\n     * @param mesh the mesh the vertexData is applied to\r\n     * @param updatable when used and having the value true allows new data to update the vertexData\r\n     * @returns the VertexData\r\n     */\r\n    public applyToMesh(mesh: Mesh, updatable?: boolean): VertexData {\r\n        this._applyTo(mesh, updatable, false);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Associates the vertexData to the passed Geometry.\r\n     * Sets it as updatable or not (default `false`)\r\n     * @param geometry the geometry the vertexData is applied to\r\n     * @param updatable when used and having the value true allows new data to update the vertexData\r\n     * @returns VertexData\r\n     */\r\n    public applyToGeometry(geometry: Geometry, updatable?: boolean): VertexData {\r\n        this._applyTo(geometry, updatable, false);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Updates the associated mesh\r\n     * @param mesh the mesh to be updated\r\n     * @returns VertexData\r\n     */\r\n    public updateMesh(mesh: Mesh): VertexData {\r\n        this._update(mesh);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Updates the associated geometry\r\n     * @param geometry the geometry to be updated\r\n     * @returns VertexData.\r\n     */\r\n    public updateGeometry(geometry: Geometry): VertexData {\r\n        this._update(geometry);\r\n        return this;\r\n    }\r\n\r\n    private readonly _applyTo = makeSyncFunction(this._applyToCoroutine.bind(this));\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public *_applyToCoroutine(meshOrGeometry: IGetSetVerticesData, updatable: boolean = false, isAsync: boolean): Coroutine<VertexData> {\r\n        if (this.positions) {\r\n            meshOrGeometry.setVerticesData(VertexBuffer.PositionKind, this.positions, updatable);\r\n            if (isAsync) {\r\n                yield;\r\n            }\r\n        }\r\n\r\n        if (this.normals) {\r\n            meshOrGeometry.setVerticesData(VertexBuffer.NormalKind, this.normals, updatable);\r\n            if (isAsync) {\r\n                yield;\r\n            }\r\n        }\r\n\r\n        if (this.tangents) {\r\n            meshOrGeometry.setVerticesData(VertexBuffer.TangentKind, this.tangents, updatable);\r\n            if (isAsync) {\r\n                yield;\r\n            }\r\n        }\r\n\r\n        if (this.uvs) {\r\n            meshOrGeometry.setVerticesData(VertexBuffer.UVKind, this.uvs, updatable);\r\n            if (isAsync) {\r\n                yield;\r\n            }\r\n        }\r\n\r\n        if (this.uvs2) {\r\n            meshOrGeometry.setVerticesData(VertexBuffer.UV2Kind, this.uvs2, updatable);\r\n            if (isAsync) {\r\n                yield;\r\n            }\r\n        }\r\n\r\n        if (this.uvs3) {\r\n            meshOrGeometry.setVerticesData(VertexBuffer.UV3Kind, this.uvs3, updatable);\r\n            if (isAsync) {\r\n                yield;\r\n            }\r\n        }\r\n\r\n        if (this.uvs4) {\r\n            meshOrGeometry.setVerticesData(VertexBuffer.UV4Kind, this.uvs4, updatable);\r\n            if (isAsync) {\r\n                yield;\r\n            }\r\n        }\r\n\r\n        if (this.uvs5) {\r\n            meshOrGeometry.setVerticesData(VertexBuffer.UV5Kind, this.uvs5, updatable);\r\n            if (isAsync) {\r\n                yield;\r\n            }\r\n        }\r\n\r\n        if (this.uvs6) {\r\n            meshOrGeometry.setVerticesData(VertexBuffer.UV6Kind, this.uvs6, updatable);\r\n            if (isAsync) {\r\n                yield;\r\n            }\r\n        }\r\n\r\n        if (this.colors) {\r\n            meshOrGeometry.setVerticesData(VertexBuffer.ColorKind, this.colors, updatable);\r\n            if (isAsync) {\r\n                yield;\r\n            }\r\n        }\r\n\r\n        if (this.matricesIndices) {\r\n            meshOrGeometry.setVerticesData(VertexBuffer.MatricesIndicesKind, this.matricesIndices, updatable);\r\n            if (isAsync) {\r\n                yield;\r\n            }\r\n        }\r\n\r\n        if (this.matricesWeights) {\r\n            meshOrGeometry.setVerticesData(VertexBuffer.MatricesWeightsKind, this.matricesWeights, updatable);\r\n            if (isAsync) {\r\n                yield;\r\n            }\r\n        }\r\n\r\n        if (this.matricesIndicesExtra) {\r\n            meshOrGeometry.setVerticesData(VertexBuffer.MatricesIndicesExtraKind, this.matricesIndicesExtra, updatable);\r\n            if (isAsync) {\r\n                yield;\r\n            }\r\n        }\r\n\r\n        if (this.matricesWeightsExtra) {\r\n            meshOrGeometry.setVerticesData(VertexBuffer.MatricesWeightsExtraKind, this.matricesWeightsExtra, updatable);\r\n            if (isAsync) {\r\n                yield;\r\n            }\r\n        }\r\n\r\n        if (this.indices) {\r\n            meshOrGeometry.setIndices(this.indices, null, updatable);\r\n            if (isAsync) {\r\n                yield;\r\n            }\r\n        } else {\r\n            meshOrGeometry.setIndices([], null);\r\n        }\r\n\r\n        if ((meshOrGeometry as Mesh).subMeshes && this.materialInfos && this.materialInfos.length > 1) {\r\n            const mesh = meshOrGeometry as Mesh;\r\n            mesh.subMeshes = [];\r\n            for (const matInfo of this.materialInfos) {\r\n                new SubMesh(matInfo.materialIndex, matInfo.verticesStart, matInfo.verticesCount, matInfo.indexStart, matInfo.indexCount, mesh);\r\n            }\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    private _update(meshOrGeometry: IGetSetVerticesData, updateExtends?: boolean, makeItUnique?: boolean): VertexData {\r\n        if (this.positions) {\r\n            meshOrGeometry.updateVerticesData(VertexBuffer.PositionKind, this.positions, updateExtends, makeItUnique);\r\n        }\r\n\r\n        if (this.normals) {\r\n            meshOrGeometry.updateVerticesData(VertexBuffer.NormalKind, this.normals, updateExtends, makeItUnique);\r\n        }\r\n\r\n        if (this.tangents) {\r\n            meshOrGeometry.updateVerticesData(VertexBuffer.TangentKind, this.tangents, updateExtends, makeItUnique);\r\n        }\r\n\r\n        if (this.uvs) {\r\n            meshOrGeometry.updateVerticesData(VertexBuffer.UVKind, this.uvs, updateExtends, makeItUnique);\r\n        }\r\n\r\n        if (this.uvs2) {\r\n            meshOrGeometry.updateVerticesData(VertexBuffer.UV2Kind, this.uvs2, updateExtends, makeItUnique);\r\n        }\r\n\r\n        if (this.uvs3) {\r\n            meshOrGeometry.updateVerticesData(VertexBuffer.UV3Kind, this.uvs3, updateExtends, makeItUnique);\r\n        }\r\n\r\n        if (this.uvs4) {\r\n            meshOrGeometry.updateVerticesData(VertexBuffer.UV4Kind, this.uvs4, updateExtends, makeItUnique);\r\n        }\r\n\r\n        if (this.uvs5) {\r\n            meshOrGeometry.updateVerticesData(VertexBuffer.UV5Kind, this.uvs5, updateExtends, makeItUnique);\r\n        }\r\n\r\n        if (this.uvs6) {\r\n            meshOrGeometry.updateVerticesData(VertexBuffer.UV6Kind, this.uvs6, updateExtends, makeItUnique);\r\n        }\r\n\r\n        if (this.colors) {\r\n            meshOrGeometry.updateVerticesData(VertexBuffer.ColorKind, this.colors, updateExtends, makeItUnique);\r\n        }\r\n\r\n        if (this.matricesIndices) {\r\n            meshOrGeometry.updateVerticesData(VertexBuffer.MatricesIndicesKind, this.matricesIndices, updateExtends, makeItUnique);\r\n        }\r\n\r\n        if (this.matricesWeights) {\r\n            meshOrGeometry.updateVerticesData(VertexBuffer.MatricesWeightsKind, this.matricesWeights, updateExtends, makeItUnique);\r\n        }\r\n\r\n        if (this.matricesIndicesExtra) {\r\n            meshOrGeometry.updateVerticesData(VertexBuffer.MatricesIndicesExtraKind, this.matricesIndicesExtra, updateExtends, makeItUnique);\r\n        }\r\n\r\n        if (this.matricesWeightsExtra) {\r\n            meshOrGeometry.updateVerticesData(VertexBuffer.MatricesWeightsExtraKind, this.matricesWeightsExtra, updateExtends, makeItUnique);\r\n        }\r\n\r\n        if (this.indices) {\r\n            meshOrGeometry.setIndices(this.indices, null);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    @nativeOverride.filter((...[coordinates]: Parameters<typeof VertexData._TransformVector3Coordinates>) => !Array.isArray(coordinates))\r\n    private static _TransformVector3Coordinates(coordinates: FloatArray, transformation: DeepImmutable<Matrix>, offset = 0, length = coordinates.length) {\r\n        const coordinate = TmpVectors.Vector3[0];\r\n        const transformedCoordinate = TmpVectors.Vector3[1];\r\n        for (let index = offset; index < offset + length; index += 3) {\r\n            Vector3.FromArrayToRef(coordinates, index, coordinate);\r\n            Vector3.TransformCoordinatesToRef(coordinate, transformation, transformedCoordinate);\r\n            coordinates[index] = transformedCoordinate.x;\r\n            coordinates[index + 1] = transformedCoordinate.y;\r\n            coordinates[index + 2] = transformedCoordinate.z;\r\n        }\r\n    }\r\n\r\n    @nativeOverride.filter((...[normals]: Parameters<typeof VertexData._TransformVector3Normals>) => !Array.isArray(normals))\r\n    private static _TransformVector3Normals(normals: FloatArray, transformation: DeepImmutable<Matrix>, offset = 0, length = normals.length) {\r\n        const normal = TmpVectors.Vector3[0];\r\n        const transformedNormal = TmpVectors.Vector3[1];\r\n        for (let index = offset; index < offset + length; index += 3) {\r\n            Vector3.FromArrayToRef(normals, index, normal);\r\n            Vector3.TransformNormalToRef(normal, transformation, transformedNormal);\r\n            normals[index] = transformedNormal.x;\r\n            normals[index + 1] = transformedNormal.y;\r\n            normals[index + 2] = transformedNormal.z;\r\n        }\r\n    }\r\n\r\n    @nativeOverride.filter((...[normals]: Parameters<typeof VertexData._TransformVector4Normals>) => !Array.isArray(normals))\r\n    private static _TransformVector4Normals(normals: FloatArray, transformation: DeepImmutable<Matrix>, offset = 0, length = normals.length) {\r\n        const normal = TmpVectors.Vector4[0];\r\n        const transformedNormal = TmpVectors.Vector4[1];\r\n        for (let index = offset; index < offset + length; index += 4) {\r\n            Vector4.FromArrayToRef(normals, index, normal);\r\n            Vector4.TransformNormalToRef(normal, transformation, transformedNormal);\r\n            normals[index] = transformedNormal.x;\r\n            normals[index + 1] = transformedNormal.y;\r\n            normals[index + 2] = transformedNormal.z;\r\n            normals[index + 3] = transformedNormal.w;\r\n        }\r\n    }\r\n\r\n    @nativeOverride.filter((...[indices]: Parameters<typeof VertexData._FlipFaces>) => !Array.isArray(indices))\r\n    private static _FlipFaces(indices: IndicesArray, offset = 0, length = indices.length) {\r\n        for (let index = offset; index < offset + length; index += 3) {\r\n            const tmp = indices[index + 1];\r\n            indices[index + 1] = indices[index + 2];\r\n            indices[index + 2] = tmp;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Transforms each position and each normal of the vertexData according to the passed Matrix\r\n     * @param matrix the transforming matrix\r\n     * @returns the VertexData\r\n     */\r\n    public transform(matrix: Matrix): VertexData {\r\n        const flip = matrix.determinant() < 0;\r\n        if (this.positions) {\r\n            VertexData._TransformVector3Coordinates(this.positions, matrix);\r\n        }\r\n\r\n        if (this.normals) {\r\n            VertexData._TransformVector3Normals(this.normals, matrix);\r\n        }\r\n\r\n        if (this.tangents) {\r\n            VertexData._TransformVector4Normals(this.tangents, matrix);\r\n        }\r\n\r\n        if (flip && this.indices) {\r\n            VertexData._FlipFaces(this.indices);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Generates an array of vertex data where each vertex data only has one material info\r\n     * @returns An array of VertexData\r\n     */\r\n    public splitBasedOnMaterialID() {\r\n        if (!this.materialInfos || this.materialInfos.length < 2) {\r\n            return [this];\r\n        }\r\n\r\n        const result: VertexData[] = [];\r\n        for (const materialInfo of this.materialInfos) {\r\n            const vertexData = new VertexData();\r\n\r\n            if (this.positions) {\r\n                vertexData.positions = this.positions.slice(materialInfo.verticesStart * 3, (materialInfo.verticesCount + materialInfo.verticesStart) * 3);\r\n            }\r\n\r\n            if (this.normals) {\r\n                vertexData.normals = this.normals.slice(materialInfo.verticesStart * 3, (materialInfo.verticesCount + materialInfo.verticesStart) * 3);\r\n            }\r\n\r\n            if (this.tangents) {\r\n                vertexData.tangents = this.tangents.slice(materialInfo.verticesStart * 4, (materialInfo.verticesCount + materialInfo.verticesStart) * 4);\r\n            }\r\n\r\n            if (this.colors) {\r\n                vertexData.colors = this.colors.slice(materialInfo.verticesStart * 4, (materialInfo.verticesCount + materialInfo.verticesStart) * 4);\r\n            }\r\n\r\n            if (this.uvs) {\r\n                vertexData.uvs = this.uvs.slice(materialInfo.verticesStart * 2, (materialInfo.verticesCount + materialInfo.verticesStart) * 2);\r\n            }\r\n\r\n            if (this.uvs2) {\r\n                vertexData.uvs2 = this.uvs2.slice(materialInfo.verticesStart * 2, (materialInfo.verticesCount + materialInfo.verticesStart) * 2);\r\n            }\r\n\r\n            if (this.uvs3) {\r\n                vertexData.uvs3 = this.uvs3.slice(materialInfo.verticesStart * 2, (materialInfo.verticesCount + materialInfo.verticesStart) * 2);\r\n            }\r\n\r\n            if (this.uvs4) {\r\n                vertexData.uvs4 = this.uvs4.slice(materialInfo.verticesStart * 2, (materialInfo.verticesCount + materialInfo.verticesStart) * 2);\r\n            }\r\n\r\n            if (this.uvs5) {\r\n                vertexData.uvs5 = this.uvs5.slice(materialInfo.verticesStart * 2, (materialInfo.verticesCount + materialInfo.verticesStart) * 2);\r\n            }\r\n\r\n            if (this.uvs6) {\r\n                vertexData.uvs6 = this.uvs6.slice(materialInfo.verticesStart * 2, (materialInfo.verticesCount + materialInfo.verticesStart) * 2);\r\n            }\r\n\r\n            if (this.matricesIndices) {\r\n                vertexData.matricesIndices = this.matricesIndices.slice(materialInfo.verticesStart * 4, (materialInfo.verticesCount + materialInfo.verticesStart) * 4);\r\n            }\r\n\r\n            if (this.matricesIndicesExtra) {\r\n                vertexData.matricesIndicesExtra = this.matricesIndicesExtra.slice(materialInfo.verticesStart * 4, (materialInfo.verticesCount + materialInfo.verticesStart) * 4);\r\n            }\r\n\r\n            if (this.matricesWeights) {\r\n                vertexData.matricesWeights = this.matricesWeights.slice(materialInfo.verticesStart * 4, (materialInfo.verticesCount + materialInfo.verticesStart) * 4);\r\n            }\r\n\r\n            if (this.matricesWeightsExtra) {\r\n                vertexData.matricesWeightsExtra = this.matricesWeightsExtra.slice(materialInfo.verticesStart * 4, (materialInfo.verticesCount + materialInfo.verticesStart) * 4);\r\n            }\r\n\r\n            if (this.indices) {\r\n                vertexData.indices = [];\r\n                for (let index = materialInfo.indexStart; index < materialInfo.indexStart + materialInfo.indexCount; index++) {\r\n                    vertexData.indices.push(this.indices[index] - materialInfo.verticesStart);\r\n                }\r\n            }\r\n\r\n            const newMaterialInfo = new VertexDataMaterialInfo();\r\n            newMaterialInfo.indexStart = 0;\r\n            newMaterialInfo.indexCount = vertexData.indices ? vertexData.indices.length : 0;\r\n            newMaterialInfo.materialIndex = materialInfo.materialIndex;\r\n            newMaterialInfo.verticesStart = 0;\r\n            newMaterialInfo.verticesCount = (vertexData.positions ? vertexData.positions.length : 0) / 3;\r\n            vertexData.materialInfos = [newMaterialInfo];\r\n\r\n            result.push(vertexData);\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Merges the passed VertexData into the current one\r\n     * @param others the VertexData to be merged into the current one\r\n     * @param use32BitsIndices defines a boolean indicating if indices must be store in a 32 bits array\r\n     * @param forceCloneIndices defines a boolean indicating if indices are forced to be cloned\r\n     * @param mergeMaterialIds defines a boolean indicating if we need to merge the material infos\r\n     * @param enableCompletion defines a boolean indicating if the vertex data should be completed to be compatible\r\n     * @returns the modified VertexData\r\n     */\r\n    public merge(others: VertexData | VertexData[], use32BitsIndices = false, forceCloneIndices = false, mergeMaterialIds = false, enableCompletion = false) {\r\n        const vertexDatas: { vertexData: VertexData; transform?: Matrix }[] = Array.isArray(others)\r\n            ? others.map((other) => {\r\n                  return { vertexData: other };\r\n              })\r\n            : [{ vertexData: others }];\r\n        return runCoroutineSync(this._mergeCoroutine(undefined, vertexDatas, use32BitsIndices, false, forceCloneIndices, mergeMaterialIds, enableCompletion));\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public *_mergeCoroutine(\r\n        transform: Matrix | undefined,\r\n        vertexDatas: { vertexData: VertexData; transform?: Matrix }[],\r\n        use32BitsIndices = false,\r\n        isAsync: boolean,\r\n        forceCloneIndices: boolean,\r\n        mergeMaterialIds = false,\r\n        enableCompletion = false\r\n    ): Coroutine<VertexData> {\r\n        this._validate();\r\n\r\n        let others = vertexDatas.map((vertexData) => vertexData.vertexData);\r\n        // eslint-disable-next-line @typescript-eslint/no-this-alias\r\n        let root: VertexData = this;\r\n\r\n        for (const other of others) {\r\n            if (!other) {\r\n                continue;\r\n            }\r\n\r\n            other._validate();\r\n\r\n            if (!enableCompletion) {\r\n                if (\r\n                    !this.normals !== !other.normals ||\r\n                    !this.tangents !== !other.tangents ||\r\n                    !this.uvs !== !other.uvs ||\r\n                    !this.uvs2 !== !other.uvs2 ||\r\n                    !this.uvs3 !== !other.uvs3 ||\r\n                    !this.uvs4 !== !other.uvs4 ||\r\n                    !this.uvs5 !== !other.uvs5 ||\r\n                    !this.uvs6 !== !other.uvs6 ||\r\n                    !this.colors !== !other.colors ||\r\n                    !this.matricesIndices !== !other.matricesIndices ||\r\n                    !this.matricesWeights !== !other.matricesWeights ||\r\n                    !this.matricesIndicesExtra !== !other.matricesIndicesExtra ||\r\n                    !this.matricesWeightsExtra !== !other.matricesWeightsExtra\r\n                ) {\r\n                    throw new Error(\"Cannot merge vertex data that do not have the same set of attributes\");\r\n                }\r\n            } else {\r\n                if (!this.normals !== !other.normals) {\r\n                    if (!this.normals) {\r\n                        this.normals = new Float32Array(this.positions!.length);\r\n                    } else {\r\n                        other.normals = new Float32Array(other.positions!.length);\r\n                    }\r\n                }\r\n\r\n                if (!this.tangents !== !other.tangents) {\r\n                    if (!this.tangents) {\r\n                        this.tangents = new Float32Array((this.positions!.length / 3) * 4);\r\n                    } else {\r\n                        other.tangents = new Float32Array((other.positions!.length / 3) * 4);\r\n                    }\r\n                }\r\n                if (!this.uvs !== !other.uvs) {\r\n                    if (!this.uvs) {\r\n                        this.uvs = new Float32Array((this.positions!.length / 3) * 2);\r\n                    } else {\r\n                        other.uvs = new Float32Array((other.positions!.length / 3) * 2);\r\n                    }\r\n                }\r\n\r\n                if (!this.uvs2 !== !other.uvs2) {\r\n                    if (!this.uvs2) {\r\n                        this.uvs2 = new Float32Array((this.positions!.length / 3) * 2);\r\n                    } else {\r\n                        other.uvs2 = new Float32Array((other.positions!.length / 3) * 2);\r\n                    }\r\n                }\r\n\r\n                if (!this.uvs3 !== !other.uvs3) {\r\n                    if (!this.uvs3) {\r\n                        this.uvs3 = new Float32Array((this.positions!.length / 3) * 2);\r\n                    } else {\r\n                        other.uvs3 = new Float32Array((other.positions!.length / 3) * 2);\r\n                    }\r\n                }\r\n\r\n                if (!this.uvs4 !== !other.uvs4) {\r\n                    if (!this.uvs4) {\r\n                        this.uvs4 = new Float32Array((this.positions!.length / 3) * 2);\r\n                    } else {\r\n                        other.uvs4 = new Float32Array((other.positions!.length / 3) * 2);\r\n                    }\r\n                }\r\n                if (!this.uvs5 !== !other.uvs5) {\r\n                    if (!this.uvs5) {\r\n                        this.uvs5 = new Float32Array((this.positions!.length / 3) * 2);\r\n                    } else {\r\n                        other.uvs5 = new Float32Array((other.positions!.length / 3) * 2);\r\n                    }\r\n                }\r\n\r\n                if (!this.uvs6 !== !other.uvs6) {\r\n                    if (!this.uvs6) {\r\n                        this.uvs6 = new Float32Array((this.positions!.length / 3) * 2);\r\n                    } else {\r\n                        other.uvs6 = new Float32Array((other.positions!.length / 3) * 2);\r\n                    }\r\n                }\r\n\r\n                if (!this.colors !== !other.colors) {\r\n                    if (!this.colors) {\r\n                        this.colors = new Float32Array((this.positions!.length / 3) * 4);\r\n                        this.colors.fill(1); // Set to white by default\r\n                    } else {\r\n                        other.colors = new Float32Array((other.positions!.length / 3) * 4);\r\n                        other.colors.fill(1); // Set to white by default\r\n                    }\r\n                }\r\n\r\n                if (!this.matricesIndices !== !other.matricesIndices) {\r\n                    if (!this.matricesIndices) {\r\n                        this.matricesIndices = new Float32Array((this.positions!.length / 3) * 4);\r\n                    } else {\r\n                        other.matricesIndices = new Float32Array((other.positions!.length / 3) * 4);\r\n                    }\r\n                }\r\n                if (!this.matricesWeights !== !other.matricesWeights) {\r\n                    if (!this.matricesWeights) {\r\n                        this.matricesWeights = new Float32Array((this.positions!.length / 3) * 4);\r\n                    } else {\r\n                        other.matricesWeights = new Float32Array((other.positions!.length / 3) * 4);\r\n                    }\r\n                }\r\n\r\n                if (!this.matricesIndicesExtra !== !other.matricesIndicesExtra) {\r\n                    if (!this.matricesIndicesExtra) {\r\n                        this.matricesIndicesExtra = new Float32Array((this.positions!.length / 3) * 4);\r\n                    } else {\r\n                        other.matricesIndicesExtra = new Float32Array((other.positions!.length / 3) * 4);\r\n                    }\r\n                }\r\n\r\n                if (!this.matricesWeightsExtra !== !other.matricesWeightsExtra) {\r\n                    if (!this.matricesWeightsExtra) {\r\n                        this.matricesWeightsExtra = new Float32Array((this.positions!.length / 3) * 4);\r\n                    } else {\r\n                        other.matricesWeightsExtra = new Float32Array((other.positions!.length / 3) * 4);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        if (mergeMaterialIds) {\r\n            // Merge material infos\r\n            let materialIndex = 0;\r\n            let indexOffset = 0;\r\n            let vertexOffset = 0;\r\n            const materialInfos: VertexDataMaterialInfo[] = [];\r\n            let currentMaterialInfo: Nullable<VertexDataMaterialInfo> = null;\r\n            const vertexDataList: { vertexData: VertexData; transform?: Matrix }[] = [];\r\n\r\n            // We need to split vertexData with more than one materialInfo\r\n            for (const split of this.splitBasedOnMaterialID()) {\r\n                vertexDataList.push({ vertexData: split, transform: transform });\r\n            }\r\n\r\n            for (const data of vertexDatas) {\r\n                if (!data.vertexData) {\r\n                    continue;\r\n                }\r\n                for (const split of data.vertexData.splitBasedOnMaterialID()) {\r\n                    vertexDataList.push({ vertexData: split, transform: data.transform });\r\n                }\r\n            }\r\n\r\n            // Sort by material IDs\r\n            vertexDataList.sort((a, b) => {\r\n                const matInfoA = a.vertexData.materialInfos ? a.vertexData.materialInfos[0].materialIndex : 0;\r\n                const matInfoB = b.vertexData.materialInfos ? b.vertexData.materialInfos[0].materialIndex : 0;\r\n\r\n                if (matInfoA > matInfoB) {\r\n                    return 1;\r\n                }\r\n\r\n                if (matInfoA === matInfoB) {\r\n                    return 0;\r\n                }\r\n\r\n                return -1;\r\n            });\r\n\r\n            // Build the new material info\r\n            for (const vertexDataSource of vertexDataList) {\r\n                const vertexData = vertexDataSource.vertexData;\r\n                if (vertexData.materialInfos) {\r\n                    materialIndex = vertexData.materialInfos[0].materialIndex;\r\n                } else {\r\n                    materialIndex = 0;\r\n                }\r\n                if (currentMaterialInfo && currentMaterialInfo.materialIndex === materialIndex) {\r\n                    currentMaterialInfo.indexCount += vertexData.indices!.length;\r\n                    currentMaterialInfo.verticesCount += vertexData.positions!.length / 3;\r\n                } else {\r\n                    const materialInfo = new VertexDataMaterialInfo();\r\n                    materialInfo.materialIndex = materialIndex;\r\n                    materialInfo.indexStart = indexOffset;\r\n                    materialInfo.indexCount = vertexData.indices!.length;\r\n                    materialInfo.verticesStart = vertexOffset;\r\n                    materialInfo.verticesCount = vertexData.positions!.length / 3;\r\n\r\n                    materialInfos.push(materialInfo);\r\n                    currentMaterialInfo = materialInfo;\r\n                }\r\n                indexOffset += vertexData.indices!.length;\r\n                vertexOffset += vertexData.positions!.length / 3;\r\n            }\r\n            // Extract sorted values\r\n            const first = vertexDataList.splice(0, 1)[0];\r\n            root = first.vertexData;\r\n            transform = first.transform;\r\n            others = vertexDataList.map((v) => v.vertexData);\r\n            vertexDatas = vertexDataList;\r\n\r\n            this.materialInfos = materialInfos;\r\n        }\r\n\r\n        // Merge geometries\r\n        const totalIndices = others.reduce((indexSum, vertexData) => indexSum + (vertexData.indices?.length ?? 0), root.indices?.length ?? 0);\r\n        const sliceIndices = forceCloneIndices || others.some((vertexData) => vertexData.indices === root.indices);\r\n        let indices = sliceIndices ? root.indices?.slice() : root.indices;\r\n        if (totalIndices > 0) {\r\n            let indicesOffset = indices?.length ?? 0;\r\n\r\n            if (!indices) {\r\n                indices = new Array<number>(totalIndices);\r\n            }\r\n\r\n            if (indices.length !== totalIndices) {\r\n                if (Array.isArray(indices)) {\r\n                    indices.length = totalIndices;\r\n                } else {\r\n                    const temp = use32BitsIndices || indices instanceof Uint32Array ? new Uint32Array(totalIndices) : new Uint16Array(totalIndices);\r\n                    temp.set(indices);\r\n                    indices = temp;\r\n                }\r\n\r\n                if (transform && transform.determinant() < 0) {\r\n                    VertexData._FlipFaces(indices, 0, indicesOffset);\r\n                }\r\n            }\r\n\r\n            let positionsOffset = root.positions ? root.positions.length / 3 : 0;\r\n            for (const { vertexData: other, transform } of vertexDatas) {\r\n                if (other.indices) {\r\n                    for (let index = 0; index < other.indices.length; index++) {\r\n                        indices[indicesOffset + index] = other.indices[index] + positionsOffset;\r\n                    }\r\n\r\n                    if (transform && transform.determinant() < 0) {\r\n                        VertexData._FlipFaces(indices, indicesOffset, other.indices.length);\r\n                    }\r\n\r\n                    // The call to _validate already checked for positions\r\n                    positionsOffset += other.positions!.length / 3;\r\n                    indicesOffset += other.indices.length;\r\n\r\n                    if (isAsync) {\r\n                        yield;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        this.indices = indices!;\r\n\r\n        this.positions = VertexData._MergeElement(\r\n            VertexBuffer.PositionKind,\r\n            root.positions,\r\n            transform,\r\n            vertexDatas.map((other) => [other.vertexData.positions, other.transform])\r\n        );\r\n        if (isAsync) {\r\n            yield;\r\n        }\r\n        if (root.normals) {\r\n            this.normals = VertexData._MergeElement(\r\n                VertexBuffer.NormalKind,\r\n                root.normals,\r\n                transform,\r\n                vertexDatas.map((other) => [other.vertexData.normals, other.transform])\r\n            );\r\n            if (isAsync) {\r\n                yield;\r\n            }\r\n        }\r\n        if (root.tangents) {\r\n            this.tangents = VertexData._MergeElement(\r\n                VertexBuffer.TangentKind,\r\n                root.tangents,\r\n                transform,\r\n                vertexDatas.map((other) => [other.vertexData.tangents, other.transform])\r\n            );\r\n            if (isAsync) {\r\n                yield;\r\n            }\r\n        }\r\n        if (root.uvs) {\r\n            this.uvs = VertexData._MergeElement(\r\n                VertexBuffer.UVKind,\r\n                root.uvs,\r\n                transform,\r\n                vertexDatas.map((other) => [other.vertexData.uvs, other.transform])\r\n            );\r\n            if (isAsync) {\r\n                yield;\r\n            }\r\n        }\r\n        if (root.uvs2) {\r\n            this.uvs2 = VertexData._MergeElement(\r\n                VertexBuffer.UV2Kind,\r\n                root.uvs2,\r\n                transform,\r\n                vertexDatas.map((other) => [other.vertexData.uvs2, other.transform])\r\n            );\r\n            if (isAsync) {\r\n                yield;\r\n            }\r\n        }\r\n        if (root.uvs3) {\r\n            this.uvs3 = VertexData._MergeElement(\r\n                VertexBuffer.UV3Kind,\r\n                root.uvs3,\r\n                transform,\r\n                vertexDatas.map((other) => [other.vertexData.uvs3, other.transform])\r\n            );\r\n            if (isAsync) {\r\n                yield;\r\n            }\r\n        }\r\n        if (root.uvs4) {\r\n            this.uvs4 = VertexData._MergeElement(\r\n                VertexBuffer.UV4Kind,\r\n                root.uvs4,\r\n                transform,\r\n                vertexDatas.map((other) => [other.vertexData.uvs4, other.transform])\r\n            );\r\n            if (isAsync) {\r\n                yield;\r\n            }\r\n        }\r\n        if (root.uvs5) {\r\n            this.uvs5 = VertexData._MergeElement(\r\n                VertexBuffer.UV5Kind,\r\n                root.uvs5,\r\n                transform,\r\n                vertexDatas.map((other) => [other.vertexData.uvs5, other.transform])\r\n            );\r\n            if (isAsync) {\r\n                yield;\r\n            }\r\n        }\r\n        if (root.uvs6) {\r\n            this.uvs6 = VertexData._MergeElement(\r\n                VertexBuffer.UV6Kind,\r\n                root.uvs6,\r\n                transform,\r\n                vertexDatas.map((other) => [other.vertexData.uvs6, other.transform])\r\n            );\r\n            if (isAsync) {\r\n                yield;\r\n            }\r\n        }\r\n        if (root.colors) {\r\n            this.colors = VertexData._MergeElement(\r\n                VertexBuffer.ColorKind,\r\n                root.colors,\r\n                transform,\r\n                vertexDatas.map((other) => [other.vertexData.colors, other.transform])\r\n            );\r\n            if (isAsync) {\r\n                yield;\r\n            }\r\n        }\r\n        if (root.matricesIndices) {\r\n            this.matricesIndices = VertexData._MergeElement(\r\n                VertexBuffer.MatricesIndicesKind,\r\n                root.matricesIndices,\r\n                transform,\r\n                vertexDatas.map((other) => [other.vertexData.matricesIndices, other.transform])\r\n            );\r\n            if (isAsync) {\r\n                yield;\r\n            }\r\n        }\r\n        if (root.matricesWeights) {\r\n            this.matricesWeights = VertexData._MergeElement(\r\n                VertexBuffer.MatricesWeightsKind,\r\n                root.matricesWeights,\r\n                transform,\r\n                vertexDatas.map((other) => [other.vertexData.matricesWeights, other.transform])\r\n            );\r\n            if (isAsync) {\r\n                yield;\r\n            }\r\n        }\r\n        if (root.matricesIndicesExtra) {\r\n            this.matricesIndicesExtra = VertexData._MergeElement(\r\n                VertexBuffer.MatricesIndicesExtraKind,\r\n                root.matricesIndicesExtra,\r\n                transform,\r\n                vertexDatas.map((other) => [other.vertexData.matricesIndicesExtra, other.transform])\r\n            );\r\n            if (isAsync) {\r\n                yield;\r\n            }\r\n        }\r\n        if (root.matricesWeightsExtra) {\r\n            this.matricesWeightsExtra = VertexData._MergeElement(\r\n                VertexBuffer.MatricesWeightsExtraKind,\r\n                root.matricesWeightsExtra,\r\n                transform,\r\n                vertexDatas.map((other) => [other.vertexData.matricesWeightsExtra, other.transform])\r\n            );\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    private static _MergeElement(\r\n        kind: string,\r\n        source: Nullable<FloatArray>,\r\n        transform: Matrix | undefined,\r\n        others: readonly (readonly [element: Nullable<FloatArray>, transform?: Matrix])[]\r\n    ): Nullable<FloatArray> {\r\n        const nonNullOthers = others.filter((other): other is [element: FloatArray, transform?: Matrix] => other[0] !== null && other[0] !== undefined);\r\n\r\n        // If there is no source to copy and no other non-null sources then skip this element.\r\n        if (!source && nonNullOthers.length == 0) {\r\n            return source;\r\n        }\r\n\r\n        if (!source) {\r\n            return this._MergeElement(kind, nonNullOthers[0][0], nonNullOthers[0][1], nonNullOthers.slice(1));\r\n        }\r\n\r\n        const len = nonNullOthers.reduce((sumLen, elements) => sumLen + elements[0].length, source.length);\r\n\r\n        const transformRange =\r\n            kind === VertexBuffer.PositionKind\r\n                ? VertexData._TransformVector3Coordinates\r\n                : kind === VertexBuffer.NormalKind\r\n                ? VertexData._TransformVector3Normals\r\n                : kind === VertexBuffer.TangentKind\r\n                ? VertexData._TransformVector4Normals\r\n                : () => {};\r\n\r\n        if (source instanceof Float32Array) {\r\n            // use non-loop method when the source is Float32Array\r\n            const ret32 = new Float32Array(len);\r\n            ret32.set(source);\r\n            transform && transformRange(ret32, transform, 0, source.length);\r\n\r\n            let offset = source.length;\r\n            for (const [vertexData, transform] of nonNullOthers) {\r\n                ret32.set(vertexData, offset);\r\n                transform && transformRange(ret32, transform, offset, vertexData.length);\r\n                offset += vertexData.length;\r\n            }\r\n            return ret32;\r\n        } else {\r\n            // don't use concat as it is super slow, just loop for other cases\r\n            const ret = new Array<number>(len);\r\n            for (let i = 0; i < source.length; i++) {\r\n                ret[i] = source[i];\r\n            }\r\n            transform && transformRange(ret, transform, 0, source.length);\r\n\r\n            let offset = source.length;\r\n            for (const [vertexData, transform] of nonNullOthers) {\r\n                for (let i = 0; i < vertexData.length; i++) {\r\n                    ret[offset + i] = vertexData[i];\r\n                }\r\n                transform && transformRange(ret, transform, offset, vertexData.length);\r\n                offset += vertexData.length;\r\n            }\r\n            return ret;\r\n        }\r\n    }\r\n\r\n    private _validate(): void {\r\n        if (!this.positions) {\r\n            throw new RuntimeError(\"Positions are required\", ErrorCodes.MeshInvalidPositionsError);\r\n        }\r\n\r\n        const getElementCount = (kind: string, values: FloatArray) => {\r\n            const stride = VertexBuffer.DeduceStride(kind);\r\n            if (values.length % stride !== 0) {\r\n                throw new Error(\"The \" + kind + \"s array count must be a multiple of \" + stride);\r\n            }\r\n\r\n            return values.length / stride;\r\n        };\r\n\r\n        const positionsElementCount = getElementCount(VertexBuffer.PositionKind, this.positions);\r\n\r\n        const validateElementCount = (kind: string, values: FloatArray) => {\r\n            const elementCount = getElementCount(kind, values);\r\n            if (elementCount !== positionsElementCount) {\r\n                throw new Error(\"The \" + kind + \"s element count (\" + elementCount + \") does not match the positions count (\" + positionsElementCount + \")\");\r\n            }\r\n        };\r\n\r\n        if (this.normals) {\r\n            validateElementCount(VertexBuffer.NormalKind, this.normals);\r\n        }\r\n        if (this.tangents) {\r\n            validateElementCount(VertexBuffer.TangentKind, this.tangents);\r\n        }\r\n        if (this.uvs) {\r\n            validateElementCount(VertexBuffer.UVKind, this.uvs);\r\n        }\r\n        if (this.uvs2) {\r\n            validateElementCount(VertexBuffer.UV2Kind, this.uvs2);\r\n        }\r\n        if (this.uvs3) {\r\n            validateElementCount(VertexBuffer.UV3Kind, this.uvs3);\r\n        }\r\n        if (this.uvs4) {\r\n            validateElementCount(VertexBuffer.UV4Kind, this.uvs4);\r\n        }\r\n        if (this.uvs5) {\r\n            validateElementCount(VertexBuffer.UV5Kind, this.uvs5);\r\n        }\r\n        if (this.uvs6) {\r\n            validateElementCount(VertexBuffer.UV6Kind, this.uvs6);\r\n        }\r\n        if (this.colors) {\r\n            validateElementCount(VertexBuffer.ColorKind, this.colors);\r\n        }\r\n        if (this.matricesIndices) {\r\n            validateElementCount(VertexBuffer.MatricesIndicesKind, this.matricesIndices);\r\n        }\r\n        if (this.matricesWeights) {\r\n            validateElementCount(VertexBuffer.MatricesWeightsKind, this.matricesWeights);\r\n        }\r\n        if (this.matricesIndicesExtra) {\r\n            validateElementCount(VertexBuffer.MatricesIndicesExtraKind, this.matricesIndicesExtra);\r\n        }\r\n        if (this.matricesWeightsExtra) {\r\n            validateElementCount(VertexBuffer.MatricesWeightsExtraKind, this.matricesWeightsExtra);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Clone the current vertex data\r\n     * @returns a copy of the current data\r\n     */\r\n    public clone() {\r\n        const serializationObject = this.serialize();\r\n        return VertexData.Parse(serializationObject);\r\n    }\r\n\r\n    /**\r\n     * Serializes the VertexData\r\n     * @returns a serialized object\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject: any = {};\r\n\r\n        if (this.positions) {\r\n            serializationObject.positions = Array.from(this.positions);\r\n        }\r\n\r\n        if (this.normals) {\r\n            serializationObject.normals = Array.from(this.normals);\r\n        }\r\n\r\n        if (this.tangents) {\r\n            serializationObject.tangents = Array.from(this.tangents);\r\n        }\r\n\r\n        if (this.uvs) {\r\n            serializationObject.uvs = Array.from(this.uvs);\r\n        }\r\n\r\n        if (this.uvs2) {\r\n            serializationObject.uvs2 = Array.from(this.uvs2);\r\n        }\r\n\r\n        if (this.uvs3) {\r\n            serializationObject.uvs3 = Array.from(this.uvs3);\r\n        }\r\n\r\n        if (this.uvs4) {\r\n            serializationObject.uvs4 = Array.from(this.uvs4);\r\n        }\r\n\r\n        if (this.uvs5) {\r\n            serializationObject.uvs5 = Array.from(this.uvs5);\r\n        }\r\n\r\n        if (this.uvs6) {\r\n            serializationObject.uvs6 = Array.from(this.uvs6);\r\n        }\r\n\r\n        if (this.colors) {\r\n            serializationObject.colors = Array.from(this.colors);\r\n        }\r\n\r\n        if (this.matricesIndices) {\r\n            serializationObject.matricesIndices = Array.from(this.matricesIndices);\r\n            serializationObject.matricesIndices._isExpanded = true;\r\n        }\r\n\r\n        if (this.matricesWeights) {\r\n            serializationObject.matricesWeights = Array.from(this.matricesWeights);\r\n        }\r\n\r\n        if (this.matricesIndicesExtra) {\r\n            serializationObject.matricesIndicesExtra = Array.from(this.matricesIndicesExtra);\r\n            serializationObject.matricesIndicesExtra._isExpanded = true;\r\n        }\r\n\r\n        if (this.matricesWeightsExtra) {\r\n            serializationObject.matricesWeightsExtra = Array.from(this.matricesWeightsExtra);\r\n        }\r\n\r\n        serializationObject.indices = Array.from(this.indices as number[]);\r\n\r\n        if (this.materialInfos) {\r\n            serializationObject.materialInfos = [];\r\n            for (const materialInfo of this.materialInfos) {\r\n                const materialInfoSerializationObject = {\r\n                    indexStart: materialInfo.indexStart,\r\n                    indexCount: materialInfo.indexCount,\r\n                    materialIndex: materialInfo.materialIndex,\r\n                    verticesStart: materialInfo.verticesStart,\r\n                    verticesCount: materialInfo.verticesCount,\r\n                };\r\n                serializationObject.materialInfos.push(materialInfoSerializationObject);\r\n            }\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    // Statics\r\n    /**\r\n     * Extracts the vertexData from a mesh\r\n     * @param mesh the mesh from which to extract the VertexData\r\n     * @param copyWhenShared defines if the VertexData must be cloned when shared between multiple meshes, optional, default false\r\n     * @param forceCopy indicating that the VertexData must be cloned, optional, default false\r\n     * @returns the object VertexData associated to the passed mesh\r\n     */\r\n    public static ExtractFromMesh(mesh: Mesh, copyWhenShared?: boolean, forceCopy?: boolean): VertexData {\r\n        return VertexData._ExtractFrom(mesh, copyWhenShared, forceCopy);\r\n    }\r\n\r\n    /**\r\n     * Extracts the vertexData from the geometry\r\n     * @param geometry the geometry from which to extract the VertexData\r\n     * @param copyWhenShared defines if the VertexData must be cloned when the geometry is shared between multiple meshes, optional, default false\r\n     * @param forceCopy indicating that the VertexData must be cloned, optional, default false\r\n     * @returns the object VertexData associated to the passed mesh\r\n     */\r\n    public static ExtractFromGeometry(geometry: Geometry, copyWhenShared?: boolean, forceCopy?: boolean): VertexData {\r\n        return VertexData._ExtractFrom(geometry, copyWhenShared, forceCopy);\r\n    }\r\n\r\n    private static _ExtractFrom(meshOrGeometry: IGetSetVerticesData, copyWhenShared?: boolean, forceCopy?: boolean): VertexData {\r\n        const result = new VertexData();\r\n\r\n        if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.PositionKind)) {\r\n            result.positions = meshOrGeometry.getVerticesData(VertexBuffer.PositionKind, copyWhenShared, forceCopy);\r\n        }\r\n\r\n        if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.NormalKind)) {\r\n            result.normals = meshOrGeometry.getVerticesData(VertexBuffer.NormalKind, copyWhenShared, forceCopy);\r\n        }\r\n\r\n        if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.TangentKind)) {\r\n            result.tangents = meshOrGeometry.getVerticesData(VertexBuffer.TangentKind, copyWhenShared, forceCopy);\r\n        }\r\n\r\n        if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.UVKind)) {\r\n            result.uvs = meshOrGeometry.getVerticesData(VertexBuffer.UVKind, copyWhenShared, forceCopy);\r\n        }\r\n\r\n        if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.UV2Kind)) {\r\n            result.uvs2 = meshOrGeometry.getVerticesData(VertexBuffer.UV2Kind, copyWhenShared, forceCopy);\r\n        }\r\n\r\n        if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.UV3Kind)) {\r\n            result.uvs3 = meshOrGeometry.getVerticesData(VertexBuffer.UV3Kind, copyWhenShared, forceCopy);\r\n        }\r\n\r\n        if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.UV4Kind)) {\r\n            result.uvs4 = meshOrGeometry.getVerticesData(VertexBuffer.UV4Kind, copyWhenShared, forceCopy);\r\n        }\r\n\r\n        if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.UV5Kind)) {\r\n            result.uvs5 = meshOrGeometry.getVerticesData(VertexBuffer.UV5Kind, copyWhenShared, forceCopy);\r\n        }\r\n\r\n        if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.UV6Kind)) {\r\n            result.uvs6 = meshOrGeometry.getVerticesData(VertexBuffer.UV6Kind, copyWhenShared, forceCopy);\r\n        }\r\n\r\n        if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.ColorKind)) {\r\n            result.colors = meshOrGeometry.getVerticesData(VertexBuffer.ColorKind, copyWhenShared, forceCopy);\r\n        }\r\n\r\n        if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.MatricesIndicesKind)) {\r\n            result.matricesIndices = meshOrGeometry.getVerticesData(VertexBuffer.MatricesIndicesKind, copyWhenShared, forceCopy);\r\n        }\r\n\r\n        if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.MatricesWeightsKind)) {\r\n            result.matricesWeights = meshOrGeometry.getVerticesData(VertexBuffer.MatricesWeightsKind, copyWhenShared, forceCopy);\r\n        }\r\n\r\n        if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.MatricesIndicesExtraKind)) {\r\n            result.matricesIndicesExtra = meshOrGeometry.getVerticesData(VertexBuffer.MatricesIndicesExtraKind, copyWhenShared, forceCopy);\r\n        }\r\n\r\n        if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.MatricesWeightsExtraKind)) {\r\n            result.matricesWeightsExtra = meshOrGeometry.getVerticesData(VertexBuffer.MatricesWeightsExtraKind, copyWhenShared, forceCopy);\r\n        }\r\n\r\n        result.indices = meshOrGeometry.getIndices(copyWhenShared, forceCopy);\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Creates the VertexData for a Ribbon\r\n     * @param options an object used to set the following optional parameters for the ribbon, required but can be empty\r\n     * * pathArray array of paths, each of which an array of successive Vector3\r\n     * * closeArray creates a seam between the first and the last paths of the pathArray, optional, default false\r\n     * * closePath creates a seam between the first and the last points of each path of the path array, optional, default false\r\n     * * offset a positive integer, only used when pathArray contains a single path (offset = 10 means the point 1 is joined to the point 11), default rounded half size of the pathArray length\r\n     * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n     * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n     * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n     * * invertUV swaps in the U and V coordinates when applying a texture, optional, default false\r\n     * * uvs a linear array, of length 2 * number of vertices, of custom UV values, optional\r\n     * * colors a linear array, of length 4 * number of vertices, of custom color values, optional\r\n     * @param options.pathArray\r\n     * @param options.closeArray\r\n     * @param options.closePath\r\n     * @param options.offset\r\n     * @param options.sideOrientation\r\n     * @param options.frontUVs\r\n     * @param options.backUVs\r\n     * @param options.invertUV\r\n     * @param options.uvs\r\n     * @param options.colors\r\n     * @returns the VertexData of the ribbon\r\n     * @deprecated use CreateRibbonVertexData instead\r\n     */\r\n    public static CreateRibbon(options: {\r\n        pathArray: Vector3[][];\r\n        closeArray?: boolean;\r\n        closePath?: boolean;\r\n        offset?: number;\r\n        sideOrientation?: number;\r\n        frontUVs?: Vector4;\r\n        backUVs?: Vector4;\r\n        invertUV?: boolean;\r\n        uvs?: Vector2[];\r\n        colors?: Color4[];\r\n    }): VertexData {\r\n        throw _WarnImport(\"ribbonBuilder\");\r\n    }\r\n\r\n    /**\r\n     * Creates the VertexData for a box\r\n     * @param options an object used to set the following optional parameters for the box, required but can be empty\r\n     * * size sets the width, height and depth of the box to the value of size, optional default 1\r\n     * * width sets the width (x direction) of the box, overwrites the width set by size, optional, default size\r\n     * * height sets the height (y direction) of the box, overwrites the height set by size, optional, default size\r\n     * * depth sets the depth (z direction) of the box, overwrites the depth set by size, optional, default size\r\n     * * faceUV an array of 6 Vector4 elements used to set different images to each box side\r\n     * * faceColors an array of 6 Color3 elements used to set different colors to each box side\r\n     * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n     * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n     * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n     * @param options.size\r\n     * @param options.width\r\n     * @param options.height\r\n     * @param options.depth\r\n     * @param options.faceUV\r\n     * @param options.faceColors\r\n     * @param options.sideOrientation\r\n     * @param options.frontUVs\r\n     * @param options.backUVs\r\n     * @returns the VertexData of the box\r\n     * @deprecated Please use CreateBoxVertexData from the BoxBuilder file instead\r\n     */\r\n    public static CreateBox(options: {\r\n        size?: number;\r\n        width?: number;\r\n        height?: number;\r\n        depth?: number;\r\n        faceUV?: Vector4[];\r\n        faceColors?: Color4[];\r\n        sideOrientation?: number;\r\n        frontUVs?: Vector4;\r\n        backUVs?: Vector4;\r\n    }): VertexData {\r\n        throw _WarnImport(\"boxBuilder\");\r\n    }\r\n\r\n    /**\r\n     * Creates the VertexData for a tiled box\r\n     * @param options an object used to set the following optional parameters for the box, required but can be empty\r\n     * * faceTiles sets the pattern, tile size and number of tiles for a face\r\n     * * faceUV an array of 6 Vector4 elements used to set different images to each box side\r\n     * * faceColors an array of 6 Color3 elements used to set different colors to each box side\r\n     * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n     * @param options.pattern\r\n     * @param options.width\r\n     * @param options.height\r\n     * @param options.depth\r\n     * @param options.tileSize\r\n     * @param options.tileWidth\r\n     * @param options.tileHeight\r\n     * @param options.alignHorizontal\r\n     * @param options.alignVertical\r\n     * @param options.faceUV\r\n     * @param options.faceColors\r\n     * @param options.sideOrientation\r\n     * @returns the VertexData of the box\r\n     * @deprecated Please use CreateTiledBoxVertexData instead\r\n     */\r\n    public static CreateTiledBox(options: {\r\n        pattern?: number;\r\n        width?: number;\r\n        height?: number;\r\n        depth?: number;\r\n        tileSize?: number;\r\n        tileWidth?: number;\r\n        tileHeight?: number;\r\n        alignHorizontal?: number;\r\n        alignVertical?: number;\r\n        faceUV?: Vector4[];\r\n        faceColors?: Color4[];\r\n        sideOrientation?: number;\r\n    }): VertexData {\r\n        throw _WarnImport(\"tiledBoxBuilder\");\r\n    }\r\n\r\n    /**\r\n     * Creates the VertexData for a tiled plane\r\n     * @param options an object used to set the following optional parameters for the box, required but can be empty\r\n     * * pattern a limited pattern arrangement depending on the number\r\n     * * tileSize sets the width, height and depth of the tile to the value of size, optional default 1\r\n     * * tileWidth sets the width (x direction) of the tile, overwrites the width set by size, optional, default size\r\n     * * tileHeight sets the height (y direction) of the tile, overwrites the height set by size, optional, default size\r\n     * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n     * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n     * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n     * @param options.pattern\r\n     * @param options.tileSize\r\n     * @param options.tileWidth\r\n     * @param options.tileHeight\r\n     * @param options.size\r\n     * @param options.width\r\n     * @param options.height\r\n     * @param options.alignHorizontal\r\n     * @param options.alignVertical\r\n     * @param options.sideOrientation\r\n     * @param options.frontUVs\r\n     * @param options.backUVs\r\n     * @returns the VertexData of the tiled plane\r\n     * @deprecated use CreateTiledPlaneVertexData instead\r\n     */\r\n    public static CreateTiledPlane(options: {\r\n        pattern?: number;\r\n        tileSize?: number;\r\n        tileWidth?: number;\r\n        tileHeight?: number;\r\n        size?: number;\r\n        width?: number;\r\n        height?: number;\r\n        alignHorizontal?: number;\r\n        alignVertical?: number;\r\n        sideOrientation?: number;\r\n        frontUVs?: Vector4;\r\n        backUVs?: Vector4;\r\n    }): VertexData {\r\n        throw _WarnImport(\"tiledPlaneBuilder\");\r\n    }\r\n\r\n    /**\r\n     * Creates the VertexData for an ellipsoid, defaults to a sphere\r\n     * @param options an object used to set the following optional parameters for the box, required but can be empty\r\n     * * segments sets the number of horizontal strips optional, default 32\r\n     * * diameter sets the axes dimensions, diameterX, diameterY and diameterZ to the value of diameter, optional default 1\r\n     * * diameterX sets the diameterX (x direction) of the ellipsoid, overwrites the diameterX set by diameter, optional, default diameter\r\n     * * diameterY sets the diameterY (y direction) of the ellipsoid, overwrites the diameterY set by diameter, optional, default diameter\r\n     * * diameterZ sets the diameterZ (z direction) of the ellipsoid, overwrites the diameterZ set by diameter, optional, default diameter\r\n     * * arc a number from 0 to 1, to create an unclosed ellipsoid based on the fraction of the circumference (latitude) given by the arc value, optional, default 1\r\n     * * slice a number from 0 to 1, to create an unclosed ellipsoid based on the fraction of the height (latitude) given by the arc value, optional, default 1\r\n     * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n     * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n     * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n     * @param options.segments\r\n     * @param options.diameter\r\n     * @param options.diameterX\r\n     * @param options.diameterY\r\n     * @param options.diameterZ\r\n     * @param options.arc\r\n     * @param options.slice\r\n     * @param options.sideOrientation\r\n     * @param options.frontUVs\r\n     * @param options.backUVs\r\n     * @returns the VertexData of the ellipsoid\r\n     * @deprecated use CreateSphereVertexData instead\r\n     */\r\n    public static CreateSphere(options: {\r\n        segments?: number;\r\n        diameter?: number;\r\n        diameterX?: number;\r\n        diameterY?: number;\r\n        diameterZ?: number;\r\n        arc?: number;\r\n        slice?: number;\r\n        sideOrientation?: number;\r\n        frontUVs?: Vector4;\r\n        backUVs?: Vector4;\r\n    }): VertexData {\r\n        throw _WarnImport(\"sphereBuilder\");\r\n    }\r\n\r\n    /**\r\n     * Creates the VertexData for a cylinder, cone or prism\r\n     * @param options an object used to set the following optional parameters for the box, required but can be empty\r\n     * * height sets the height (y direction) of the cylinder, optional, default 2\r\n     * * diameterTop sets the diameter of the top of the cone, overwrites diameter,  optional, default diameter\r\n     * * diameterBottom sets the diameter of the bottom of the cone, overwrites diameter,  optional, default diameter\r\n     * * diameter sets the diameter of the top and bottom of the cone, optional default 1\r\n     * * tessellation the number of prism sides, 3 for a triangular prism, optional, default 24\r\n     * * subdivisions` the number of rings along the cylinder height, optional, default 1\r\n     * * arc a number from 0 to 1, to create an unclosed cylinder based on the fraction of the circumference given by the arc value, optional, default 1\r\n     * * faceColors an array of Color3 elements used to set different colors to the top, rings and bottom respectively\r\n     * * faceUV an array of Vector4 elements used to set different images to the top, rings and bottom respectively\r\n     * * hasRings when true makes each subdivision independently treated as a face for faceUV and faceColors, optional, default false\r\n     * * enclose when true closes an open cylinder by adding extra flat faces between the height axis and vertical edges, think cut cake\r\n     * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n     * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n     * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n     * @param options.height\r\n     * @param options.diameterTop\r\n     * @param options.diameterBottom\r\n     * @param options.diameter\r\n     * @param options.tessellation\r\n     * @param options.subdivisions\r\n     * @param options.arc\r\n     * @param options.faceColors\r\n     * @param options.faceUV\r\n     * @param options.hasRings\r\n     * @param options.enclose\r\n     * @param options.sideOrientation\r\n     * @param options.frontUVs\r\n     * @param options.backUVs\r\n     * @returns the VertexData of the cylinder, cone or prism\r\n     * @deprecated please use CreateCylinderVertexData instead\r\n     */\r\n    public static CreateCylinder(options: {\r\n        height?: number;\r\n        diameterTop?: number;\r\n        diameterBottom?: number;\r\n        diameter?: number;\r\n        tessellation?: number;\r\n        subdivisions?: number;\r\n        arc?: number;\r\n        faceColors?: Color4[];\r\n        faceUV?: Vector4[];\r\n        hasRings?: boolean;\r\n        enclose?: boolean;\r\n        sideOrientation?: number;\r\n        frontUVs?: Vector4;\r\n        backUVs?: Vector4;\r\n    }): VertexData {\r\n        throw _WarnImport(\"cylinderBuilder\");\r\n    }\r\n\r\n    /**\r\n     * Creates the VertexData for a torus\r\n     * @param options an object used to set the following optional parameters for the box, required but can be empty\r\n     * * diameter the diameter of the torus, optional default 1\r\n     * * thickness the diameter of the tube forming the torus, optional default 0.5\r\n     * * tessellation the number of prism sides, 3 for a triangular prism, optional, default 24\r\n     * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n     * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n     * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n     * @param options.diameter\r\n     * @param options.thickness\r\n     * @param options.tessellation\r\n     * @param options.sideOrientation\r\n     * @param options.frontUVs\r\n     * @param options.backUVs\r\n     * @returns the VertexData of the torus\r\n     * @deprecated use CreateTorusVertexData instead\r\n     */\r\n    public static CreateTorus(options: {\r\n        diameter?: number;\r\n        thickness?: number;\r\n        tessellation?: number;\r\n        sideOrientation?: number;\r\n        frontUVs?: Vector4;\r\n        backUVs?: Vector4;\r\n    }): VertexData {\r\n        throw _WarnImport(\"torusBuilder\");\r\n    }\r\n\r\n    /**\r\n     * Creates the VertexData of the LineSystem\r\n     * @param options an object used to set the following optional parameters for the LineSystem, required but can be empty\r\n     *  - lines an array of lines, each line being an array of successive Vector3\r\n     *  - colors an array of line colors, each of the line colors being an array of successive Color4, one per line point\r\n     * @param options.lines\r\n     * @param options.colors\r\n     * @returns the VertexData of the LineSystem\r\n     * @deprecated use CreateLineSystemVertexData instead\r\n     */\r\n    public static CreateLineSystem(options: { lines: Vector3[][]; colors?: Nullable<Color4[][]> }): VertexData {\r\n        throw _WarnImport(\"linesBuilder\");\r\n    }\r\n\r\n    /**\r\n     * Create the VertexData for a DashedLines\r\n     * @param options an object used to set the following optional parameters for the DashedLines, required but can be empty\r\n     *  - points an array successive Vector3\r\n     *  - dashSize the size of the dashes relative to the dash number, optional, default 3\r\n     *  - gapSize the size of the gap between two successive dashes relative to the dash number, optional, default 1\r\n     *  - dashNb the intended total number of dashes, optional, default 200\r\n     * @param options.points\r\n     * @param options.dashSize\r\n     * @param options.gapSize\r\n     * @param options.dashNb\r\n     * @returns the VertexData for the DashedLines\r\n     * @deprecated use CreateDashedLinesVertexData instead\r\n     */\r\n    public static CreateDashedLines(options: { points: Vector3[]; dashSize?: number; gapSize?: number; dashNb?: number }): VertexData {\r\n        throw _WarnImport(\"linesBuilder\");\r\n    }\r\n\r\n    /**\r\n     * Creates the VertexData for a Ground\r\n     * @param options an object used to set the following optional parameters for the Ground, required but can be empty\r\n     *  - width the width (x direction) of the ground, optional, default 1\r\n     *  - height the height (z direction) of the ground, optional, default 1\r\n     *  - subdivisions the number of subdivisions per side, optional, default 1\r\n     * @param options.width\r\n     * @param options.height\r\n     * @param options.subdivisions\r\n     * @param options.subdivisionsX\r\n     * @param options.subdivisionsY\r\n     * @returns the VertexData of the Ground\r\n     * @deprecated Please use CreateGroundVertexData instead\r\n     */\r\n    public static CreateGround(options: { width?: number; height?: number; subdivisions?: number; subdivisionsX?: number; subdivisionsY?: number }): VertexData {\r\n        throw _WarnImport(\"groundBuilder\");\r\n    }\r\n\r\n    /**\r\n     * Creates the VertexData for a TiledGround by subdividing the ground into tiles\r\n     * @param options an object used to set the following optional parameters for the Ground, required but can be empty\r\n     * * xmin the ground minimum X coordinate, optional, default -1\r\n     * * zmin the ground minimum Z coordinate, optional, default -1\r\n     * * xmax the ground maximum X coordinate, optional, default 1\r\n     * * zmax the ground maximum Z coordinate, optional, default 1\r\n     * * subdivisions a javascript object {w: positive integer, h: positive integer}, `w` and `h` are the numbers of subdivisions on the ground width and height creating 'tiles', default {w: 6, h: 6}\r\n     * * precision a javascript object {w: positive integer, h: positive integer}, `w` and `h` are the numbers of subdivisions on the tile width and height, default {w: 2, h: 2}\r\n     * @param options.xmin\r\n     * @param options.zmin\r\n     * @param options.xmax\r\n     * @param options.zmax\r\n     * @param options.subdivisions\r\n     * @param options.subdivisions.w\r\n     * @param options.subdivisions.h\r\n     * @param options.precision\r\n     * @param options.precision.w\r\n     * @param options.precision.h\r\n     * @returns the VertexData of the TiledGround\r\n     * @deprecated use CreateTiledGroundVertexData instead\r\n     */\r\n    public static CreateTiledGround(options: {\r\n        xmin: number;\r\n        zmin: number;\r\n        xmax: number;\r\n        zmax: number;\r\n        subdivisions?: { w: number; h: number };\r\n        precision?: { w: number; h: number };\r\n    }): VertexData {\r\n        throw _WarnImport(\"groundBuilder\");\r\n    }\r\n\r\n    /**\r\n     * Creates the VertexData of the Ground designed from a heightmap\r\n     * @param options an object used to set the following parameters for the Ground, required and provided by CreateGroundFromHeightMap\r\n     * * width the width (x direction) of the ground\r\n     * * height the height (z direction) of the ground\r\n     * * subdivisions the number of subdivisions per side\r\n     * * minHeight the minimum altitude on the ground, optional, default 0\r\n     * * maxHeight the maximum altitude on the ground, optional default 1\r\n     * * colorFilter the filter to apply to the image pixel colors to compute the height, optional Color3, default (0.3, 0.59, 0.11)\r\n     * * buffer the array holding the image color data\r\n     * * bufferWidth the width of image\r\n     * * bufferHeight the height of image\r\n     * * alphaFilter Remove any data where the alpha channel is below this value, defaults 0 (all data visible)\r\n     * @param options.width\r\n     * @param options.height\r\n     * @param options.subdivisions\r\n     * @param options.minHeight\r\n     * @param options.maxHeight\r\n     * @param options.colorFilter\r\n     * @param options.buffer\r\n     * @param options.bufferWidth\r\n     * @param options.bufferHeight\r\n     * @param options.alphaFilter\r\n     * @returns the VertexData of the Ground designed from a heightmap\r\n     * @deprecated use CreateGroundFromHeightMapVertexData instead\r\n     */\r\n    public static CreateGroundFromHeightMap(options: {\r\n        width: number;\r\n        height: number;\r\n        subdivisions: number;\r\n        minHeight: number;\r\n        maxHeight: number;\r\n        colorFilter: Color3;\r\n        buffer: Uint8Array;\r\n        bufferWidth: number;\r\n        bufferHeight: number;\r\n        alphaFilter: number;\r\n    }): VertexData {\r\n        throw _WarnImport(\"groundBuilder\");\r\n    }\r\n\r\n    /**\r\n     * Creates the VertexData for a Plane\r\n     * @param options an object used to set the following optional parameters for the plane, required but can be empty\r\n     * * size sets the width and height of the plane to the value of size, optional default 1\r\n     * * width sets the width (x direction) of the plane, overwrites the width set by size, optional, default size\r\n     * * height sets the height (y direction) of the plane, overwrites the height set by size, optional, default size\r\n     * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n     * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n     * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n     * @param options.size\r\n     * @param options.width\r\n     * @param options.height\r\n     * @param options.sideOrientation\r\n     * @param options.frontUVs\r\n     * @param options.backUVs\r\n     * @returns the VertexData of the box\r\n     * @deprecated use CreatePlaneVertexData instead\r\n     */\r\n    public static CreatePlane(options: { size?: number; width?: number; height?: number; sideOrientation?: number; frontUVs?: Vector4; backUVs?: Vector4 }): VertexData {\r\n        throw _WarnImport(\"planeBuilder\");\r\n    }\r\n\r\n    /**\r\n     * Creates the VertexData of the Disc or regular Polygon\r\n     * @param options an object used to set the following optional parameters for the disc, required but can be empty\r\n     * * radius the radius of the disc, optional default 0.5\r\n     * * tessellation the number of polygon sides, optional, default 64\r\n     * * arc a number from 0 to 1, to create an unclosed polygon based on the fraction of the circumference given by the arc value, optional, default 1\r\n     * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n     * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n     * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n     * @param options.radius\r\n     * @param options.tessellation\r\n     * @param options.arc\r\n     * @param options.sideOrientation\r\n     * @param options.frontUVs\r\n     * @param options.backUVs\r\n     * @returns the VertexData of the box\r\n     * @deprecated use CreateDiscVertexData instead\r\n     */\r\n    public static CreateDisc(options: { radius?: number; tessellation?: number; arc?: number; sideOrientation?: number; frontUVs?: Vector4; backUVs?: Vector4 }): VertexData {\r\n        throw _WarnImport(\"discBuilder\");\r\n    }\r\n\r\n    /**\r\n     * Creates the VertexData for an irregular Polygon in the XoZ plane using a mesh built by polygonTriangulation.build()\r\n     * All parameters are provided by CreatePolygon as needed\r\n     * @param polygon a mesh built from polygonTriangulation.build()\r\n     * @param sideOrientation takes the values Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n     * @param fUV an array of Vector4 elements used to set different images to the top, rings and bottom respectively\r\n     * @param fColors an array of Color3 elements used to set different colors to the top, rings and bottom respectively\r\n     * @param frontUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n     * @param backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n     * @param wrap a boolean, default false, when true and fUVs used texture is wrapped around all sides, when false texture is applied side\r\n     * @returns the VertexData of the Polygon\r\n     * @deprecated use CreatePolygonVertexData instead\r\n     */\r\n    public static CreatePolygon(polygon: Mesh, sideOrientation: number, fUV?: Vector4[], fColors?: Color4[], frontUVs?: Vector4, backUVs?: Vector4, wrap?: boolean): VertexData {\r\n        throw _WarnImport(\"polygonBuilder\");\r\n    }\r\n\r\n    /**\r\n     * Creates the VertexData of the IcoSphere\r\n     * @param options an object used to set the following optional parameters for the IcoSphere, required but can be empty\r\n     * * radius the radius of the IcoSphere, optional default 1\r\n     * * radiusX allows stretching in the x direction, optional, default radius\r\n     * * radiusY allows stretching in the y direction, optional, default radius\r\n     * * radiusZ allows stretching in the z direction, optional, default radius\r\n     * * flat when true creates a flat shaded mesh, optional, default true\r\n     * * subdivisions increasing the subdivisions increases the number of faces, optional, default 4\r\n     * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n     * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n     * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n     * @param options.radius\r\n     * @param options.radiusX\r\n     * @param options.radiusY\r\n     * @param options.radiusZ\r\n     * @param options.flat\r\n     * @param options.subdivisions\r\n     * @param options.sideOrientation\r\n     * @param options.frontUVs\r\n     * @param options.backUVs\r\n     * @returns the VertexData of the IcoSphere\r\n     * @deprecated use CreateIcoSphereVertexData instead\r\n     */\r\n    public static CreateIcoSphere(options: {\r\n        radius?: number;\r\n        radiusX?: number;\r\n        radiusY?: number;\r\n        radiusZ?: number;\r\n        flat?: boolean;\r\n        subdivisions?: number;\r\n        sideOrientation?: number;\r\n        frontUVs?: Vector4;\r\n        backUVs?: Vector4;\r\n    }): VertexData {\r\n        throw _WarnImport(\"icoSphereBuilder\");\r\n    }\r\n\r\n    // inspired from // http://stemkoski.github.io/Three.js/Polyhedra.html\r\n    /**\r\n     * Creates the VertexData for a Polyhedron\r\n     * @param options an object used to set the following optional parameters for the polyhedron, required but can be empty\r\n     * * type provided types are:\r\n     *  * 0 : Tetrahedron, 1 : Octahedron, 2 : Dodecahedron, 3 : Icosahedron, 4 : Rhombicuboctahedron, 5 : Triangular Prism, 6 : Pentagonal Prism, 7 : Hexagonal Prism, 8 : Square Pyramid (J1)\r\n     *  * 9 : Pentagonal Pyramid (J2), 10 : Triangular Dipyramid (J12), 11 : Pentagonal Dipyramid (J13), 12 : Elongated Square Dipyramid (J15), 13 : Elongated Pentagonal Dipyramid (J16), 14 : Elongated Pentagonal Cupola (J20)\r\n     * * size the size of the IcoSphere, optional default 1\r\n     * * sizeX allows stretching in the x direction, optional, default size\r\n     * * sizeY allows stretching in the y direction, optional, default size\r\n     * * sizeZ allows stretching in the z direction, optional, default size\r\n     * * custom a number that overwrites the type to create from an extended set of polyhedron from https://www.babylonjs-playground.com/#21QRSK#15 with minimised editor\r\n     * * faceUV an array of Vector4 elements used to set different images to the top, rings and bottom respectively\r\n     * * faceColors an array of Color3 elements used to set different colors to the top, rings and bottom respectively\r\n     * * flat when true creates a flat shaded mesh, optional, default true\r\n     * * subdivisions increasing the subdivisions increases the number of faces, optional, default 4\r\n     * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n     * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n     * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n     * @param options.type\r\n     * @param options.size\r\n     * @param options.sizeX\r\n     * @param options.sizeY\r\n     * @param options.sizeZ\r\n     * @param options.custom\r\n     * @param options.faceUV\r\n     * @param options.faceColors\r\n     * @param options.flat\r\n     * @param options.sideOrientation\r\n     * @param options.frontUVs\r\n     * @param options.backUVs\r\n     * @returns the VertexData of the Polyhedron\r\n     * @deprecated use CreatePolyhedronVertexData instead\r\n     */\r\n    public static CreatePolyhedron(options: {\r\n        type?: number;\r\n        size?: number;\r\n        sizeX?: number;\r\n        sizeY?: number;\r\n        sizeZ?: number;\r\n        custom?: any;\r\n        faceUV?: Vector4[];\r\n        faceColors?: Color4[];\r\n        flat?: boolean;\r\n        sideOrientation?: number;\r\n        frontUVs?: Vector4;\r\n        backUVs?: Vector4;\r\n    }): VertexData {\r\n        throw _WarnImport(\"polyhedronBuilder\");\r\n    }\r\n\r\n    /**\r\n     * Creates the VertexData for a Capsule, inspired from https://github.com/maximeq/three-js-capsule-geometry/blob/master/src/CapsuleBufferGeometry.js\r\n     * @param options an object used to set the following optional parameters for the capsule, required but can be empty\r\n     * @returns the VertexData of the Capsule\r\n     * @deprecated Please use CreateCapsuleVertexData from the capsuleBuilder file instead\r\n     */\r\n    public static CreateCapsule(\r\n        options: ICreateCapsuleOptions = {\r\n            orientation: Vector3.Up(),\r\n            subdivisions: 2,\r\n            tessellation: 16,\r\n            height: 1,\r\n            radius: 0.25,\r\n            capSubdivisions: 6,\r\n        }\r\n    ): VertexData {\r\n        throw _WarnImport(\"capsuleBuilder\");\r\n    }\r\n\r\n    // based on http://code.google.com/p/away3d/source/browse/trunk/fp10/Away3D/src/away3d/primitives/TorusKnot.as?spec=svn2473&r=2473\r\n    /**\r\n     * Creates the VertexData for a TorusKnot\r\n     * @param options an object used to set the following optional parameters for the TorusKnot, required but can be empty\r\n     * * radius the radius of the torus knot, optional, default 2\r\n     * * tube the thickness of the tube, optional, default 0.5\r\n     * * radialSegments the number of sides on each tube segments, optional, default 32\r\n     * * tubularSegments the number of tubes to decompose the knot into, optional, default 32\r\n     * * p the number of windings around the z axis, optional,  default 2\r\n     * * q the number of windings around the x axis, optional,  default 3\r\n     * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n     * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n     * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n     * @param options.radius\r\n     * @param options.tube\r\n     * @param options.radialSegments\r\n     * @param options.tubularSegments\r\n     * @param options.p\r\n     * @param options.q\r\n     * @param options.sideOrientation\r\n     * @param options.frontUVs\r\n     * @param options.backUVs\r\n     * @returns the VertexData of the Torus Knot\r\n     * @deprecated use CreateTorusKnotVertexData instead\r\n     */\r\n    public static CreateTorusKnot(options: {\r\n        radius?: number;\r\n        tube?: number;\r\n        radialSegments?: number;\r\n        tubularSegments?: number;\r\n        p?: number;\r\n        q?: number;\r\n        sideOrientation?: number;\r\n        frontUVs?: Vector4;\r\n        backUVs?: Vector4;\r\n    }): VertexData {\r\n        throw _WarnImport(\"torusKnotBuilder\");\r\n    }\r\n\r\n    // Tools\r\n\r\n    /**\r\n     * Compute normals for given positions and indices\r\n     * @param positions an array of vertex positions, [...., x, y, z, ......]\r\n     * @param indices an array of indices in groups of three for each triangular facet, [...., i, j, k, ......]\r\n     * @param normals an array of vertex normals, [...., x, y, z, ......]\r\n     * @param options an object used to set the following optional parameters for the TorusKnot, optional\r\n     * * facetNormals : optional array of facet normals (vector3)\r\n     * * facetPositions : optional array of facet positions (vector3)\r\n     * * facetPartitioning : optional partitioning array. facetPositions is required for facetPartitioning computation\r\n     * * ratio : optional partitioning ratio / bounding box, required for facetPartitioning computation\r\n     * * bInfo : optional bounding info, required for facetPartitioning computation\r\n     * * bbSize : optional bounding box size data, required for facetPartitioning computation\r\n     * * subDiv : optional partitioning data about subdivisions on  each axis (int), required for facetPartitioning computation\r\n     * * useRightHandedSystem: optional boolean to for right handed system computation\r\n     * * depthSort : optional boolean to enable the facet depth sort computation\r\n     * * distanceTo : optional Vector3 to compute the facet depth from this location\r\n     * * depthSortedFacets : optional array of depthSortedFacets to store the facet distances from the reference location\r\n     * @param options.facetNormals\r\n     * @param options.facetPositions\r\n     * @param options.facetPartitioning\r\n     * @param options.ratio\r\n     * @param options.bInfo\r\n     * @param options.bbSize\r\n     * @param options.subDiv\r\n     * @param options.useRightHandedSystem\r\n     * @param options.depthSort\r\n     * @param options.distanceTo\r\n     * @param options.depthSortedFacets\r\n     */\r\n    public static ComputeNormals(\r\n        positions: any,\r\n        indices: any,\r\n        normals: any,\r\n        options?: {\r\n            facetNormals?: any;\r\n            facetPositions?: any;\r\n            facetPartitioning?: any;\r\n            ratio?: number;\r\n            bInfo?: any;\r\n            bbSize?: Vector3;\r\n            subDiv?: any;\r\n            useRightHandedSystem?: boolean;\r\n            depthSort?: boolean;\r\n            distanceTo?: Vector3;\r\n            depthSortedFacets?: any;\r\n        }\r\n    ): void {\r\n        // temporary scalar variables\r\n        let index = 0; // facet index\r\n        let p1p2x = 0.0; // p1p2 vector x coordinate\r\n        let p1p2y = 0.0; // p1p2 vector y coordinate\r\n        let p1p2z = 0.0; // p1p2 vector z coordinate\r\n        let p3p2x = 0.0; // p3p2 vector x coordinate\r\n        let p3p2y = 0.0; // p3p2 vector y coordinate\r\n        let p3p2z = 0.0; // p3p2 vector z coordinate\r\n        let faceNormalx = 0.0; // facet normal x coordinate\r\n        let faceNormaly = 0.0; // facet normal y coordinate\r\n        let faceNormalz = 0.0; // facet normal z coordinate\r\n        let length = 0.0; // facet normal length before normalization\r\n        let v1x = 0; // vector1 x index in the positions array\r\n        let v1y = 0; // vector1 y index in the positions array\r\n        let v1z = 0; // vector1 z index in the positions array\r\n        let v2x = 0; // vector2 x index in the positions array\r\n        let v2y = 0; // vector2 y index in the positions array\r\n        let v2z = 0; // vector2 z index in the positions array\r\n        let v3x = 0; // vector3 x index in the positions array\r\n        let v3y = 0; // vector3 y index in the positions array\r\n        let v3z = 0; // vector3 z index in the positions array\r\n        let computeFacetNormals = false;\r\n        let computeFacetPositions = false;\r\n        let computeFacetPartitioning = false;\r\n        let computeDepthSort = false;\r\n        let faceNormalSign = 1;\r\n        let ratio = 0;\r\n        let distanceTo: Nullable<Vector3> = null;\r\n        if (options) {\r\n            computeFacetNormals = options.facetNormals ? true : false;\r\n            computeFacetPositions = options.facetPositions ? true : false;\r\n            computeFacetPartitioning = options.facetPartitioning ? true : false;\r\n            faceNormalSign = options.useRightHandedSystem === true ? -1 : 1;\r\n            ratio = options.ratio || 0;\r\n            computeDepthSort = options.depthSort ? true : false;\r\n            distanceTo = <Vector3>options.distanceTo;\r\n            if (computeDepthSort) {\r\n                if (distanceTo === undefined) {\r\n                    distanceTo = Vector3.Zero();\r\n                }\r\n            }\r\n        }\r\n\r\n        // facetPartitioning reinit if needed\r\n        let xSubRatio = 0;\r\n        let ySubRatio = 0;\r\n        let zSubRatio = 0;\r\n        let subSq = 0;\r\n        if (computeFacetPartitioning && options && options.bbSize) {\r\n            //let bbSizeMax = options.bbSize.x > options.bbSize.y ? options.bbSize.x : options.bbSize.y;\r\n            //bbSizeMax = bbSizeMax > options.bbSize.z ? bbSizeMax : options.bbSize.z;\r\n            xSubRatio = (options.subDiv.X * ratio) / options.bbSize.x;\r\n            ySubRatio = (options.subDiv.Y * ratio) / options.bbSize.y;\r\n            zSubRatio = (options.subDiv.Z * ratio) / options.bbSize.z;\r\n            subSq = options.subDiv.max * options.subDiv.max;\r\n            options.facetPartitioning.length = 0;\r\n        }\r\n\r\n        // reset the normals\r\n        for (index = 0; index < positions.length; index++) {\r\n            normals[index] = 0.0;\r\n        }\r\n\r\n        // Loop : 1 indice triplet = 1 facet\r\n        const nbFaces = (indices.length / 3) | 0;\r\n        for (index = 0; index < nbFaces; index++) {\r\n            // get the indexes of the coordinates of each vertex of the facet\r\n            v1x = indices[index * 3] * 3;\r\n            v1y = v1x + 1;\r\n            v1z = v1x + 2;\r\n            v2x = indices[index * 3 + 1] * 3;\r\n            v2y = v2x + 1;\r\n            v2z = v2x + 2;\r\n            v3x = indices[index * 3 + 2] * 3;\r\n            v3y = v3x + 1;\r\n            v3z = v3x + 2;\r\n\r\n            p1p2x = positions[v1x] - positions[v2x]; // compute two vectors per facet : p1p2 and p3p2\r\n            p1p2y = positions[v1y] - positions[v2y];\r\n            p1p2z = positions[v1z] - positions[v2z];\r\n\r\n            p3p2x = positions[v3x] - positions[v2x];\r\n            p3p2y = positions[v3y] - positions[v2y];\r\n            p3p2z = positions[v3z] - positions[v2z];\r\n\r\n            // compute the face normal with the cross product\r\n            faceNormalx = faceNormalSign * (p1p2y * p3p2z - p1p2z * p3p2y);\r\n            faceNormaly = faceNormalSign * (p1p2z * p3p2x - p1p2x * p3p2z);\r\n            faceNormalz = faceNormalSign * (p1p2x * p3p2y - p1p2y * p3p2x);\r\n            // normalize this normal and store it in the array facetData\r\n            length = Math.sqrt(faceNormalx * faceNormalx + faceNormaly * faceNormaly + faceNormalz * faceNormalz);\r\n            length = length === 0 ? 1.0 : length;\r\n            faceNormalx /= length;\r\n            faceNormaly /= length;\r\n            faceNormalz /= length;\r\n\r\n            if (computeFacetNormals && options) {\r\n                options.facetNormals[index].x = faceNormalx;\r\n                options.facetNormals[index].y = faceNormaly;\r\n                options.facetNormals[index].z = faceNormalz;\r\n            }\r\n\r\n            if (computeFacetPositions && options) {\r\n                // compute and the facet barycenter coordinates in the array facetPositions\r\n                options.facetPositions[index].x = (positions[v1x] + positions[v2x] + positions[v3x]) / 3.0;\r\n                options.facetPositions[index].y = (positions[v1y] + positions[v2y] + positions[v3y]) / 3.0;\r\n                options.facetPositions[index].z = (positions[v1z] + positions[v2z] + positions[v3z]) / 3.0;\r\n            }\r\n\r\n            if (computeFacetPartitioning && options) {\r\n                // store the facet indexes in arrays in the main facetPartitioning array :\r\n                // compute each facet vertex (+ facet barycenter) index in the partiniong array\r\n                const ox = Math.floor((options.facetPositions[index].x - options.bInfo.minimum.x * ratio) * xSubRatio);\r\n                const oy = Math.floor((options.facetPositions[index].y - options.bInfo.minimum.y * ratio) * ySubRatio);\r\n                const oz = Math.floor((options.facetPositions[index].z - options.bInfo.minimum.z * ratio) * zSubRatio);\r\n                const b1x = Math.floor((positions[v1x] - options.bInfo.minimum.x * ratio) * xSubRatio);\r\n                const b1y = Math.floor((positions[v1y] - options.bInfo.minimum.y * ratio) * ySubRatio);\r\n                const b1z = Math.floor((positions[v1z] - options.bInfo.minimum.z * ratio) * zSubRatio);\r\n                const b2x = Math.floor((positions[v2x] - options.bInfo.minimum.x * ratio) * xSubRatio);\r\n                const b2y = Math.floor((positions[v2y] - options.bInfo.minimum.y * ratio) * ySubRatio);\r\n                const b2z = Math.floor((positions[v2z] - options.bInfo.minimum.z * ratio) * zSubRatio);\r\n                const b3x = Math.floor((positions[v3x] - options.bInfo.minimum.x * ratio) * xSubRatio);\r\n                const b3y = Math.floor((positions[v3y] - options.bInfo.minimum.y * ratio) * ySubRatio);\r\n                const b3z = Math.floor((positions[v3z] - options.bInfo.minimum.z * ratio) * zSubRatio);\r\n\r\n                const block_idx_v1 = b1x + options.subDiv.max * b1y + subSq * b1z;\r\n                const block_idx_v2 = b2x + options.subDiv.max * b2y + subSq * b2z;\r\n                const block_idx_v3 = b3x + options.subDiv.max * b3y + subSq * b3z;\r\n                const block_idx_o = ox + options.subDiv.max * oy + subSq * oz;\r\n\r\n                options.facetPartitioning[block_idx_o] = options.facetPartitioning[block_idx_o] ? options.facetPartitioning[block_idx_o] : new Array();\r\n                options.facetPartitioning[block_idx_v1] = options.facetPartitioning[block_idx_v1] ? options.facetPartitioning[block_idx_v1] : new Array();\r\n                options.facetPartitioning[block_idx_v2] = options.facetPartitioning[block_idx_v2] ? options.facetPartitioning[block_idx_v2] : new Array();\r\n                options.facetPartitioning[block_idx_v3] = options.facetPartitioning[block_idx_v3] ? options.facetPartitioning[block_idx_v3] : new Array();\r\n\r\n                // push each facet index in each block containing the vertex\r\n                options.facetPartitioning[block_idx_v1].push(index);\r\n                if (block_idx_v2 != block_idx_v1) {\r\n                    options.facetPartitioning[block_idx_v2].push(index);\r\n                }\r\n                if (!(block_idx_v3 == block_idx_v2 || block_idx_v3 == block_idx_v1)) {\r\n                    options.facetPartitioning[block_idx_v3].push(index);\r\n                }\r\n                if (!(block_idx_o == block_idx_v1 || block_idx_o == block_idx_v2 || block_idx_o == block_idx_v3)) {\r\n                    options.facetPartitioning[block_idx_o].push(index);\r\n                }\r\n            }\r\n\r\n            if (computeDepthSort && options && options.facetPositions) {\r\n                const dsf = options.depthSortedFacets[index];\r\n                dsf.ind = index * 3;\r\n                dsf.sqDistance = Vector3.DistanceSquared(options.facetPositions[index], distanceTo!);\r\n            }\r\n\r\n            // compute the normals anyway\r\n            normals[v1x] += faceNormalx; // accumulate all the normals per face\r\n            normals[v1y] += faceNormaly;\r\n            normals[v1z] += faceNormalz;\r\n            normals[v2x] += faceNormalx;\r\n            normals[v2y] += faceNormaly;\r\n            normals[v2z] += faceNormalz;\r\n            normals[v3x] += faceNormalx;\r\n            normals[v3y] += faceNormaly;\r\n            normals[v3z] += faceNormalz;\r\n        }\r\n        // last normalization of each normal\r\n        for (index = 0; index < normals.length / 3; index++) {\r\n            faceNormalx = normals[index * 3];\r\n            faceNormaly = normals[index * 3 + 1];\r\n            faceNormalz = normals[index * 3 + 2];\r\n\r\n            length = Math.sqrt(faceNormalx * faceNormalx + faceNormaly * faceNormaly + faceNormalz * faceNormalz);\r\n            length = length === 0 ? 1.0 : length;\r\n            faceNormalx /= length;\r\n            faceNormaly /= length;\r\n            faceNormalz /= length;\r\n\r\n            normals[index * 3] = faceNormalx;\r\n            normals[index * 3 + 1] = faceNormaly;\r\n            normals[index * 3 + 2] = faceNormalz;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public static _ComputeSides(\r\n        sideOrientation: number,\r\n        positions: FloatArray,\r\n        indices: FloatArray | IndicesArray,\r\n        normals: FloatArray,\r\n        uvs: FloatArray,\r\n        frontUVs?: Vector4,\r\n        backUVs?: Vector4\r\n    ) {\r\n        const li: number = indices.length;\r\n        const ln: number = normals.length;\r\n        let i: number;\r\n        let n: number;\r\n        sideOrientation = sideOrientation || VertexData.DEFAULTSIDE;\r\n\r\n        switch (sideOrientation) {\r\n            case VertexData.FRONTSIDE:\r\n                // nothing changed\r\n                break;\r\n\r\n            case VertexData.BACKSIDE:\r\n                // indices\r\n                for (i = 0; i < li; i += 3) {\r\n                    const tmp = indices[i];\r\n                    indices[i] = indices[i + 2];\r\n                    indices[i + 2] = tmp;\r\n                }\r\n                // normals\r\n                for (n = 0; n < ln; n++) {\r\n                    normals[n] = -normals[n];\r\n                }\r\n                break;\r\n\r\n            case VertexData.DOUBLESIDE: {\r\n                // positions\r\n                const lp: number = positions.length;\r\n                const l: number = lp / 3;\r\n                for (let p = 0; p < lp; p++) {\r\n                    positions[lp + p] = positions[p];\r\n                }\r\n                // indices\r\n                for (i = 0; i < li; i += 3) {\r\n                    indices[i + li] = indices[i + 2] + l;\r\n                    indices[i + 1 + li] = indices[i + 1] + l;\r\n                    indices[i + 2 + li] = indices[i] + l;\r\n                }\r\n                // normals\r\n                for (n = 0; n < ln; n++) {\r\n                    normals[ln + n] = -normals[n];\r\n                }\r\n\r\n                // uvs\r\n                const lu: number = uvs.length;\r\n                let u: number = 0;\r\n                for (u = 0; u < lu; u++) {\r\n                    uvs[u + lu] = uvs[u];\r\n                }\r\n                frontUVs = frontUVs ? frontUVs : new Vector4(0.0, 0.0, 1.0, 1.0);\r\n                backUVs = backUVs ? backUVs : new Vector4(0.0, 0.0, 1.0, 1.0);\r\n                u = 0;\r\n                for (i = 0; i < lu / 2; i++) {\r\n                    uvs[u] = frontUVs.x + (frontUVs.z - frontUVs.x) * uvs[u];\r\n                    uvs[u + 1] = frontUVs.y + (frontUVs.w - frontUVs.y) * uvs[u + 1];\r\n                    uvs[u + lu] = backUVs.x + (backUVs.z - backUVs.x) * uvs[u + lu];\r\n                    uvs[u + lu + 1] = backUVs.y + (backUVs.w - backUVs.y) * uvs[u + lu + 1];\r\n                    u += 2;\r\n                }\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Creates a VertexData from serialized data\r\n     * @param parsedVertexData the parsed data from an imported file\r\n     * @returns a VertexData\r\n     */\r\n    public static Parse(parsedVertexData: any) {\r\n        const vertexData = new VertexData();\r\n\r\n        // positions\r\n        const positions = parsedVertexData.positions;\r\n        if (positions) {\r\n            vertexData.set(positions, VertexBuffer.PositionKind);\r\n        }\r\n\r\n        // normals\r\n        const normals = parsedVertexData.normals;\r\n        if (normals) {\r\n            vertexData.set(normals, VertexBuffer.NormalKind);\r\n        }\r\n\r\n        // tangents\r\n        const tangents = parsedVertexData.tangents;\r\n        if (tangents) {\r\n            vertexData.set(tangents, VertexBuffer.TangentKind);\r\n        }\r\n\r\n        // uvs\r\n        const uvs = parsedVertexData.uvs;\r\n        if (uvs) {\r\n            vertexData.set(uvs, VertexBuffer.UVKind);\r\n        }\r\n\r\n        // uv2s\r\n        const uvs2 = parsedVertexData.uvs2;\r\n        if (uvs2) {\r\n            vertexData.set(uvs2, VertexBuffer.UV2Kind);\r\n        }\r\n\r\n        // uv3s\r\n        const uvs3 = parsedVertexData.uvs3;\r\n        if (uvs3) {\r\n            vertexData.set(uvs3, VertexBuffer.UV3Kind);\r\n        }\r\n\r\n        // uv4s\r\n        const uvs4 = parsedVertexData.uvs4;\r\n        if (uvs4) {\r\n            vertexData.set(uvs4, VertexBuffer.UV4Kind);\r\n        }\r\n\r\n        // uv5s\r\n        const uvs5 = parsedVertexData.uvs5;\r\n        if (uvs5) {\r\n            vertexData.set(uvs5, VertexBuffer.UV5Kind);\r\n        }\r\n\r\n        // uv6s\r\n        const uvs6 = parsedVertexData.uvs6;\r\n        if (uvs6) {\r\n            vertexData.set(uvs6, VertexBuffer.UV6Kind);\r\n        }\r\n\r\n        // colors\r\n        const colors = parsedVertexData.colors;\r\n        if (colors) {\r\n            vertexData.set(Color4.CheckColors4(colors, positions.length / 3), VertexBuffer.ColorKind);\r\n        }\r\n\r\n        // matricesIndices\r\n        const matricesIndices = parsedVertexData.matricesIndices;\r\n        if (matricesIndices) {\r\n            vertexData.set(matricesIndices, VertexBuffer.MatricesIndicesKind);\r\n        }\r\n\r\n        // matricesWeights\r\n        const matricesWeights = parsedVertexData.matricesWeights;\r\n        if (matricesWeights) {\r\n            vertexData.set(matricesWeights, VertexBuffer.MatricesWeightsKind);\r\n        }\r\n\r\n        // indices\r\n        const indices = parsedVertexData.indices;\r\n        if (indices) {\r\n            vertexData.indices = indices;\r\n        }\r\n\r\n        // MaterialInfos\r\n        const materialInfos = parsedVertexData.materialInfos;\r\n        if (materialInfos) {\r\n            vertexData.materialInfos = [];\r\n            for (const materialInfoFromJSON of materialInfos) {\r\n                const materialInfo = new VertexDataMaterialInfo();\r\n                materialInfo.indexCount = materialInfoFromJSON.indexCount;\r\n                materialInfo.indexStart = materialInfoFromJSON.indexStart;\r\n                materialInfo.verticesCount = materialInfoFromJSON.verticesCount;\r\n                materialInfo.verticesStart = materialInfoFromJSON.verticesStart;\r\n                materialInfo.materialIndex = materialInfoFromJSON.materialIndex;\r\n                vertexData.materialInfos.push(materialInfo);\r\n            }\r\n        }\r\n\r\n        return vertexData;\r\n    }\r\n\r\n    /**\r\n     * Applies VertexData created from the imported parameters to the geometry\r\n     * @param parsedVertexData the parsed data from an imported file\r\n     * @param geometry the geometry to apply the VertexData to\r\n     */\r\n    public static ImportVertexData(parsedVertexData: any, geometry: Geometry) {\r\n        const vertexData = VertexData.Parse(parsedVertexData);\r\n\r\n        geometry.setAllVerticesData(vertexData, parsedVertexData.updatable);\r\n    }\r\n}\r\n"]}