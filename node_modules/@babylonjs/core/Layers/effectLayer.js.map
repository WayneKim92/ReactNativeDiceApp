{"version":3,"file":"effectLayer.js","sourceRoot":"","sources":["../../../../dev/core/src/Layers/effectLayer.ts"],"names":[],"mappings":"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","sourcesContent":["import { serialize, serializeAsColor4, serializeAsCameraReference } from \"../Misc/decorators\";\r\nimport { Tools } from \"../Misc/tools\";\r\nimport type { SmartArray } from \"../Misc/smartArray\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { Camera } from \"../Cameras/camera\";\r\nimport type { Scene } from \"../scene\";\r\nimport type { ISize } from \"../Maths/math.size\";\r\nimport { Color4 } from \"../Maths/math.color\";\r\nimport { Engine } from \"../Engines/engine\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\nimport { VertexBuffer } from \"../Buffers/buffer\";\r\nimport type { SubMesh } from \"../Meshes/subMesh\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport type { Mesh } from \"../Meshes/mesh\";\r\nimport type { PostProcess } from \"../PostProcesses/postProcess\";\r\nimport type { BaseTexture } from \"../Materials/Textures/baseTexture\";\r\nimport { Texture } from \"../Materials/Textures/texture\";\r\nimport { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture\";\r\nimport type { Effect } from \"../Materials/effect\";\r\nimport { Material } from \"../Materials/material\";\r\nimport { MaterialHelper } from \"../Materials/materialHelper\";\r\nimport { Constants } from \"../Engines/constants\";\r\n\r\nimport \"../Shaders/glowMapGeneration.fragment\";\r\nimport \"../Shaders/glowMapGeneration.vertex\";\r\nimport { _WarnImport } from \"../Misc/devTools\";\r\nimport type { DataBuffer } from \"../Buffers/dataBuffer\";\r\nimport { EffectFallbacks } from \"../Materials/effectFallbacks\";\r\nimport { DrawWrapper } from \"../Materials/drawWrapper\";\r\nimport { addClipPlaneUniforms, bindClipPlane, prepareStringDefinesForClipPlanes } from \"../Materials/clipPlaneMaterialHelper\";\r\n\r\n/**\r\n * Effect layer options. This helps customizing the behaviour\r\n * of the effect layer.\r\n */\r\nexport interface IEffectLayerOptions {\r\n    /**\r\n     * Multiplication factor apply to the canvas size to compute the render target size\r\n     * used to generated the objects (the smaller the faster). Default: 0.5\r\n     */\r\n    mainTextureRatio: number;\r\n\r\n    /**\r\n     * Enforces a fixed size texture to ensure effect stability across devices. Default: undefined\r\n     */\r\n    mainTextureFixedSize?: number;\r\n\r\n    /**\r\n     * Alpha blending mode used to apply the blur. Default depends of the implementation. Default: ALPHA_COMBINE\r\n     */\r\n    alphaBlendingMode: number;\r\n\r\n    /**\r\n     * The camera attached to the layer. Default: null\r\n     */\r\n    camera: Nullable<Camera>;\r\n\r\n    /**\r\n     * The rendering group to draw the layer in. Default: -1\r\n     */\r\n    renderingGroupId: number;\r\n\r\n    /**\r\n     * The type of the main texture. Default: TEXTURETYPE_UNSIGNED_INT\r\n     */\r\n    mainTextureType: number;\r\n\r\n    /**\r\n     * Whether or not to generate a stencil buffer. Default: false\r\n     */\r\n    generateStencilBuffer: boolean;\r\n}\r\n\r\n/**\r\n * The effect layer Helps adding post process effect blended with the main pass.\r\n *\r\n * This can be for instance use to generate glow or highlight effects on the scene.\r\n *\r\n * The effect layer class can not be used directly and is intented to inherited from to be\r\n * customized per effects.\r\n */\r\nexport abstract class EffectLayer {\r\n    private _vertexBuffers: { [key: string]: Nullable<VertexBuffer> } = {};\r\n    private _indexBuffer: Nullable<DataBuffer>;\r\n    private _effectLayerOptions: IEffectLayerOptions;\r\n    private _mergeDrawWrapper: DrawWrapper[];\r\n\r\n    protected _scene: Scene;\r\n    protected _engine: Engine;\r\n    protected _maxSize: number = 0;\r\n    protected _mainTextureDesiredSize: ISize = { width: 0, height: 0 };\r\n    protected _mainTexture: RenderTargetTexture;\r\n    protected _shouldRender = true;\r\n    protected _postProcesses: PostProcess[] = [];\r\n    protected _textures: BaseTexture[] = [];\r\n    protected _emissiveTextureAndColor: { texture: Nullable<BaseTexture>; color: Color4 } = { texture: null, color: new Color4() };\r\n    protected _effectIntensity: { [meshUniqueId: number]: number } = {};\r\n\r\n    /**\r\n     * The name of the layer\r\n     */\r\n    @serialize()\r\n    public name: string;\r\n\r\n    /**\r\n     * The clear color of the texture used to generate the glow map.\r\n     */\r\n    @serializeAsColor4()\r\n    public neutralColor: Color4 = new Color4();\r\n\r\n    /**\r\n     * Specifies whether the highlight layer is enabled or not.\r\n     */\r\n    @serialize()\r\n    public isEnabled: boolean = true;\r\n\r\n    /**\r\n     * Gets the camera attached to the layer.\r\n     */\r\n    @serializeAsCameraReference()\r\n    public get camera(): Nullable<Camera> {\r\n        return this._effectLayerOptions.camera;\r\n    }\r\n\r\n    /**\r\n     * Gets the rendering group id the layer should render in.\r\n     */\r\n    @serialize()\r\n    public get renderingGroupId(): number {\r\n        return this._effectLayerOptions.renderingGroupId;\r\n    }\r\n    public set renderingGroupId(renderingGroupId: number) {\r\n        this._effectLayerOptions.renderingGroupId = renderingGroupId;\r\n    }\r\n\r\n    /**\r\n     * Specifies if the bounding boxes should be rendered normally or if they should undergo the effect of the layer\r\n     */\r\n    @serialize()\r\n    public disableBoundingBoxesFromEffectLayer = false;\r\n\r\n    /**\r\n     * An event triggered when the effect layer has been disposed.\r\n     */\r\n    public onDisposeObservable = new Observable<EffectLayer>();\r\n\r\n    /**\r\n     * An event triggered when the effect layer is about rendering the main texture with the glowy parts.\r\n     */\r\n    public onBeforeRenderMainTextureObservable = new Observable<EffectLayer>();\r\n\r\n    /**\r\n     * An event triggered when the generated texture is being merged in the scene.\r\n     */\r\n    public onBeforeComposeObservable = new Observable<EffectLayer>();\r\n\r\n    /**\r\n     * An event triggered when the mesh is rendered into the effect render target.\r\n     */\r\n    public onBeforeRenderMeshToEffect = new Observable<AbstractMesh>();\r\n\r\n    /**\r\n     * An event triggered after the mesh has been rendered into the effect render target.\r\n     */\r\n    public onAfterRenderMeshToEffect = new Observable<AbstractMesh>();\r\n\r\n    /**\r\n     * An event triggered when the generated texture has been merged in the scene.\r\n     */\r\n    public onAfterComposeObservable = new Observable<EffectLayer>();\r\n\r\n    /**\r\n     * An event triggered when the effect layer changes its size.\r\n     */\r\n    public onSizeChangedObservable = new Observable<EffectLayer>();\r\n\r\n    /**\r\n     * Gets the main texture where the effect is rendered\r\n     */\r\n    public get mainTexture() {\r\n        return this._mainTexture;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public static _SceneComponentInitialization: (scene: Scene) => void = (_) => {\r\n        throw _WarnImport(\"EffectLayerSceneComponent\");\r\n    };\r\n\r\n    private _materialForRendering: { [id: string]: [AbstractMesh, Material] } = {};\r\n\r\n    /**\r\n     * Sets a specific material to be used to render a mesh/a list of meshes in the layer\r\n     * @param mesh mesh or array of meshes\r\n     * @param material material to use by the layer when rendering the mesh(es). If undefined is passed, the specific material created by the layer will be used.\r\n     */\r\n    public setMaterialForRendering(mesh: AbstractMesh | AbstractMesh[], material?: Material): void {\r\n        this._mainTexture.setMaterialForRendering(mesh, material);\r\n        if (Array.isArray(mesh)) {\r\n            for (let i = 0; i < mesh.length; ++i) {\r\n                const currentMesh = mesh[i];\r\n                if (!material) {\r\n                    delete this._materialForRendering[currentMesh.uniqueId];\r\n                } else {\r\n                    this._materialForRendering[currentMesh.uniqueId] = [currentMesh, material];\r\n                }\r\n            }\r\n        } else {\r\n            if (!material) {\r\n                delete this._materialForRendering[mesh.uniqueId];\r\n            } else {\r\n                this._materialForRendering[mesh.uniqueId] = [mesh, material];\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the intensity of the effect for a specific mesh.\r\n     * @param mesh The mesh to get the effect intensity for\r\n     * @returns The intensity of the effect for the mesh\r\n     */\r\n    public getEffectIntensity(mesh: AbstractMesh) {\r\n        return this._effectIntensity[mesh.uniqueId] ?? 1;\r\n    }\r\n\r\n    /**\r\n     * Sets the intensity of the effect for a specific mesh.\r\n     * @param mesh The mesh to set the effect intensity for\r\n     * @param intensity The intensity of the effect for the mesh\r\n     */\r\n    public setEffectIntensity(mesh: AbstractMesh, intensity: number): void {\r\n        this._effectIntensity[mesh.uniqueId] = intensity;\r\n    }\r\n\r\n    /**\r\n     * Instantiates a new effect Layer and references it in the scene.\r\n     * @param name The name of the layer\r\n     * @param scene The scene to use the layer in\r\n     */\r\n    constructor(\r\n        /** The Friendly of the effect in the scene */\r\n        name: string,\r\n        scene?: Scene\r\n    ) {\r\n        this.name = name;\r\n\r\n        this._scene = scene || <Scene>EngineStore.LastCreatedScene;\r\n        EffectLayer._SceneComponentInitialization(this._scene);\r\n\r\n        this._engine = this._scene.getEngine();\r\n        this._maxSize = this._engine.getCaps().maxTextureSize;\r\n        this._scene.effectLayers.push(this);\r\n\r\n        this._mergeDrawWrapper = [];\r\n\r\n        // Generate Buffers\r\n        this._generateIndexBuffer();\r\n        this._generateVertexBuffer();\r\n    }\r\n\r\n    /**\r\n     * Get the effect name of the layer.\r\n     * @returns The effect name\r\n     */\r\n    public abstract getEffectName(): string;\r\n\r\n    /**\r\n     * Checks for the readiness of the element composing the layer.\r\n     * @param subMesh the mesh to check for\r\n     * @param useInstances specify whether or not to use instances to render the mesh\r\n     * @returns true if ready otherwise, false\r\n     */\r\n    public abstract isReady(subMesh: SubMesh, useInstances: boolean): boolean;\r\n\r\n    /**\r\n     * Returns whether or not the layer needs stencil enabled during the mesh rendering.\r\n     * @returns true if the effect requires stencil during the main canvas render pass.\r\n     */\r\n    public abstract needStencil(): boolean;\r\n\r\n    /**\r\n     * Create the merge effect. This is the shader use to blit the information back\r\n     * to the main canvas at the end of the scene rendering.\r\n     * @returns The effect containing the shader used to merge the effect on the  main canvas\r\n     */\r\n    protected abstract _createMergeEffect(): Effect;\r\n\r\n    /**\r\n     * Creates the render target textures and post processes used in the effect layer.\r\n     */\r\n    protected abstract _createTextureAndPostProcesses(): void;\r\n\r\n    /**\r\n     * Implementation specific of rendering the generating effect on the main canvas.\r\n     * @param effect The effect used to render through\r\n     * @param renderNum Index of the _internalRender call (0 for the first time _internalRender is called, 1 for the second time, etc. _internalRender is called the number of times returned by _numInternalDraws())\r\n     */\r\n    protected abstract _internalRender(effect: Effect, renderIndex: number): void;\r\n\r\n    /**\r\n     * Sets the required values for both the emissive texture and and the main color.\r\n     */\r\n    protected abstract _setEmissiveTextureAndColor(mesh: Mesh, subMesh: SubMesh, material: Material): void;\r\n\r\n    /**\r\n     * Free any resources and references associated to a mesh.\r\n     * Internal use\r\n     * @param mesh The mesh to free.\r\n     */\r\n    public abstract _disposeMesh(mesh: Mesh): void;\r\n\r\n    /**\r\n     * Serializes this layer (Glow or Highlight for example)\r\n     * @returns a serialized layer object\r\n     */\r\n    public abstract serialize?(): any;\r\n\r\n    /**\r\n     * Number of times _internalRender will be called. Some effect layers need to render the mesh several times, so they should override this method with the number of times the mesh should be rendered\r\n     * @returns Number of times a mesh must be rendered in the layer\r\n     */\r\n    protected _numInternalDraws(): number {\r\n        return 1;\r\n    }\r\n\r\n    /**\r\n     * Initializes the effect layer with the required options.\r\n     * @param options Sets of none mandatory options to use with the layer (see IEffectLayerOptions for more information)\r\n     */\r\n    protected _init(options: Partial<IEffectLayerOptions>): void {\r\n        // Adapt options\r\n        this._effectLayerOptions = {\r\n            mainTextureRatio: 0.5,\r\n            alphaBlendingMode: Constants.ALPHA_COMBINE,\r\n            camera: null,\r\n            renderingGroupId: -1,\r\n            mainTextureType: Constants.TEXTURETYPE_UNSIGNED_INT,\r\n            generateStencilBuffer: false,\r\n            ...options,\r\n        };\r\n\r\n        this._setMainTextureSize();\r\n        this._createMainTexture();\r\n        this._createTextureAndPostProcesses();\r\n    }\r\n\r\n    /**\r\n     * Generates the index buffer of the full screen quad blending to the main canvas.\r\n     */\r\n    private _generateIndexBuffer(): void {\r\n        // Indices\r\n        const indices = [];\r\n        indices.push(0);\r\n        indices.push(1);\r\n        indices.push(2);\r\n\r\n        indices.push(0);\r\n        indices.push(2);\r\n        indices.push(3);\r\n\r\n        this._indexBuffer = this._engine.createIndexBuffer(indices);\r\n    }\r\n\r\n    /**\r\n     * Generates the vertex buffer of the full screen quad blending to the main canvas.\r\n     */\r\n    private _generateVertexBuffer(): void {\r\n        // VBO\r\n        const vertices = [];\r\n        vertices.push(1, 1);\r\n        vertices.push(-1, 1);\r\n        vertices.push(-1, -1);\r\n        vertices.push(1, -1);\r\n\r\n        const vertexBuffer = new VertexBuffer(this._engine, vertices, VertexBuffer.PositionKind, false, false, 2);\r\n        this._vertexBuffers[VertexBuffer.PositionKind] = vertexBuffer;\r\n    }\r\n\r\n    /**\r\n     * Sets the main texture desired size which is the closest power of two\r\n     * of the engine canvas size.\r\n     */\r\n    private _setMainTextureSize(): void {\r\n        if (this._effectLayerOptions.mainTextureFixedSize) {\r\n            this._mainTextureDesiredSize.width = this._effectLayerOptions.mainTextureFixedSize;\r\n            this._mainTextureDesiredSize.height = this._effectLayerOptions.mainTextureFixedSize;\r\n        } else {\r\n            this._mainTextureDesiredSize.width = this._engine.getRenderWidth() * this._effectLayerOptions.mainTextureRatio;\r\n            this._mainTextureDesiredSize.height = this._engine.getRenderHeight() * this._effectLayerOptions.mainTextureRatio;\r\n\r\n            this._mainTextureDesiredSize.width = this._engine.needPOTTextures\r\n                ? Engine.GetExponentOfTwo(this._mainTextureDesiredSize.width, this._maxSize)\r\n                : this._mainTextureDesiredSize.width;\r\n            this._mainTextureDesiredSize.height = this._engine.needPOTTextures\r\n                ? Engine.GetExponentOfTwo(this._mainTextureDesiredSize.height, this._maxSize)\r\n                : this._mainTextureDesiredSize.height;\r\n        }\r\n\r\n        this._mainTextureDesiredSize.width = Math.floor(this._mainTextureDesiredSize.width);\r\n        this._mainTextureDesiredSize.height = Math.floor(this._mainTextureDesiredSize.height);\r\n    }\r\n\r\n    /**\r\n     * Creates the main texture for the effect layer.\r\n     */\r\n    protected _createMainTexture(): void {\r\n        this._mainTexture = new RenderTargetTexture(\r\n            \"EffectLayerMainRTT\",\r\n            {\r\n                width: this._mainTextureDesiredSize.width,\r\n                height: this._mainTextureDesiredSize.height,\r\n            },\r\n            this._scene,\r\n            false,\r\n            true,\r\n            this._effectLayerOptions.mainTextureType,\r\n            false,\r\n            Texture.TRILINEAR_SAMPLINGMODE,\r\n            true,\r\n            this._effectLayerOptions.generateStencilBuffer\r\n        );\r\n        this._mainTexture.activeCamera = this._effectLayerOptions.camera;\r\n        this._mainTexture.wrapU = Texture.CLAMP_ADDRESSMODE;\r\n        this._mainTexture.wrapV = Texture.CLAMP_ADDRESSMODE;\r\n        this._mainTexture.anisotropicFilteringLevel = 1;\r\n        this._mainTexture.updateSamplingMode(Texture.BILINEAR_SAMPLINGMODE);\r\n        this._mainTexture.renderParticles = false;\r\n        this._mainTexture.renderList = null;\r\n        this._mainTexture.ignoreCameraViewport = true;\r\n\r\n        for (const id in this._materialForRendering) {\r\n            const [mesh, material] = this._materialForRendering[id];\r\n            this._mainTexture.setMaterialForRendering(mesh, material);\r\n        }\r\n\r\n        this._mainTexture.customIsReadyFunction = (mesh: AbstractMesh, refreshRate: number, preWarm?: boolean) => {\r\n            if ((preWarm || refreshRate === 0) && mesh.subMeshes) {\r\n                for (let i = 0; i < mesh.subMeshes.length; ++i) {\r\n                    const subMesh = mesh.subMeshes[i];\r\n                    const material = subMesh.getMaterial();\r\n                    const renderingMesh = subMesh.getRenderingMesh();\r\n\r\n                    if (!material) {\r\n                        continue;\r\n                    }\r\n\r\n                    const batch = renderingMesh._getInstancesRenderList(subMesh._id, !!subMesh.getReplacementMesh());\r\n                    const hardwareInstancedRendering = batch.hardwareInstancedRendering[subMesh._id] || renderingMesh.hasThinInstances;\r\n\r\n                    this._setEmissiveTextureAndColor(renderingMesh, subMesh, material);\r\n\r\n                    if (!this._isReady(subMesh, hardwareInstancedRendering, this._emissiveTextureAndColor.texture)) {\r\n                        return false;\r\n                    }\r\n                }\r\n            }\r\n\r\n            return true;\r\n        };\r\n\r\n        // Custom render function\r\n        this._mainTexture.customRenderFunction = (\r\n            opaqueSubMeshes: SmartArray<SubMesh>,\r\n            alphaTestSubMeshes: SmartArray<SubMesh>,\r\n            transparentSubMeshes: SmartArray<SubMesh>,\r\n            depthOnlySubMeshes: SmartArray<SubMesh>\r\n        ): void => {\r\n            this.onBeforeRenderMainTextureObservable.notifyObservers(this);\r\n\r\n            let index: number;\r\n\r\n            const engine = this._scene.getEngine();\r\n\r\n            if (depthOnlySubMeshes.length) {\r\n                engine.setColorWrite(false);\r\n                for (index = 0; index < depthOnlySubMeshes.length; index++) {\r\n                    this._renderSubMesh(depthOnlySubMeshes.data[index]);\r\n                }\r\n                engine.setColorWrite(true);\r\n            }\r\n\r\n            for (index = 0; index < opaqueSubMeshes.length; index++) {\r\n                this._renderSubMesh(opaqueSubMeshes.data[index]);\r\n            }\r\n\r\n            for (index = 0; index < alphaTestSubMeshes.length; index++) {\r\n                this._renderSubMesh(alphaTestSubMeshes.data[index]);\r\n            }\r\n\r\n            const previousAlphaMode = engine.getAlphaMode();\r\n\r\n            for (index = 0; index < transparentSubMeshes.length; index++) {\r\n                this._renderSubMesh(transparentSubMeshes.data[index], true);\r\n            }\r\n\r\n            engine.setAlphaMode(previousAlphaMode);\r\n        };\r\n\r\n        this._mainTexture.onClearObservable.add((engine: Engine) => {\r\n            engine.clear(this.neutralColor, true, true, true);\r\n        });\r\n\r\n        // Prevent package size in es6 (getBoundingBoxRenderer might not be present)\r\n        if (this._scene.getBoundingBoxRenderer) {\r\n            const boundingBoxRendererEnabled = this._scene.getBoundingBoxRenderer().enabled;\r\n\r\n            this._mainTexture.onBeforeBindObservable.add(() => {\r\n                this._scene.getBoundingBoxRenderer().enabled = !this.disableBoundingBoxesFromEffectLayer && boundingBoxRendererEnabled;\r\n            });\r\n\r\n            this._mainTexture.onAfterUnbindObservable.add(() => {\r\n                this._scene.getBoundingBoxRenderer().enabled = boundingBoxRendererEnabled;\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Adds specific effects defines.\r\n     * @param defines The defines to add specifics to.\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    protected _addCustomEffectDefines(defines: string[]): void {\r\n        // Nothing to add by default.\r\n    }\r\n\r\n    /**\r\n     * Checks for the readiness of the element composing the layer.\r\n     * @param subMesh the mesh to check for\r\n     * @param useInstances specify whether or not to use instances to render the mesh\r\n     * @param emissiveTexture the associated emissive texture used to generate the glow\r\n     * @returns true if ready otherwise, false\r\n     */\r\n    protected _isReady(subMesh: SubMesh, useInstances: boolean, emissiveTexture: Nullable<BaseTexture>): boolean {\r\n        const engine = this._scene.getEngine();\r\n        const mesh = subMesh.getMesh();\r\n\r\n        const renderingMaterial = mesh._internalAbstractMeshDataInfo._materialForRenderPass?.[engine.currentRenderPassId];\r\n\r\n        if (renderingMaterial) {\r\n            return renderingMaterial.isReadyForSubMesh(mesh, subMesh, useInstances);\r\n        }\r\n\r\n        const material = subMesh.getMaterial();\r\n\r\n        if (!material) {\r\n            return false;\r\n        }\r\n\r\n        if (this._useMeshMaterial(subMesh.getRenderingMesh())) {\r\n            return material.isReadyForSubMesh(subMesh.getMesh(), subMesh, useInstances);\r\n        }\r\n\r\n        const defines: string[] = [];\r\n\r\n        const attribs = [VertexBuffer.PositionKind];\r\n\r\n        let uv1 = false;\r\n        let uv2 = false;\r\n\r\n        // Diffuse\r\n        if (material) {\r\n            const needAlphaTest = material.needAlphaTesting();\r\n\r\n            const diffuseTexture = material.getAlphaTestTexture();\r\n            const needAlphaBlendFromDiffuse =\r\n                diffuseTexture && diffuseTexture.hasAlpha && ((material as any).useAlphaFromDiffuseTexture || (material as any)._useAlphaFromAlbedoTexture);\r\n\r\n            if (diffuseTexture && (needAlphaTest || needAlphaBlendFromDiffuse)) {\r\n                defines.push(\"#define DIFFUSE\");\r\n                if (mesh.isVerticesDataPresent(VertexBuffer.UV2Kind) && diffuseTexture.coordinatesIndex === 1) {\r\n                    defines.push(\"#define DIFFUSEUV2\");\r\n                    uv2 = true;\r\n                } else if (mesh.isVerticesDataPresent(VertexBuffer.UVKind)) {\r\n                    defines.push(\"#define DIFFUSEUV1\");\r\n                    uv1 = true;\r\n                }\r\n\r\n                if (needAlphaTest) {\r\n                    defines.push(\"#define ALPHATEST\");\r\n                    defines.push(\"#define ALPHATESTVALUE 0.4\");\r\n                }\r\n                if (!diffuseTexture.gammaSpace) {\r\n                    defines.push(\"#define DIFFUSE_ISLINEAR\");\r\n                }\r\n            }\r\n\r\n            const opacityTexture = (material as any).opacityTexture;\r\n            if (opacityTexture) {\r\n                defines.push(\"#define OPACITY\");\r\n                if (mesh.isVerticesDataPresent(VertexBuffer.UV2Kind) && opacityTexture.coordinatesIndex === 1) {\r\n                    defines.push(\"#define OPACITYUV2\");\r\n                    uv2 = true;\r\n                } else if (mesh.isVerticesDataPresent(VertexBuffer.UVKind)) {\r\n                    defines.push(\"#define OPACITYUV1\");\r\n                    uv1 = true;\r\n                }\r\n            }\r\n        }\r\n\r\n        // Emissive\r\n        if (emissiveTexture) {\r\n            defines.push(\"#define EMISSIVE\");\r\n            if (mesh.isVerticesDataPresent(VertexBuffer.UV2Kind) && emissiveTexture.coordinatesIndex === 1) {\r\n                defines.push(\"#define EMISSIVEUV2\");\r\n                uv2 = true;\r\n            } else if (mesh.isVerticesDataPresent(VertexBuffer.UVKind)) {\r\n                defines.push(\"#define EMISSIVEUV1\");\r\n                uv1 = true;\r\n            }\r\n            if (!emissiveTexture.gammaSpace) {\r\n                defines.push(\"#define EMISSIVE_ISLINEAR\");\r\n            }\r\n        }\r\n\r\n        // Vertex\r\n        if (mesh.useVertexColors && mesh.isVerticesDataPresent(VertexBuffer.ColorKind) && mesh.hasVertexAlpha && material.transparencyMode !== Material.MATERIAL_OPAQUE) {\r\n            attribs.push(VertexBuffer.ColorKind);\r\n            defines.push(\"#define VERTEXALPHA\");\r\n        }\r\n\r\n        if (uv1) {\r\n            attribs.push(VertexBuffer.UVKind);\r\n            defines.push(\"#define UV1\");\r\n        }\r\n        if (uv2) {\r\n            attribs.push(VertexBuffer.UV2Kind);\r\n            defines.push(\"#define UV2\");\r\n        }\r\n\r\n        // Bones\r\n        const fallbacks = new EffectFallbacks();\r\n        if (mesh.useBones && mesh.computeBonesUsingShaders) {\r\n            attribs.push(VertexBuffer.MatricesIndicesKind);\r\n            attribs.push(VertexBuffer.MatricesWeightsKind);\r\n            if (mesh.numBoneInfluencers > 4) {\r\n                attribs.push(VertexBuffer.MatricesIndicesExtraKind);\r\n                attribs.push(VertexBuffer.MatricesWeightsExtraKind);\r\n            }\r\n\r\n            defines.push(\"#define NUM_BONE_INFLUENCERS \" + mesh.numBoneInfluencers);\r\n\r\n            const skeleton = mesh.skeleton;\r\n            if (skeleton && skeleton.isUsingTextureForMatrices) {\r\n                defines.push(\"#define BONETEXTURE\");\r\n            } else {\r\n                defines.push(\"#define BonesPerMesh \" + (skeleton ? skeleton.bones.length + 1 : 0));\r\n            }\r\n\r\n            if (mesh.numBoneInfluencers > 0) {\r\n                fallbacks.addCPUSkinningFallback(0, mesh);\r\n            }\r\n        } else {\r\n            defines.push(\"#define NUM_BONE_INFLUENCERS 0\");\r\n        }\r\n\r\n        // Morph targets\r\n        const manager = (<Mesh>mesh).morphTargetManager;\r\n        let morphInfluencers = 0;\r\n        if (manager) {\r\n            if (manager.numInfluencers > 0) {\r\n                defines.push(\"#define MORPHTARGETS\");\r\n                morphInfluencers = manager.numInfluencers;\r\n                defines.push(\"#define NUM_MORPH_INFLUENCERS \" + morphInfluencers);\r\n                if (manager.isUsingTextureForTargets) {\r\n                    defines.push(\"#define MORPHTARGETS_TEXTURE\");\r\n                }\r\n                MaterialHelper.PrepareAttributesForMorphTargetsInfluencers(attribs, mesh, morphInfluencers);\r\n            }\r\n        }\r\n\r\n        // Instances\r\n        if (useInstances) {\r\n            defines.push(\"#define INSTANCES\");\r\n            MaterialHelper.PushAttributesForInstances(attribs);\r\n            if (subMesh.getRenderingMesh().hasThinInstances) {\r\n                defines.push(\"#define THIN_INSTANCES\");\r\n            }\r\n        }\r\n\r\n        // ClipPlanes\r\n        prepareStringDefinesForClipPlanes(material, this._scene, defines);\r\n\r\n        this._addCustomEffectDefines(defines);\r\n\r\n        // Get correct effect\r\n        const drawWrapper = subMesh._getDrawWrapper(undefined, true)!;\r\n        const cachedDefines = drawWrapper.defines as string;\r\n        const join = defines.join(\"\\n\");\r\n        if (cachedDefines !== join) {\r\n            const uniforms = [\r\n                \"world\",\r\n                \"mBones\",\r\n                \"viewProjection\",\r\n                \"glowColor\",\r\n                \"morphTargetInfluences\",\r\n                \"boneTextureWidth\",\r\n                \"diffuseMatrix\",\r\n                \"emissiveMatrix\",\r\n                \"opacityMatrix\",\r\n                \"opacityIntensity\",\r\n                \"morphTargetTextureInfo\",\r\n                \"morphTargetTextureIndices\",\r\n                \"glowIntensity\",\r\n            ];\r\n\r\n            addClipPlaneUniforms(uniforms);\r\n\r\n            drawWrapper.setEffect(\r\n                this._engine.createEffect(\r\n                    \"glowMapGeneration\",\r\n                    attribs,\r\n                    uniforms,\r\n                    [\"diffuseSampler\", \"emissiveSampler\", \"opacitySampler\", \"boneSampler\", \"morphTargets\"],\r\n                    join,\r\n                    fallbacks,\r\n                    undefined,\r\n                    undefined,\r\n                    { maxSimultaneousMorphTargets: morphInfluencers }\r\n                ),\r\n                join\r\n            );\r\n        }\r\n\r\n        return drawWrapper.effect!.isReady();\r\n    }\r\n\r\n    /**\r\n     * Renders the glowing part of the scene by blending the blurred glowing meshes on top of the rendered scene.\r\n     */\r\n    public render(): void {\r\n        for (let i = 0; i < this._postProcesses.length; i++) {\r\n            if (!this._postProcesses[i].isReady()) {\r\n                return;\r\n            }\r\n        }\r\n\r\n        const engine = this._scene.getEngine();\r\n        const numDraws = this._numInternalDraws();\r\n\r\n        // Check\r\n        let isReady = true;\r\n        for (let i = 0; i < numDraws; ++i) {\r\n            let currentEffect = this._mergeDrawWrapper[i];\r\n            if (!currentEffect) {\r\n                currentEffect = this._mergeDrawWrapper[i] = new DrawWrapper(this._engine);\r\n                currentEffect.setEffect(this._createMergeEffect());\r\n            }\r\n            isReady = isReady && currentEffect.effect!.isReady();\r\n        }\r\n\r\n        if (!isReady) {\r\n            return;\r\n        }\r\n\r\n        this.onBeforeComposeObservable.notifyObservers(this);\r\n\r\n        const previousAlphaMode = engine.getAlphaMode();\r\n\r\n        for (let i = 0; i < numDraws; ++i) {\r\n            const currentEffect = this._mergeDrawWrapper[i];\r\n\r\n            // Render\r\n            engine.enableEffect(currentEffect);\r\n            engine.setState(false);\r\n\r\n            // VBOs\r\n            engine.bindBuffers(this._vertexBuffers, this._indexBuffer, currentEffect.effect!);\r\n\r\n            // Go Blend.\r\n            engine.setAlphaMode(this._effectLayerOptions.alphaBlendingMode);\r\n\r\n            // Blends the map on the main canvas.\r\n            this._internalRender(currentEffect.effect!, i);\r\n        }\r\n\r\n        // Restore Alpha\r\n        engine.setAlphaMode(previousAlphaMode);\r\n\r\n        this.onAfterComposeObservable.notifyObservers(this);\r\n\r\n        // Handle size changes.\r\n        const size = this._mainTexture.getSize();\r\n        this._setMainTextureSize();\r\n        if (\r\n            (size.width !== this._mainTextureDesiredSize.width || size.height !== this._mainTextureDesiredSize.height) &&\r\n            this._mainTextureDesiredSize.width !== 0 &&\r\n            this._mainTextureDesiredSize.height !== 0\r\n        ) {\r\n            // Recreate RTT and post processes on size change.\r\n            this.onSizeChangedObservable.notifyObservers(this);\r\n            this._disposeTextureAndPostProcesses();\r\n            this._createMainTexture();\r\n            this._createTextureAndPostProcesses();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Determine if a given mesh will be used in the current effect.\r\n     * @param mesh mesh to test\r\n     * @returns true if the mesh will be used\r\n     */\r\n    public hasMesh(mesh: AbstractMesh): boolean {\r\n        if (this.renderingGroupId === -1 || mesh.renderingGroupId === this.renderingGroupId) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Returns true if the layer contains information to display, otherwise false.\r\n     * @returns true if the glow layer should be rendered\r\n     */\r\n    public shouldRender(): boolean {\r\n        return this.isEnabled && this._shouldRender;\r\n    }\r\n\r\n    /**\r\n     * Returns true if the mesh should render, otherwise false.\r\n     * @param mesh The mesh to render\r\n     * @returns true if it should render otherwise false\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    protected _shouldRenderMesh(mesh: AbstractMesh): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Returns true if the mesh can be rendered, otherwise false.\r\n     * @param mesh The mesh to render\r\n     * @param material The material used on the mesh\r\n     * @returns true if it can be rendered otherwise false\r\n     */\r\n    protected _canRenderMesh(mesh: AbstractMesh, material: Material): boolean {\r\n        return !material.needAlphaBlendingForMesh(mesh);\r\n    }\r\n\r\n    /**\r\n     * Returns true if the mesh should render, otherwise false.\r\n     * @returns true if it should render otherwise false\r\n     */\r\n    protected _shouldRenderEmissiveTextureForMesh(): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Renders the submesh passed in parameter to the generation map.\r\n     * @param subMesh\r\n     * @param enableAlphaMode\r\n     */\r\n    protected _renderSubMesh(subMesh: SubMesh, enableAlphaMode: boolean = false): void {\r\n        if (!this.shouldRender()) {\r\n            return;\r\n        }\r\n\r\n        const material = subMesh.getMaterial();\r\n        const ownerMesh = subMesh.getMesh();\r\n        const replacementMesh = subMesh.getReplacementMesh();\r\n        const renderingMesh = subMesh.getRenderingMesh();\r\n        const effectiveMesh = subMesh.getEffectiveMesh();\r\n        const scene = this._scene;\r\n        const engine = scene.getEngine();\r\n\r\n        effectiveMesh._internalAbstractMeshDataInfo._isActiveIntermediate = false;\r\n\r\n        if (!material) {\r\n            return;\r\n        }\r\n\r\n        // Do not block in blend mode.\r\n        if (!this._canRenderMesh(renderingMesh, material)) {\r\n            return;\r\n        }\r\n\r\n        // Culling\r\n        let sideOrientation = renderingMesh.overrideMaterialSideOrientation ?? material.sideOrientation;\r\n        const mainDeterminant = effectiveMesh._getWorldMatrixDeterminant();\r\n        if (mainDeterminant < 0) {\r\n            sideOrientation = sideOrientation === Material.ClockWiseSideOrientation ? Material.CounterClockWiseSideOrientation : Material.ClockWiseSideOrientation;\r\n        }\r\n\r\n        const reverse = sideOrientation === Material.ClockWiseSideOrientation;\r\n        engine.setState(material.backFaceCulling, material.zOffset, undefined, reverse, material.cullBackFaces, undefined, material.zOffsetUnits);\r\n\r\n        // Managing instances\r\n        const batch = renderingMesh._getInstancesRenderList(subMesh._id, !!replacementMesh);\r\n        if (batch.mustReturn) {\r\n            return;\r\n        }\r\n\r\n        // Early Exit per mesh\r\n        if (!this._shouldRenderMesh(renderingMesh)) {\r\n            return;\r\n        }\r\n\r\n        const hardwareInstancedRendering = batch.hardwareInstancedRendering[subMesh._id] || renderingMesh.hasThinInstances;\r\n\r\n        this._setEmissiveTextureAndColor(renderingMesh, subMesh, material);\r\n\r\n        this.onBeforeRenderMeshToEffect.notifyObservers(ownerMesh);\r\n\r\n        if (this._useMeshMaterial(renderingMesh)) {\r\n            renderingMesh.render(subMesh, enableAlphaMode, replacementMesh || undefined);\r\n        } else if (this._isReady(subMesh, hardwareInstancedRendering, this._emissiveTextureAndColor.texture)) {\r\n            const renderingMaterial = effectiveMesh._internalAbstractMeshDataInfo._materialForRenderPass?.[engine.currentRenderPassId];\r\n\r\n            let drawWrapper = subMesh._getDrawWrapper();\r\n            if (!drawWrapper && renderingMaterial) {\r\n                drawWrapper = renderingMaterial._getDrawWrapper();\r\n            }\r\n\r\n            if (!drawWrapper) {\r\n                return;\r\n            }\r\n\r\n            const effect = drawWrapper.effect!;\r\n\r\n            engine.enableEffect(drawWrapper);\r\n            if (!hardwareInstancedRendering) {\r\n                renderingMesh._bind(subMesh, effect, material.fillMode);\r\n            }\r\n\r\n            if (!renderingMaterial) {\r\n                effect.setMatrix(\"viewProjection\", scene.getTransformMatrix());\r\n                effect.setMatrix(\"world\", effectiveMesh.getWorldMatrix());\r\n                effect.setFloat4(\r\n                    \"glowColor\",\r\n                    this._emissiveTextureAndColor.color.r,\r\n                    this._emissiveTextureAndColor.color.g,\r\n                    this._emissiveTextureAndColor.color.b,\r\n                    this._emissiveTextureAndColor.color.a\r\n                );\r\n            } else {\r\n                renderingMaterial.bindForSubMesh(effectiveMesh.getWorldMatrix(), effectiveMesh as Mesh, subMesh);\r\n            }\r\n\r\n            if (!renderingMaterial) {\r\n                const needAlphaTest = material.needAlphaTesting();\r\n\r\n                const diffuseTexture = material.getAlphaTestTexture();\r\n                const needAlphaBlendFromDiffuse =\r\n                    diffuseTexture && diffuseTexture.hasAlpha && ((material as any).useAlphaFromDiffuseTexture || (material as any)._useAlphaFromAlbedoTexture);\r\n\r\n                if (diffuseTexture && (needAlphaTest || needAlphaBlendFromDiffuse)) {\r\n                    effect.setTexture(\"diffuseSampler\", diffuseTexture);\r\n                    const textureMatrix = diffuseTexture.getTextureMatrix();\r\n\r\n                    if (textureMatrix) {\r\n                        effect.setMatrix(\"diffuseMatrix\", textureMatrix);\r\n                    }\r\n                }\r\n\r\n                const opacityTexture = (material as any).opacityTexture;\r\n                if (opacityTexture) {\r\n                    effect.setTexture(\"opacitySampler\", opacityTexture);\r\n                    effect.setFloat(\"opacityIntensity\", opacityTexture.level);\r\n                    const textureMatrix = opacityTexture.getTextureMatrix();\r\n                    if (textureMatrix) {\r\n                        effect.setMatrix(\"opacityMatrix\", textureMatrix);\r\n                    }\r\n                }\r\n\r\n                // Glow emissive only\r\n                if (this._emissiveTextureAndColor.texture) {\r\n                    effect.setTexture(\"emissiveSampler\", this._emissiveTextureAndColor.texture);\r\n                    effect.setMatrix(\"emissiveMatrix\", this._emissiveTextureAndColor.texture.getTextureMatrix());\r\n                }\r\n\r\n                // Bones\r\n                if (renderingMesh.useBones && renderingMesh.computeBonesUsingShaders && renderingMesh.skeleton) {\r\n                    const skeleton = renderingMesh.skeleton;\r\n\r\n                    if (skeleton.isUsingTextureForMatrices) {\r\n                        const boneTexture = skeleton.getTransformMatrixTexture(renderingMesh);\r\n                        if (!boneTexture) {\r\n                            return;\r\n                        }\r\n\r\n                        effect.setTexture(\"boneSampler\", boneTexture);\r\n                        effect.setFloat(\"boneTextureWidth\", 4.0 * (skeleton.bones.length + 1));\r\n                    } else {\r\n                        effect.setMatrices(\"mBones\", skeleton.getTransformMatrices(renderingMesh));\r\n                    }\r\n                }\r\n\r\n                // Morph targets\r\n                MaterialHelper.BindMorphTargetParameters(renderingMesh, effect);\r\n                if (renderingMesh.morphTargetManager && renderingMesh.morphTargetManager.isUsingTextureForTargets) {\r\n                    renderingMesh.morphTargetManager._bind(effect);\r\n                }\r\n\r\n                // Alpha mode\r\n                if (enableAlphaMode) {\r\n                    engine.setAlphaMode(material.alphaMode);\r\n                }\r\n\r\n                // Intensity of effect\r\n                effect.setFloat(\"glowIntensity\", this.getEffectIntensity(renderingMesh));\r\n\r\n                // Clip planes\r\n                bindClipPlane(effect, material, scene);\r\n            }\r\n\r\n            // Draw\r\n            renderingMesh._processRendering(effectiveMesh, subMesh, effect, material.fillMode, batch, hardwareInstancedRendering, (isInstance, world) =>\r\n                effect.setMatrix(\"world\", world)\r\n            );\r\n        } else {\r\n            // Need to reset refresh rate of the main map\r\n            this._mainTexture.resetRefreshCounter();\r\n        }\r\n\r\n        this.onAfterRenderMeshToEffect.notifyObservers(ownerMesh);\r\n    }\r\n\r\n    /**\r\n     * Defines whether the current material of the mesh should be use to render the effect.\r\n     * @param mesh defines the current mesh to render\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    protected _useMeshMaterial(mesh: AbstractMesh): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Rebuild the required buffers.\r\n     * @internal Internal use only.\r\n     */\r\n    public _rebuild(): void {\r\n        const vb = this._vertexBuffers[VertexBuffer.PositionKind];\r\n\r\n        if (vb) {\r\n            vb._rebuild();\r\n        }\r\n\r\n        this._generateIndexBuffer();\r\n    }\r\n\r\n    /**\r\n     * Dispose only the render target textures and post process.\r\n     */\r\n    private _disposeTextureAndPostProcesses(): void {\r\n        this._mainTexture.dispose();\r\n\r\n        for (let i = 0; i < this._postProcesses.length; i++) {\r\n            if (this._postProcesses[i]) {\r\n                this._postProcesses[i].dispose();\r\n            }\r\n        }\r\n        this._postProcesses = [];\r\n\r\n        for (let i = 0; i < this._textures.length; i++) {\r\n            if (this._textures[i]) {\r\n                this._textures[i].dispose();\r\n            }\r\n        }\r\n        this._textures = [];\r\n    }\r\n\r\n    /**\r\n     * Dispose the highlight layer and free resources.\r\n     */\r\n    public dispose(): void {\r\n        const vertexBuffer = this._vertexBuffers[VertexBuffer.PositionKind];\r\n        if (vertexBuffer) {\r\n            vertexBuffer.dispose();\r\n            this._vertexBuffers[VertexBuffer.PositionKind] = null;\r\n        }\r\n\r\n        if (this._indexBuffer) {\r\n            this._scene.getEngine()._releaseBuffer(this._indexBuffer);\r\n            this._indexBuffer = null;\r\n        }\r\n\r\n        for (const drawWrapper of this._mergeDrawWrapper) {\r\n            drawWrapper.dispose();\r\n        }\r\n        this._mergeDrawWrapper = [];\r\n\r\n        // Clean textures and post processes\r\n        this._disposeTextureAndPostProcesses();\r\n\r\n        // Remove from scene\r\n        const index = this._scene.effectLayers.indexOf(this, 0);\r\n        if (index > -1) {\r\n            this._scene.effectLayers.splice(index, 1);\r\n        }\r\n\r\n        // Callback\r\n        this.onDisposeObservable.notifyObservers(this);\r\n\r\n        this.onDisposeObservable.clear();\r\n        this.onBeforeRenderMainTextureObservable.clear();\r\n        this.onBeforeComposeObservable.clear();\r\n        this.onBeforeRenderMeshToEffect.clear();\r\n        this.onAfterRenderMeshToEffect.clear();\r\n        this.onAfterComposeObservable.clear();\r\n        this.onSizeChangedObservable.clear();\r\n    }\r\n\r\n    /**\r\n     * Gets the class name of the effect layer\r\n     * @returns the string with the class name of the effect layer\r\n     */\r\n    public getClassName(): string {\r\n        return \"EffectLayer\";\r\n    }\r\n\r\n    /**\r\n     * Creates an effect layer from parsed effect layer data\r\n     * @param parsedEffectLayer defines effect layer data\r\n     * @param scene defines the current scene\r\n     * @param rootUrl defines the root URL containing the effect layer information\r\n     * @returns a parsed effect Layer\r\n     */\r\n    public static Parse(parsedEffectLayer: any, scene: Scene, rootUrl: string): EffectLayer {\r\n        const effectLayerType = Tools.Instantiate(parsedEffectLayer.customType);\r\n\r\n        return effectLayerType.Parse(parsedEffectLayer, scene, rootUrl);\r\n    }\r\n}\r\n"]}