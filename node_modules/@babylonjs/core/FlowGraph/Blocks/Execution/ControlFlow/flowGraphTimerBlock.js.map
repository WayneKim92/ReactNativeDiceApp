{"version":3,"file":"flowGraphTimerBlock.js","sourceRoot":"","sources":["../../../../../../../dev/core/src/FlowGraph/Blocks/Execution/ControlFlow/flowGraphTimerBlock.ts"],"names":[],"mappings":"AAEA,OAAO,EAAE,aAAa,EAAE,MAAM,wBAAwB,CAAC;AAEvD,OAAO,EAAE,4BAA4B,EAAE,MAAM,uCAAuC,CAAC;AACrF,OAAO,EAAE,cAAc,EAAE,MAAM,6BAA6B,CAAC;AAC7D,OAAO,EAAE,KAAK,EAAE,MAAM,wBAAwB,CAAC;AAE/C,OAAO,EAAE,aAAa,EAAE,MAAM,4BAA4B,CAAC;AAC3D;;;;GAIG;AACH,MAAM,OAAO,mBAAoB,SAAQ,4BAA4B;IAWjE,YAAY,MAAqC;QAC7C,KAAK,CAAC,MAAM,CAAC,CAAC;QAEd,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC,kBAAkB,CAAC,SAAS,EAAE,cAAc,CAAC,CAAC;QAClE,IAAI,CAAC,WAAW,GAAG,IAAI,CAAC,qBAAqB,CAAC,aAAa,CAAC,CAAC;IACjE,CAAC;IAEM,oBAAoB,CAAC,OAAyB;QACjD,MAAM,cAAc,GAAG,IAAI,CAAC,OAAO,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAC;QAEtD,IAAI,cAAc,KAAK,SAAS,IAAI,cAAc,IAAI,CAAC,EAAE;YACrD,MAAM,MAAM,GAAG,OAAO,CAAC,qBAAqB,CAAC,IAAI,EAAE,eAAe,CAAC,IAAI,EAAE,CAAC;YAC1E,MAAM,KAAK,GAAG,OAAO,CAAC,aAAa,CAAC,KAAK,CAAC;YAC1C,MAAM,KAAK,GAAkB,IAAI,aAAa,CAAC;gBAC3C,OAAO,EAAE,cAAc;gBACvB,iBAAiB,EAAE,KAAK,CAAC,wBAAwB;gBACjD,OAAO,EAAE,GAAG,EAAE,CAAC,IAAI,CAAC,QAAQ,CAAC,KAAK,EAAE,OAAO,CAAC;aAC/C,CAAC,CAAC;YACH,KAAK,CAAC,KAAK,EAAE,CAAC;YAEd,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;YACnB,OAAO,CAAC,qBAAqB,CAAC,IAAI,EAAE,eAAe,EAAE,MAAM,CAAC,CAAC;SAChE;IACL,CAAC;IAED;;OAEG;IACI,QAAQ,CAAC,OAAyB;QACrC,IAAI,CAAC,kBAAkB,CAAC,OAAO,CAAC,CAAC;QACjC,IAAI,CAAC,MAAM,CAAC,eAAe,CAAC,OAAO,CAAC,CAAC;IACzC,CAAC;IAEO,QAAQ,CAAC,KAAoB,EAAE,OAAyB;QAC5D,MAAM,MAAM,GAAG,OAAO,CAAC,qBAAqB,CAAC,IAAI,EAAE,eAAe,CAAC,IAAI,EAAE,CAAC;QAC1E,MAAM,KAAK,GAAG,MAAM,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;QACpC,IAAI,KAAK,KAAK,CAAC,CAAC,EAAE;YACd,MAAM,CAAC,MAAM,CAAC,KAAK,EAAE,CAAC,CAAC,CAAC;SAC3B;aAAM;YACH,KAAK,CAAC,IAAI,CAAC,+EAA+E,CAAC,CAAC;SAC/F;QACD,OAAO,CAAC,mBAAmB,CAAC,IAAI,CAAC,CAAC;QAClC,IAAI,CAAC,WAAW,CAAC,eAAe,CAAC,OAAO,CAAC,CAAC;IAC9C,CAAC;IAEM,mBAAmB,CAAC,OAAyB;QAChD,MAAM,MAAM,GAAG,OAAO,CAAC,qBAAqB,CAAC,IAAI,EAAE,eAAe,CAAC,IAAI,EAAE,CAAC;QAC1E,KAAK,MAAM,KAAK,IAAI,MAAM,EAAE;YACxB,KAAK,CAAC,OAAO,EAAE,CAAC;SACnB;QACD,OAAO,CAAC,wBAAwB,CAAC,IAAI,EAAE,eAAe,CAAC,CAAC;IAC5D,CAAC;IAEM,YAAY;QACf,OAAO,cAAc,CAAC;IAC1B,CAAC;CACJ;AACD,aAAa,CAAC,cAAc,EAAE,mBAAmB,CAAC,CAAC","sourcesContent":["import type { FlowGraphDataConnection } from \"../../../flowGraphDataConnection\";\r\nimport type { FlowGraphSignalConnection } from \"../../../flowGraphSignalConnection\";\r\nimport { AdvancedTimer } from \"../../../../Misc/timer\";\r\nimport type { FlowGraphContext } from \"../../../flowGraphContext\";\r\nimport { FlowGraphAsyncExecutionBlock } from \"../../../flowGraphAsyncExecutionBlock\";\r\nimport { RichTypeNumber } from \"../../../flowGraphRichTypes\";\r\nimport { Tools } from \"../../../../Misc/tools\";\r\nimport type { IFlowGraphBlockConfiguration } from \"../../../flowGraphBlock\";\r\nimport { RegisterClass } from \"../../../../Misc/typeStore\";\r\n/**\r\n * @experimental\r\n * Block that provides two different output flows. One is started immediately once the block is executed,\r\n * and the other is executed after a set time. The timer for this block runs based on the scene's render loop.\r\n */\r\nexport class FlowGraphTimerBlock extends FlowGraphAsyncExecutionBlock {\r\n    /**\r\n     * Input connection: The timeout of the timer.\r\n     */\r\n    public readonly timeout: FlowGraphDataConnection<number>;\r\n    /**\r\n     * Output connection: The signal that is activated when the timer is done.\r\n     * This signal is activated asynchronically.\r\n     */\r\n    public readonly onTimerDone: FlowGraphSignalConnection;\r\n\r\n    constructor(config?: IFlowGraphBlockConfiguration) {\r\n        super(config);\r\n\r\n        this.timeout = this._registerDataInput(\"timeout\", RichTypeNumber);\r\n        this.onTimerDone = this._registerSignalOutput(\"onTimerDone\");\r\n    }\r\n\r\n    public _preparePendingTasks(context: FlowGraphContext): void {\r\n        const currentTimeout = this.timeout.getValue(context);\r\n\r\n        if (currentTimeout !== undefined && currentTimeout >= 0) {\r\n            const timers = context._getExecutionVariable(this, \"runningTimers\") || [];\r\n            const scene = context.configuration.scene;\r\n            const timer: AdvancedTimer = new AdvancedTimer({\r\n                timeout: currentTimeout,\r\n                contextObservable: scene.onBeforeRenderObservable,\r\n                onEnded: () => this._onEnded(timer, context),\r\n            });\r\n            timer.start();\r\n\r\n            timers.push(timer);\r\n            context._setExecutionVariable(this, \"runningTimers\", timers);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _execute(context: FlowGraphContext) {\r\n        this._startPendingTasks(context);\r\n        this.onDone._activateSignal(context);\r\n    }\r\n\r\n    private _onEnded(timer: AdvancedTimer, context: FlowGraphContext) {\r\n        const timers = context._getExecutionVariable(this, \"runningTimers\") || [];\r\n        const index = timers.indexOf(timer);\r\n        if (index !== -1) {\r\n            timers.splice(index, 1);\r\n        } else {\r\n            Tools.Warn(\"FlowGraphTimerBlock: Timer ended but was not found in the running timers list\");\r\n        }\r\n        context._removePendingBlock(this);\r\n        this.onTimerDone._activateSignal(context);\r\n    }\r\n\r\n    public _cancelPendingTasks(context: FlowGraphContext): void {\r\n        const timers = context._getExecutionVariable(this, \"runningTimers\") || [];\r\n        for (const timer of timers) {\r\n            timer.dispose();\r\n        }\r\n        context._deleteExecutionVariable(this, \"runningTimers\");\r\n    }\r\n\r\n    public getClassName(): string {\r\n        return \"FGTimerBlock\";\r\n    }\r\n}\r\nRegisterClass(\"FGTimerBlock\", FlowGraphTimerBlock);\r\n"]}