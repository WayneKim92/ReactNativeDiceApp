import { Matrix, Quaternion, TmpVectors, Vector3 } from "../../../../Maths/math.vector.js";
import { FlowGraphBinaryOperationBlock } from "../flowGraphBinaryOperationBlock.js";
import { RichTypeAny, RichTypeMatrix, RichTypeNumber, RichTypeQuaternion, RichTypeVector3 } from "../../../flowGraphRichTypes.js";
import { FlowGraphUnaryOperationBlock } from "../flowGraphUnaryOperationBlock.js";
import { FlowGraphBlock } from "../../../flowGraphBlock.js";
import { RegisterClass } from "../../../../Misc/typeStore.js";
const ADDNAME = "FGAddMatrixBlock";
/**
 * Adds two matrices together.
 * @experimental
 */
export class FlowGraphAddMatrixBlock extends FlowGraphBinaryOperationBlock {
    constructor(config) {
        super(RichTypeMatrix, RichTypeMatrix, RichTypeMatrix, (left, right) => left.addToRef(right, this._cachedMatrix), ADDNAME, config);
        this._cachedMatrix = Matrix.Zero();
    }
}
RegisterClass(ADDNAME, FlowGraphAddMatrixBlock);
const ADDNUMBERNAME = "FGAddMatrixAndNumberBlock";
/**
 * Adds a matrix and a number together.
 * @experimental
 */
export class FlowGraphAddMatrixAndNumberBlock extends FlowGraphBinaryOperationBlock {
    constructor(config) {
        super(RichTypeMatrix, RichTypeNumber, RichTypeMatrix, (left, right) => {
            for (let i = 0; i < left.m.length; i++) {
                this._cachedArray[i] = left.m[i] + right;
            }
            return Matrix.FromArrayToRef(this._cachedArray, 0, this._cachedMatrix);
        }, ADDNUMBERNAME, config);
        this._cachedArray = new Float32Array(16);
        this._cachedMatrix = Matrix.Zero();
    }
}
RegisterClass(ADDNUMBERNAME, FlowGraphAddMatrixAndNumberBlock);
const SUBNAME = "FGSubtractMatrixBlock";
/**
 * Subtracts two matrices.
 * @experimental
 */
export class FlowGraphSubtractMatrixBlock extends FlowGraphBinaryOperationBlock {
    constructor(config) {
        super(RichTypeMatrix, RichTypeMatrix, RichTypeMatrix, (left, right) => left.addToRef(right.scaleToRef(-1, TmpVectors.Matrix[0]), this._cachedMatrix), SUBNAME, config);
        this._cachedMatrix = Matrix.Zero();
    }
}
RegisterClass(SUBNAME, FlowGraphSubtractMatrixBlock);
const SUBNUMBERNAME = "FGSubtractMatrixAndNumberBlock";
/**
 * Subtracts a matrix and a number together.
 * @experimental
 */
export class FlowGraphSubtractMatrixAndNumberBlock extends FlowGraphBinaryOperationBlock {
    constructor(config) {
        super(RichTypeMatrix, RichTypeNumber, RichTypeMatrix, (left, right) => {
            for (let i = 0; i < left.m.length; i++) {
                this._cachedArray[i] = left.m[i] - right;
            }
            return Matrix.FromArrayToRef(this._cachedArray, 0, this._cachedMatrix);
        }, SUBNUMBERNAME, config);
        this._cachedArray = new Float32Array(16);
        this._cachedMatrix = Matrix.Zero();
    }
}
RegisterClass(SUBNUMBERNAME, FlowGraphSubtractMatrixAndNumberBlock);
const MULNAME = "FGMultiplyMatrixBlock";
/**
 * Multiplies two matrices together.
 * @experimental
 */
export class FlowGraphMultiplyMatrixBlock extends FlowGraphBinaryOperationBlock {
    constructor(config) {
        super(RichTypeMatrix, RichTypeMatrix, RichTypeMatrix, (left, right) => left.multiplyToRef(right, this._cachedMatrix), MULNAME, config);
        this._cachedMatrix = Matrix.Zero();
    }
}
RegisterClass(MULNAME, FlowGraphMultiplyMatrixBlock);
const DIVIDENAME = "FGDivideMatrixBlock";
/**
 * Divides two matrices.
 * @experimental
 */
export class FlowGraphDivideMatrixBlock extends FlowGraphBinaryOperationBlock {
    constructor(config) {
        super(RichTypeMatrix, RichTypeMatrix, RichTypeMatrix, (left, right) => left.multiplyToRef(right.invertToRef(TmpVectors.Matrix[0]), this._cachedResultMatrix), DIVIDENAME, config);
        this._cachedResultMatrix = Matrix.Zero();
    }
}
RegisterClass(DIVIDENAME, FlowGraphDivideMatrixBlock);
const DIVIDENUMBERNAME = "FGDivideMatrixAndNumberBlock";
/**
 * Divides a matrix and a number together.
 * @experimental
 */
export class FlowGraphDivideMatrixAndNumberBlock extends FlowGraphBinaryOperationBlock {
    constructor(config) {
        super(RichTypeMatrix, RichTypeNumber, RichTypeMatrix, (left, right) => {
            for (let i = 0; i < left.m.length; i++) {
                this._cachedArray[i] = left.m[i] / right;
            }
            return Matrix.FromArrayToRef(this._cachedArray, 0, this._cachedMatrix);
        }, DIVIDENUMBERNAME, config);
        this._cachedArray = new Float32Array(16);
        this._cachedMatrix = Matrix.Zero();
    }
}
RegisterClass(DIVIDENUMBERNAME, FlowGraphDivideMatrixAndNumberBlock);
const SCALENAME = "FGScaleMatrixBlock";
/**
 * Scales a matrix by a number.
 * @experimental
 */
export class FlowGraphScaleMatrixBlock extends FlowGraphBinaryOperationBlock {
    constructor(config) {
        super(RichTypeMatrix, RichTypeNumber, RichTypeMatrix, (left, right) => left.scaleToRef(right, this._cachedMatrix), SCALENAME, config);
        this._cachedMatrix = Matrix.Zero();
    }
}
RegisterClass(SCALENAME, FlowGraphScaleMatrixBlock);
const CLAMPNAME = "FGClampMatrixBlock";
/**
 * Clamps each value in a matrix between a minimum and maximum value.
 * @experimental
 */
export class FlowGraphClampMatrixBlock extends FlowGraphBlock {
    constructor(config) {
        super(config);
        this._cachedArray = new Float32Array(16);
        this._cachedMatrix = Matrix.Identity();
        this.input = this._registerDataInput("input", RichTypeMatrix);
        this.min = this._registerDataInput("min", RichTypeNumber);
        this.max = this._registerDataInput("max", RichTypeNumber);
        this.output = this._registerDataOutput("output", RichTypeMatrix);
    }
    _updateOutputs(_context) {
        const input = this.input.getValue(_context);
        const min = this.min.getValue(_context);
        const max = this.max.getValue(_context);
        for (let i = 0; i < input.m.length; i++) {
            this._cachedArray[i] = Math.min(Math.max(input.m[i], min), max);
        }
        Matrix.FromArrayToRef(this._cachedArray, 0, this._cachedMatrix);
        this.output.setValue(this._cachedMatrix, _context);
    }
    getClassName() {
        return CLAMPNAME;
    }
}
RegisterClass(CLAMPNAME, FlowGraphClampMatrixBlock);
const DECOMPOSENAME = "FGDecomposeMatrixBlock";
/**
 * Decomposes a matrix into its translation, rotation and scale components.
 * @experimental
 */
export class FlowGraphDecomposeMatrixBlock extends FlowGraphBlock {
    constructor(config) {
        super(config);
        this._cachedTranslation = new Vector3();
        this._cachedRotation = new Quaternion();
        this._cachedScale = new Vector3();
        this.input = this._registerDataInput("input", RichTypeMatrix);
        this.translation = this._registerDataOutput("translation", RichTypeVector3);
        this.rotation = this._registerDataOutput("rotation", RichTypeQuaternion);
        this.scale = this._registerDataOutput("scale", RichTypeVector3);
    }
    _updateOutputs(_context) {
        const input = this.input.getValue(_context);
        input.decompose(this._cachedScale, this._cachedRotation, this._cachedTranslation);
        this.translation.setValue(this._cachedTranslation, _context);
        this.rotation.setValue(this._cachedRotation, _context);
        this.scale.setValue(this._cachedScale, _context);
    }
    getClassName() {
        return DECOMPOSENAME;
    }
}
RegisterClass(DECOMPOSENAME, FlowGraphDecomposeMatrixBlock);
const COMPOSENAME = "FGComposeMatrixBlock";
/**
 * Composes a matrix from its translation, rotation and scale components.
 * @experimental
 */
export class FlowGraphComposeMatrixBlock extends FlowGraphBlock {
    constructor(config) {
        super(config);
        this._cachedMatrix = new Matrix();
        this.output = this._registerDataOutput("input", RichTypeMatrix);
        this.translation = this._registerDataInput("translation", RichTypeVector3);
        this.rotation = this._registerDataInput("rotation", RichTypeQuaternion);
        this.scale = this._registerDataInput("scale", RichTypeVector3);
    }
    _updateOutputs(_context) {
        const translation = this.translation.getValue(_context);
        const rotation = this.rotation.getValue(_context);
        const scale = this.scale.getValue(_context);
        Matrix.ComposeToRef(scale, rotation, translation, this._cachedMatrix);
        this.output.setValue(this._cachedMatrix, _context);
    }
    getClassName() {
        return COMPOSENAME;
    }
}
RegisterClass(COMPOSENAME, FlowGraphComposeMatrixBlock);
const QUATERNIONTOROTNAME = "FGQuaternionToRotationMatrixBlock";
/**
 * Converts a quaternion to a rotation matrix.
 * @experimental
 */
export class FlowGraphQuaternionToRotationMatrixBlock extends FlowGraphUnaryOperationBlock {
    constructor(config) {
        super(RichTypeQuaternion, RichTypeMatrix, (value) => Matrix.FromQuaternionToRef(value, this._cachedMatrix), QUATERNIONTOROTNAME, config);
        this._cachedMatrix = new Matrix();
    }
}
RegisterClass(QUATERNIONTOROTNAME, FlowGraphQuaternionToRotationMatrixBlock);
const GETTRANSFORMNAME = "FGGetTransformationMatrixBlock";
/**
 * Given the Transform Nodes A and B, gives the matrix required
 * to transform coordinates from A's local space to B's local space.
 */
export class FlowGraphGetTransformationMatrixBlock extends FlowGraphBinaryOperationBlock {
    constructor(config) {
        super(RichTypeAny, RichTypeAny, RichTypeMatrix, (left, right) => {
            const aMatrix = left.getWorldMatrix();
            const bMatrix = right.getWorldMatrix();
            const inverseB = bMatrix.invertToRef(TmpVectors.Matrix[0]);
            const result = inverseB.multiplyToRef(aMatrix, this._cachedResult);
            return result;
        }, GETTRANSFORMNAME, config);
        this._cachedResult = Matrix.Zero();
    }
}
RegisterClass(GETTRANSFORMNAME, FlowGraphGetTransformationMatrixBlock);
//# sourceMappingURL=flowGraphMatrixBlocks.js.map