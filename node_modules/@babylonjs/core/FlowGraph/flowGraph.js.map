{"version":3,"file":"flowGraph.js","sourceRoot":"","sources":["../../../../dev/core/src/FlowGraph/flowGraph.ts"],"names":[],"mappings":"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","sourcesContent":["import type { Observer } from \"../Misc/observable\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { Scene } from \"../scene\";\r\nimport { FlowGraphEventBlock } from \"./flowGraphEventBlock\";\r\nimport { FlowGraphContext } from \"./flowGraphContext\";\r\nimport { FlowGraphBlock } from \"./flowGraphBlock\";\r\nimport { FlowGraphExecutionBlock } from \"./flowGraphExecutionBlock\";\r\nimport type { FlowGraphCoordinator } from \"./flowGraphCoordinator\";\r\nimport type { FlowGraphSignalConnection } from \"./flowGraphSignalConnection\";\r\nimport type { FlowGraphDataConnection } from \"./flowGraphDataConnection\";\r\n\r\nexport enum FlowGraphState {\r\n    /**\r\n     * The graph is stopped\r\n     */\r\n    Stopped,\r\n    /**\r\n     * The graph is running\r\n     */\r\n    Started,\r\n}\r\n\r\n/**\r\n * @experimental\r\n * Parameters used to create a flow graph.\r\n */\r\nexport interface FlowGraphParams {\r\n    /**\r\n     * The scene that the flow graph belongs to.\r\n     */\r\n    scene: Scene;\r\n    /**\r\n     * The event coordinator used by the flow graph.\r\n     */\r\n    coordinator: FlowGraphCoordinator;\r\n}\r\n/**\r\n * @experimental\r\n * Class used to represent a flow graph.\r\n * A flow graph is a graph of blocks that can be used to create complex logic.\r\n * Blocks can be added to the graph and connected to each other.\r\n * The graph can then be started, which will init and start all of its event blocks.\r\n */\r\nexport class FlowGraph {\r\n    /** @internal */\r\n    public _eventBlocks: FlowGraphEventBlock[] = [];\r\n    private _sceneDisposeObserver: Nullable<Observer<Scene>>;\r\n    /**\r\n     * @internal\r\n     */\r\n    public readonly _scene: Scene;\r\n    private _coordinator: FlowGraphCoordinator;\r\n    private _executionContexts: FlowGraphContext[] = [];\r\n\r\n    /**\r\n     * The state of the graph\r\n     */\r\n    state: FlowGraphState = FlowGraphState.Stopped;\r\n\r\n    /**\r\n     * Construct a Flow Graph\r\n     * @param params construction parameters. currently only the scene\r\n     */\r\n    public constructor(params: FlowGraphParams) {\r\n        this._scene = params.scene;\r\n        this._coordinator = params.coordinator;\r\n        this._sceneDisposeObserver = this._scene.onDisposeObservable.add(() => this.dispose());\r\n    }\r\n\r\n    /**\r\n     * Create a context. A context represents one self contained execution for the graph, with its own variables.\r\n     * @returns the context, where you can get and set variables\r\n     */\r\n    public createContext() {\r\n        const context = new FlowGraphContext({ scene: this._scene, coordinator: this._coordinator });\r\n        this._executionContexts.push(context);\r\n        return context;\r\n    }\r\n\r\n    /**\r\n     * Add an event block. When the graph is started, it will start listening to events\r\n     * from the block and execute the graph when they are triggered.\r\n     * @param block\r\n     */\r\n    public addEventBlock(block: FlowGraphEventBlock): void {\r\n        this._eventBlocks.push(block);\r\n    }\r\n\r\n    /**\r\n     * Starts the flow graph. Initializes the event blocks and starts listening to events.\r\n     */\r\n    public start() {\r\n        if (this.state === FlowGraphState.Started) {\r\n            return;\r\n        }\r\n        this.state = FlowGraphState.Started;\r\n        if (this._executionContexts.length === 0) {\r\n            this.createContext();\r\n        }\r\n        for (const context of this._executionContexts) {\r\n            for (const block of this._eventBlocks) {\r\n                block._startPendingTasks(context);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Disposes of the flow graph. Cancels any pending tasks and removes all event listeners.\r\n     */\r\n    public dispose() {\r\n        if (this.state === FlowGraphState.Stopped) {\r\n            return;\r\n        }\r\n        this.state = FlowGraphState.Stopped;\r\n        for (const context of this._executionContexts) {\r\n            context._clearPendingBlocks();\r\n        }\r\n        this._executionContexts.length = 0;\r\n        this._eventBlocks.length = 0;\r\n        this._scene.onDisposeObservable.remove(this._sceneDisposeObserver);\r\n        this._sceneDisposeObserver = null;\r\n    }\r\n\r\n    /**\r\n     * Executes a function in all blocks of a flow graph, starting with the event blocks.\r\n     * @param visitor the function to execute.\r\n     */\r\n    public visitAllBlocks(visitor: (block: FlowGraphBlock) => void) {\r\n        const visitList: FlowGraphBlock[] = [];\r\n        const idsAddedToVisitList = new Set<string>();\r\n        for (const block of this._eventBlocks) {\r\n            visitList.push(block);\r\n            idsAddedToVisitList.add(block.uniqueId);\r\n        }\r\n\r\n        while (visitList.length > 0) {\r\n            const block = visitList.pop()!;\r\n            visitor(block);\r\n\r\n            for (const dataIn of block.dataInputs) {\r\n                for (const connection of dataIn._connectedPoint) {\r\n                    if (!idsAddedToVisitList.has(connection._ownerBlock.uniqueId)) {\r\n                        visitList.push(connection._ownerBlock);\r\n                        idsAddedToVisitList.add(connection._ownerBlock.uniqueId);\r\n                    }\r\n                }\r\n            }\r\n            if (block instanceof FlowGraphExecutionBlock) {\r\n                for (const signalOut of block.signalOutputs) {\r\n                    for (const connection of signalOut._connectedPoint) {\r\n                        if (!idsAddedToVisitList.has(connection._ownerBlock.uniqueId)) {\r\n                            visitList.push(connection._ownerBlock);\r\n                            idsAddedToVisitList.add(connection._ownerBlock.uniqueId);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Serializes a graph\r\n     * @param serializationObject the object to write the values in\r\n     * @param valueSerializeFunction a function to serialize complex values\r\n     */\r\n    public serialize(serializationObject: any = {}, valueSerializeFunction?: (key: string, value: any, serializationObject: any) => void) {\r\n        serializationObject.variableDefinitions = {};\r\n        serializationObject.allBlocks = [];\r\n        this.visitAllBlocks((block) => {\r\n            const serializedBlock: any = {};\r\n            block.serialize(serializedBlock);\r\n            serializationObject.allBlocks.push(serializedBlock);\r\n        });\r\n        serializationObject.executionContexts = [];\r\n        for (const context of this._executionContexts) {\r\n            const serializedContext: any = {};\r\n            context.serialize(serializedContext, valueSerializeFunction);\r\n            serializationObject.executionContexts.push(serializedContext);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Given a list of blocks, find an output data connection that has a specific unique id\r\n     * @param blocks\r\n     * @param uniqueId\r\n     * @returns\r\n     */\r\n    public static GetDataOutConnectionByUniqueId(blocks: FlowGraphBlock[], uniqueId: string): FlowGraphDataConnection<any> {\r\n        for (const block of blocks) {\r\n            for (const dataOut of block.dataOutputs) {\r\n                if (dataOut.uniqueId === uniqueId) {\r\n                    return dataOut;\r\n                }\r\n            }\r\n        }\r\n        throw new Error(\"Could not find data out connection with unique id \" + uniqueId);\r\n    }\r\n\r\n    /**\r\n     * Given a list of blocks, find an input signal connection that has a specific unique id\r\n     * @param blocks\r\n     * @param uniqueId\r\n     * @returns\r\n     */\r\n    public static GetSignalInConnectionByUniqueId(blocks: FlowGraphBlock[], uniqueId: string): FlowGraphSignalConnection {\r\n        for (const block of blocks) {\r\n            if (block instanceof FlowGraphExecutionBlock) {\r\n                for (const signalIn of block.signalInputs) {\r\n                    if (signalIn.uniqueId === uniqueId) {\r\n                        return signalIn;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        throw new Error(\"Could not find signal in connection with unique id \" + uniqueId);\r\n    }\r\n\r\n    /**\r\n     * Parses a graph from a given serialization object\r\n     * @param serializationObject the object where the values are written\r\n     * @param coordinator the flow graph coordinator\r\n     * @param valueParseFunction a function to parse complex values in a scene\r\n     * @returns\r\n     */\r\n    public static Parse(serializationObject: any, coordinator: FlowGraphCoordinator, valueParseFunction?: (key: string, serializationObject: any, scene: Scene) => any): FlowGraph {\r\n        const graph = coordinator.createGraph();\r\n        const blocks: FlowGraphBlock[] = [];\r\n        // Parse all blocks\r\n        for (const serializedBlock of serializationObject.allBlocks) {\r\n            const block = FlowGraphBlock.Parse(serializedBlock);\r\n            blocks.push(block);\r\n            if (block instanceof FlowGraphEventBlock) {\r\n                graph.addEventBlock(block);\r\n            }\r\n        }\r\n        // After parsing all blocks, connect them\r\n        for (const block of blocks) {\r\n            for (const dataIn of block.dataInputs) {\r\n                for (const serializedConnection of dataIn.connectedPointIds) {\r\n                    const connection = FlowGraph.GetDataOutConnectionByUniqueId(blocks, serializedConnection);\r\n                    dataIn.connectTo(connection);\r\n                }\r\n            }\r\n            if (block instanceof FlowGraphExecutionBlock) {\r\n                for (const signalOut of block.signalOutputs) {\r\n                    for (const serializedConnection of signalOut.connectedPointIds) {\r\n                        const connection = FlowGraph.GetSignalInConnectionByUniqueId(blocks, serializedConnection);\r\n                        signalOut.connectTo(connection);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        for (const serializedContext of serializationObject.executionContexts) {\r\n            FlowGraphContext.Parse(serializedContext, graph, valueParseFunction);\r\n        }\r\n        return graph;\r\n    }\r\n}\r\n"]}