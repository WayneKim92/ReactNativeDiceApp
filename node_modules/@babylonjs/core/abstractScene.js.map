{"version":3,"file":"abstractScene.js","sourceRoot":"","sources":["../../../dev/core/src/abstractScene.ts"],"names":[],"mappings":"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","sourcesContent":["import type { Scene } from \"./scene\";\r\nimport type { Nullable } from \"./types\";\r\nimport type { AbstractMesh } from \"./Meshes/abstractMesh\";\r\nimport type { TransformNode } from \"./Meshes/transformNode\";\r\nimport type { Geometry } from \"./Meshes/geometry\";\r\nimport type { Skeleton } from \"./Bones/skeleton\";\r\nimport type { MorphTargetManager } from \"./Morph/morphTargetManager\";\r\nimport type { AssetContainer } from \"./assetContainer\";\r\nimport type { IParticleSystem } from \"./Particles/IParticleSystem\";\r\nimport type { AnimationGroup } from \"./Animations/animationGroup\";\r\nimport type { BaseTexture } from \"./Materials/Textures/baseTexture\";\r\nimport type { Material } from \"./Materials/material\";\r\nimport type { MultiMaterial } from \"./Materials/multiMaterial\";\r\nimport type { AbstractActionManager } from \"./Actions/abstractActionManager\";\r\nimport type { Camera } from \"./Cameras/camera\";\r\nimport type { Light } from \"./Lights/light\";\r\nimport type { Node } from \"./node\";\r\nimport type { PostProcess } from \"./PostProcesses/postProcess\";\r\nimport type { Animation } from \"./Animations/animation\";\r\n\r\n/**\r\n * Defines how the parser contract is defined.\r\n * These parsers are used to parse a list of specific assets (like particle systems, etc..)\r\n */\r\nexport type BabylonFileParser = (parsedData: any, scene: Scene, container: AssetContainer, rootUrl: string) => void;\r\n\r\n/**\r\n * Defines how the individual parser contract is defined.\r\n * These parser can parse an individual asset\r\n */\r\nexport type IndividualBabylonFileParser = (parsedData: any, scene: Scene, rootUrl: string) => any;\r\n\r\n/**\r\n * Base class of the scene acting as a container for the different elements composing a scene.\r\n * This class is dynamically extended by the different components of the scene increasing\r\n * flexibility and reducing coupling\r\n */\r\nexport abstract class AbstractScene {\r\n    /**\r\n     * Stores the list of available parsers in the application.\r\n     */\r\n    private static _BabylonFileParsers: { [key: string]: BabylonFileParser } = {};\r\n\r\n    /**\r\n     * Stores the list of available individual parsers in the application.\r\n     */\r\n    private static _IndividualBabylonFileParsers: { [key: string]: IndividualBabylonFileParser } = {};\r\n\r\n    /**\r\n     * Adds a parser in the list of available ones\r\n     * @param name Defines the name of the parser\r\n     * @param parser Defines the parser to add\r\n     */\r\n    public static AddParser(name: string, parser: BabylonFileParser): void {\r\n        this._BabylonFileParsers[name] = parser;\r\n    }\r\n\r\n    /**\r\n     * Gets a general parser from the list of available ones\r\n     * @param name Defines the name of the parser\r\n     * @returns the requested parser or null\r\n     */\r\n    public static GetParser(name: string): Nullable<BabylonFileParser> {\r\n        if (this._BabylonFileParsers[name]) {\r\n            return this._BabylonFileParsers[name];\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Adds n individual parser in the list of available ones\r\n     * @param name Defines the name of the parser\r\n     * @param parser Defines the parser to add\r\n     */\r\n    public static AddIndividualParser(name: string, parser: IndividualBabylonFileParser): void {\r\n        this._IndividualBabylonFileParsers[name] = parser;\r\n    }\r\n\r\n    /**\r\n     * Gets an individual parser from the list of available ones\r\n     * @param name Defines the name of the parser\r\n     * @returns the requested parser or null\r\n     */\r\n    public static GetIndividualParser(name: string): Nullable<IndividualBabylonFileParser> {\r\n        if (this._IndividualBabylonFileParsers[name]) {\r\n            return this._IndividualBabylonFileParsers[name];\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Parser json data and populate both a scene and its associated container object\r\n     * @param jsonData Defines the data to parse\r\n     * @param scene Defines the scene to parse the data for\r\n     * @param container Defines the container attached to the parsing sequence\r\n     * @param rootUrl Defines the root url of the data\r\n     */\r\n    public static Parse(jsonData: any, scene: Scene, container: AssetContainer, rootUrl: string): void {\r\n        for (const parserName in this._BabylonFileParsers) {\r\n            if (Object.prototype.hasOwnProperty.call(this._BabylonFileParsers, parserName)) {\r\n                this._BabylonFileParsers[parserName](jsonData, scene, container, rootUrl);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the list of root nodes (ie. nodes with no parent)\r\n     */\r\n    public rootNodes: Node[] = [];\r\n\r\n    /** All of the cameras added to this scene\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras\r\n     */\r\n    public cameras: Camera[] = [];\r\n\r\n    /**\r\n     * All of the lights added to this scene\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/lights/lights_introduction\r\n     */\r\n    public lights: Light[] = [];\r\n\r\n    /**\r\n     * All of the (abstract) meshes added to this scene\r\n     */\r\n    public meshes: AbstractMesh[] = [];\r\n\r\n    /**\r\n     * The list of skeletons added to the scene\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/bonesSkeletons\r\n     */\r\n    public skeletons: Skeleton[] = [];\r\n\r\n    /**\r\n     * All of the particle systems added to this scene\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/particles/particle_system/particle_system_intro\r\n     */\r\n    public particleSystems: IParticleSystem[] = [];\r\n\r\n    /**\r\n     * Gets a list of Animations associated with the scene\r\n     */\r\n    public animations: Animation[] = [];\r\n\r\n    /**\r\n     * All of the animation groups added to this scene\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/groupAnimations\r\n     */\r\n    public animationGroups: AnimationGroup[] = [];\r\n\r\n    /**\r\n     * All of the multi-materials added to this scene\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/multiMaterials\r\n     */\r\n    public multiMaterials: MultiMaterial[] = [];\r\n\r\n    /**\r\n     * All of the materials added to this scene\r\n     * In the context of a Scene, it is not supposed to be modified manually.\r\n     * Any addition or removal should be done using the addMaterial and removeMaterial Scene methods.\r\n     * Note also that the order of the Material within the array is not significant and might change.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/materials_introduction\r\n     */\r\n    public materials: Material[] = [];\r\n\r\n    /**\r\n     * The list of morph target managers added to the scene\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/dynamicMeshMorph\r\n     */\r\n    public morphTargetManagers: MorphTargetManager[] = [];\r\n\r\n    /**\r\n     * The list of geometries used in the scene.\r\n     */\r\n    public geometries: Geometry[] = [];\r\n\r\n    /**\r\n     * All of the transform nodes added to this scene\r\n     * In the context of a Scene, it is not supposed to be modified manually.\r\n     * Any addition or removal should be done using the addTransformNode and removeTransformNode Scene methods.\r\n     * Note also that the order of the TransformNode within the array is not significant and might change.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/transforms/parent_pivot/transform_node\r\n     */\r\n    public transformNodes: TransformNode[] = [];\r\n\r\n    /**\r\n     * ActionManagers available on the scene.\r\n     * @deprecated\r\n     */\r\n    public actionManagers: AbstractActionManager[] = [];\r\n\r\n    /**\r\n     * Textures to keep.\r\n     */\r\n    public textures: BaseTexture[] = [];\r\n\r\n    /** @internal */\r\n    protected _environmentTexture: Nullable<BaseTexture> = null;\r\n    /**\r\n     * Texture used in all pbr material as the reflection texture.\r\n     * As in the majority of the scene they are the same (exception for multi room and so on),\r\n     * this is easier to reference from here than from all the materials.\r\n     */\r\n    public get environmentTexture(): Nullable<BaseTexture> {\r\n        return this._environmentTexture;\r\n    }\r\n\r\n    public set environmentTexture(value: Nullable<BaseTexture>) {\r\n        this._environmentTexture = value;\r\n    }\r\n\r\n    /**\r\n     * The list of postprocesses added to the scene\r\n     */\r\n    public postProcesses: PostProcess[] = [];\r\n\r\n    /**\r\n     * @returns all meshes, lights, cameras, transformNodes and bones\r\n     */\r\n    public getNodes(): Array<Node> {\r\n        let nodes: Node[] = [];\r\n        nodes = nodes.concat(this.meshes);\r\n        nodes = nodes.concat(this.lights);\r\n        nodes = nodes.concat(this.cameras);\r\n        nodes = nodes.concat(this.transformNodes); // dummies\r\n        this.skeletons.forEach((skeleton) => (nodes = nodes.concat(skeleton.bones)));\r\n        return nodes;\r\n    }\r\n}\r\n"]}