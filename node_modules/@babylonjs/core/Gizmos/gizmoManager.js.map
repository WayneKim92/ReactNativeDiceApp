{"version":3,"file":"gizmoManager.js","sourceRoot":"","sources":["../../../../dev/core/src/Gizmos/gizmoManager.ts"],"names":[],"mappings":"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","sourcesContent":["import type { Observer } from \"../Misc/observable\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { PointerInfo } from \"../Events/pointerEvents\";\r\nimport { PointerEventTypes } from \"../Events/pointerEvents\";\r\nimport type { Scene, IDisposable } from \"../scene\";\r\nimport type { Node } from \"../node\";\r\nimport { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport type { Mesh } from \"../Meshes/mesh\";\r\nimport { UtilityLayerRenderer } from \"../Rendering/utilityLayerRenderer\";\r\nimport { Color3 } from \"../Maths/math.color\";\r\nimport { SixDofDragBehavior } from \"../Behaviors/Meshes/sixDofDragBehavior\";\r\nimport type { GizmoAxisCache, IGizmo } from \"./gizmo\";\r\nimport { Gizmo, GizmoCoordinatesMode } from \"./gizmo\";\r\nimport type { IRotationGizmo } from \"./rotationGizmo\";\r\nimport { RotationGizmo } from \"./rotationGizmo\";\r\nimport type { IPositionGizmo } from \"./positionGizmo\";\r\nimport { PositionGizmo } from \"./positionGizmo\";\r\nimport type { IScaleGizmo } from \"./scaleGizmo\";\r\nimport { ScaleGizmo } from \"./scaleGizmo\";\r\nimport type { IBoundingBoxGizmo } from \"./boundingBoxGizmo\";\r\nimport { BoundingBoxGizmo } from \"./boundingBoxGizmo\";\r\n\r\n/**\r\n * Helps setup gizmo's in the scene to rotate/scale/position nodes\r\n */\r\nexport class GizmoManager implements IDisposable {\r\n    /**\r\n     * Gizmo's created by the gizmo manager, gizmo will be null until gizmo has been enabled for the first time\r\n     */\r\n    public gizmos: {\r\n        positionGizmo: Nullable<IPositionGizmo>;\r\n        rotationGizmo: Nullable<IRotationGizmo>;\r\n        scaleGizmo: Nullable<IScaleGizmo>;\r\n        boundingBoxGizmo: Nullable<IBoundingBoxGizmo>;\r\n    };\r\n\r\n    /** When true, the gizmo will be detached from the current object when a pointer down occurs with an empty picked mesh */\r\n    public clearGizmoOnEmptyPointerEvent = false;\r\n\r\n    /** When true (default), picking to attach a new mesh is enabled. This works in sync with inspector autopicking. */\r\n    public enableAutoPicking = true;\r\n\r\n    /** Fires an event when the manager is attached to a mesh */\r\n    public onAttachedToMeshObservable = new Observable<Nullable<AbstractMesh>>();\r\n\r\n    /** Fires an event when the manager is attached to a node */\r\n    public onAttachedToNodeObservable = new Observable<Nullable<Node>>();\r\n\r\n    protected _gizmosEnabled = { positionGizmo: false, rotationGizmo: false, scaleGizmo: false, boundingBoxGizmo: false };\r\n    protected _pointerObservers: Observer<PointerInfo>[] = [];\r\n    protected _attachedMesh: Nullable<AbstractMesh> = null;\r\n    protected _attachedNode: Nullable<Node> = null;\r\n    protected _boundingBoxColor = Color3.FromHexString(\"#0984e3\");\r\n    protected _defaultUtilityLayer: UtilityLayerRenderer;\r\n    protected _defaultKeepDepthUtilityLayer: UtilityLayerRenderer;\r\n    protected _thickness: number = 1;\r\n    protected _scaleRatio: number = 1;\r\n    protected _coordinatesMode = GizmoCoordinatesMode.Local;\r\n\r\n    /** Node Caching for quick lookup */\r\n    private _gizmoAxisCache: Map<Mesh, GizmoAxisCache> = new Map();\r\n    /**\r\n     * When bounding box gizmo is enabled, this can be used to track drag/end events\r\n     */\r\n    public boundingBoxDragBehavior = new SixDofDragBehavior();\r\n    /**\r\n     * Array of meshes which will have the gizmo attached when a pointer selected them. If null, all meshes are attachable. (Default: null)\r\n     */\r\n    public attachableMeshes: Nullable<Array<AbstractMesh>> = null;\r\n    /**\r\n     * Array of nodes which will have the gizmo attached when a pointer selected them. If null, all nodes are attachable. (Default: null)\r\n     */\r\n    public attachableNodes: Nullable<Array<Node>> = null;\r\n    /**\r\n     * If pointer events should perform attaching/detaching a gizmo, if false this can be done manually via attachToMesh/attachToNode. (Default: true)\r\n     */\r\n    public usePointerToAttachGizmos = true;\r\n\r\n    /**\r\n     * Utility layer that the bounding box gizmo belongs to\r\n     */\r\n    public get keepDepthUtilityLayer() {\r\n        return this._defaultKeepDepthUtilityLayer;\r\n    }\r\n\r\n    /**\r\n     * Utility layer that all gizmos besides bounding box belong to\r\n     */\r\n    public get utilityLayer() {\r\n        return this._defaultUtilityLayer;\r\n    }\r\n\r\n    /**\r\n     * True when the mouse pointer is hovering a gizmo mesh\r\n     */\r\n    public get isHovered() {\r\n        let hovered = false;\r\n        for (const key in this.gizmos) {\r\n            const gizmo = <Nullable<IGizmo>>(<any>this.gizmos)[key];\r\n            if (gizmo && gizmo.isHovered) {\r\n                hovered = true;\r\n                break;\r\n            }\r\n        }\r\n        return hovered;\r\n    }\r\n\r\n    /**\r\n     * Ratio for the scale of the gizmo (Default: 1)\r\n     */\r\n    public set scaleRatio(value: number) {\r\n        this._scaleRatio = value;\r\n        [this.gizmos.positionGizmo, this.gizmos.rotationGizmo, this.gizmos.scaleGizmo].forEach((gizmo) => {\r\n            if (gizmo) {\r\n                gizmo.scaleRatio = value;\r\n            }\r\n        });\r\n    }\r\n    public get scaleRatio() {\r\n        return this._scaleRatio;\r\n    }\r\n\r\n    /**\r\n     * Set the coordinate system to use. By default it's local.\r\n     * But it's possible for a user to tweak so its local for translation and world for rotation.\r\n     * In that case, setting the coordinate system will change `updateGizmoRotationToMatchAttachedMesh` and `updateGizmoPositionToMatchAttachedMesh`\r\n     */\r\n    public set coordinatesMode(coordinatesMode: GizmoCoordinatesMode) {\r\n        this._coordinatesMode = coordinatesMode;\r\n        [this.gizmos.positionGizmo, this.gizmos.rotationGizmo, this.gizmos.scaleGizmo].forEach((gizmo) => {\r\n            if (gizmo) {\r\n                gizmo.coordinatesMode = coordinatesMode;\r\n            }\r\n        });\r\n    }\r\n\r\n    public get coordinatesMode(): GizmoCoordinatesMode {\r\n        return this._coordinatesMode;\r\n    }\r\n    /**\r\n     * Instantiates a gizmo manager\r\n     * @param _scene the scene to overlay the gizmos on top of\r\n     * @param thickness display gizmo axis thickness\r\n     * @param utilityLayer the layer where gizmos are rendered\r\n     * @param keepDepthUtilityLayer the layer where occluded gizmos are rendered\r\n     */\r\n    constructor(\r\n        private _scene: Scene,\r\n        thickness: number = 1,\r\n        utilityLayer: UtilityLayerRenderer = UtilityLayerRenderer.DefaultUtilityLayer,\r\n        keepDepthUtilityLayer: UtilityLayerRenderer = UtilityLayerRenderer.DefaultKeepDepthUtilityLayer\r\n    ) {\r\n        this._defaultUtilityLayer = utilityLayer;\r\n        this._defaultKeepDepthUtilityLayer = keepDepthUtilityLayer;\r\n        this._defaultKeepDepthUtilityLayer.utilityLayerScene.autoClearDepthAndStencil = false;\r\n        this._thickness = thickness;\r\n        this.gizmos = { positionGizmo: null, rotationGizmo: null, scaleGizmo: null, boundingBoxGizmo: null };\r\n\r\n        const attachToMeshPointerObserver = this._attachToMeshPointerObserver(_scene);\r\n        const gizmoAxisPointerObserver = Gizmo.GizmoAxisPointerObserver(this._defaultUtilityLayer, this._gizmoAxisCache);\r\n        this._pointerObservers = [attachToMeshPointerObserver, gizmoAxisPointerObserver];\r\n    }\r\n\r\n    /**\r\n     * Subscribes to pointer down events, for attaching and detaching mesh\r\n     * @param scene The scene layer the observer will be added to\r\n     */\r\n    private _attachToMeshPointerObserver(scene: Scene): Observer<PointerInfo> {\r\n        // Instantiate/dispose gizmos based on pointer actions\r\n        const pointerObserver = scene.onPointerObservable.add((pointerInfo) => {\r\n            if (!this.usePointerToAttachGizmos) {\r\n                return;\r\n            }\r\n            if (pointerInfo.type == PointerEventTypes.POINTERDOWN) {\r\n                if (pointerInfo.pickInfo && pointerInfo.pickInfo.pickedMesh) {\r\n                    if (this.enableAutoPicking) {\r\n                        let node: Nullable<Node> = pointerInfo.pickInfo.pickedMesh;\r\n                        if (this.attachableMeshes == null) {\r\n                            // Attach to the most parent node\r\n                            while (node && node.parent != null) {\r\n                                node = node.parent;\r\n                            }\r\n                        } else {\r\n                            // Attach to the parent node that is an attachableMesh\r\n                            let found = false;\r\n                            this.attachableMeshes.forEach((mesh) => {\r\n                                if (node && (node == mesh || node.isDescendantOf(mesh))) {\r\n                                    node = mesh;\r\n                                    found = true;\r\n                                }\r\n                            });\r\n                            if (!found) {\r\n                                node = null;\r\n                            }\r\n                        }\r\n                        if (node instanceof AbstractMesh) {\r\n                            if (this._attachedMesh != node) {\r\n                                this.attachToMesh(node);\r\n                            }\r\n                        } else {\r\n                            if (this.clearGizmoOnEmptyPointerEvent) {\r\n                                this.attachToMesh(null);\r\n                            }\r\n                        }\r\n                    }\r\n                } else {\r\n                    if (this.clearGizmoOnEmptyPointerEvent) {\r\n                        this.attachToMesh(null);\r\n                    }\r\n                }\r\n            }\r\n        });\r\n        return pointerObserver!;\r\n    }\r\n\r\n    /**\r\n     * Attaches a set of gizmos to the specified mesh\r\n     * @param mesh The mesh the gizmo's should be attached to\r\n     */\r\n    public attachToMesh(mesh: Nullable<AbstractMesh>) {\r\n        if (this._attachedMesh) {\r\n            this._attachedMesh.removeBehavior(this.boundingBoxDragBehavior);\r\n        }\r\n        if (this._attachedNode) {\r\n            this._attachedNode.removeBehavior(this.boundingBoxDragBehavior);\r\n        }\r\n        this._attachedMesh = mesh;\r\n        this._attachedNode = null;\r\n        for (const key in this.gizmos) {\r\n            const gizmo = <Nullable<IGizmo>>(<any>this.gizmos)[key];\r\n            if (gizmo && (<any>this._gizmosEnabled)[key]) {\r\n                gizmo.attachedMesh = mesh;\r\n            }\r\n        }\r\n        if (this.boundingBoxGizmoEnabled && this._attachedMesh) {\r\n            this._attachedMesh.addBehavior(this.boundingBoxDragBehavior);\r\n        }\r\n        this.onAttachedToMeshObservable.notifyObservers(mesh);\r\n    }\r\n\r\n    /**\r\n     * Attaches a set of gizmos to the specified node\r\n     * @param node The node the gizmo's should be attached to\r\n     */\r\n    public attachToNode(node: Nullable<Node>) {\r\n        if (this._attachedMesh) {\r\n            this._attachedMesh.removeBehavior(this.boundingBoxDragBehavior);\r\n        }\r\n        if (this._attachedNode) {\r\n            this._attachedNode.removeBehavior(this.boundingBoxDragBehavior);\r\n        }\r\n        this._attachedMesh = null;\r\n        this._attachedNode = node;\r\n        for (const key in this.gizmos) {\r\n            const gizmo = <Nullable<IGizmo>>(<any>this.gizmos)[key];\r\n            if (gizmo && (<any>this._gizmosEnabled)[key]) {\r\n                gizmo.attachedNode = node;\r\n            }\r\n        }\r\n        if (this.boundingBoxGizmoEnabled && this._attachedNode) {\r\n            this._attachedNode.addBehavior(this.boundingBoxDragBehavior);\r\n        }\r\n        this.onAttachedToNodeObservable.notifyObservers(node);\r\n    }\r\n\r\n    /**\r\n     * If the position gizmo is enabled\r\n     */\r\n    public set positionGizmoEnabled(value: boolean) {\r\n        if (value) {\r\n            if (!this.gizmos.positionGizmo) {\r\n                this.gizmos.positionGizmo = new PositionGizmo(this._defaultUtilityLayer, this._thickness, this);\r\n            }\r\n            if (this._attachedNode) {\r\n                this.gizmos.positionGizmo.attachedNode = this._attachedNode;\r\n            } else {\r\n                this.gizmos.positionGizmo.attachedMesh = this._attachedMesh;\r\n            }\r\n        } else if (this.gizmos.positionGizmo) {\r\n            this.gizmos.positionGizmo.attachedNode = null;\r\n        }\r\n        this._gizmosEnabled.positionGizmo = value;\r\n    }\r\n    public get positionGizmoEnabled(): boolean {\r\n        return this._gizmosEnabled.positionGizmo;\r\n    }\r\n    /**\r\n     * If the rotation gizmo is enabled\r\n     */\r\n    public set rotationGizmoEnabled(value: boolean) {\r\n        if (value) {\r\n            if (!this.gizmos.rotationGizmo) {\r\n                this.gizmos.rotationGizmo = new RotationGizmo(this._defaultUtilityLayer, 32, false, this._thickness, this);\r\n            }\r\n            if (this._attachedNode) {\r\n                this.gizmos.rotationGizmo.attachedNode = this._attachedNode;\r\n            } else {\r\n                this.gizmos.rotationGizmo.attachedMesh = this._attachedMesh;\r\n            }\r\n        } else if (this.gizmos.rotationGizmo) {\r\n            this.gizmos.rotationGizmo.attachedNode = null;\r\n        }\r\n        this._gizmosEnabled.rotationGizmo = value;\r\n    }\r\n    public get rotationGizmoEnabled(): boolean {\r\n        return this._gizmosEnabled.rotationGizmo;\r\n    }\r\n    /**\r\n     * If the scale gizmo is enabled\r\n     */\r\n    public set scaleGizmoEnabled(value: boolean) {\r\n        if (value) {\r\n            this.gizmos.scaleGizmo = this.gizmos.scaleGizmo || new ScaleGizmo(this._defaultUtilityLayer, this._thickness, this);\r\n            if (this._attachedNode) {\r\n                this.gizmos.scaleGizmo.attachedNode = this._attachedNode;\r\n            } else {\r\n                this.gizmos.scaleGizmo.attachedMesh = this._attachedMesh;\r\n            }\r\n        } else if (this.gizmos.scaleGizmo) {\r\n            this.gizmos.scaleGizmo.attachedNode = null;\r\n        }\r\n        this._gizmosEnabled.scaleGizmo = value;\r\n    }\r\n    public get scaleGizmoEnabled(): boolean {\r\n        return this._gizmosEnabled.scaleGizmo;\r\n    }\r\n    /**\r\n     * If the boundingBox gizmo is enabled\r\n     */\r\n    public set boundingBoxGizmoEnabled(value: boolean) {\r\n        if (value) {\r\n            this.gizmos.boundingBoxGizmo = this.gizmos.boundingBoxGizmo || new BoundingBoxGizmo(this._boundingBoxColor, this._defaultKeepDepthUtilityLayer);\r\n            if (this._attachedMesh) {\r\n                this.gizmos.boundingBoxGizmo.attachedMesh = this._attachedMesh;\r\n            } else {\r\n                this.gizmos.boundingBoxGizmo.attachedNode = this._attachedNode;\r\n            }\r\n\r\n            if (this._attachedMesh) {\r\n                this._attachedMesh.removeBehavior(this.boundingBoxDragBehavior);\r\n                this._attachedMesh.addBehavior(this.boundingBoxDragBehavior);\r\n            } else if (this._attachedNode) {\r\n                this._attachedNode.removeBehavior(this.boundingBoxDragBehavior);\r\n                this._attachedNode.addBehavior(this.boundingBoxDragBehavior);\r\n            }\r\n        } else if (this.gizmos.boundingBoxGizmo) {\r\n            if (this._attachedMesh) {\r\n                this._attachedMesh.removeBehavior(this.boundingBoxDragBehavior);\r\n            } else if (this._attachedNode) {\r\n                this._attachedNode.removeBehavior(this.boundingBoxDragBehavior);\r\n            }\r\n            this.gizmos.boundingBoxGizmo.attachedNode = null;\r\n        }\r\n        this._gizmosEnabled.boundingBoxGizmo = value;\r\n    }\r\n    public get boundingBoxGizmoEnabled(): boolean {\r\n        return this._gizmosEnabled.boundingBoxGizmo;\r\n    }\r\n\r\n    /**\r\n     * Builds Gizmo Axis Cache to enable features such as hover state preservation and graying out other axis during manipulation\r\n     * @param gizmoAxisCache Gizmo axis definition used for reactive gizmo UI\r\n     */\r\n    public addToAxisCache(gizmoAxisCache: Map<Mesh, GizmoAxisCache>) {\r\n        if (gizmoAxisCache.size > 0) {\r\n            gizmoAxisCache.forEach((v, k) => {\r\n                this._gizmoAxisCache.set(k, v);\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Disposes of the gizmo manager\r\n     */\r\n    public dispose() {\r\n        this._pointerObservers.forEach((observer) => {\r\n            this._scene.onPointerObservable.remove(observer);\r\n        });\r\n        for (const key in this.gizmos) {\r\n            const gizmo = <Nullable<IGizmo>>(<any>this.gizmos)[key];\r\n            if (gizmo) {\r\n                gizmo.dispose();\r\n            }\r\n        }\r\n        if (this._defaultKeepDepthUtilityLayer !== UtilityLayerRenderer._DefaultKeepDepthUtilityLayer) {\r\n            this._defaultKeepDepthUtilityLayer?.dispose();\r\n        }\r\n        if (this._defaultUtilityLayer !== UtilityLayerRenderer._DefaultUtilityLayer) {\r\n            this._defaultUtilityLayer?.dispose();\r\n        }\r\n        this.boundingBoxDragBehavior.detach();\r\n        this.onAttachedToMeshObservable.clear();\r\n    }\r\n}\r\n"]}