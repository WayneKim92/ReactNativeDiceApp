{"version":3,"file":"effect.js","sourceRoot":"","sources":["../../../../dev/core/src/Materials/effect.ts"],"names":[],"mappings":"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","sourcesContent":["import { Observable } from \"../Misc/observable\";\r\nimport type { FloatArray, Nullable } from \"../types\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport { GetDOMTextContent, IsWindowObjectExist } from \"../Misc/domManagement\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport type { IDisposable } from \"../scene\";\r\nimport type { IPipelineContext } from \"../Engines/IPipelineContext\";\r\nimport type { DataBuffer } from \"../Buffers/dataBuffer\";\r\nimport { ShaderProcessor } from \"../Engines/Processors/shaderProcessor\";\r\nimport type { IShaderProcessor } from \"../Engines/Processors/iShaderProcessor\";\r\nimport type { ProcessingOptions, ShaderCustomProcessingFunction, ShaderProcessingContext } from \"../Engines/Processors/shaderProcessingOptions\";\r\nimport type { IMatrixLike, IVector2Like, IVector3Like, IVector4Like, IColor3Like, IColor4Like, IQuaternionLike } from \"../Maths/math.like\";\r\nimport type { ThinEngine } from \"../Engines/thinEngine\";\r\nimport type { IEffectFallbacks } from \"./iEffectFallbacks\";\r\nimport { ShaderStore as EngineShaderStore } from \"../Engines/shaderStore\";\r\nimport { ShaderLanguage } from \"./shaderLanguage\";\r\n\r\nimport type { Engine } from \"../Engines/engine\";\r\nimport type { InternalTexture } from \"../Materials/Textures/internalTexture\";\r\nimport type { ThinTexture } from \"../Materials/Textures/thinTexture\";\r\nimport type { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture\";\r\nimport type { PostProcess } from \"../PostProcesses/postProcess\";\r\n\r\n/**\r\n * Options to be used when creating an effect.\r\n */\r\nexport interface IEffectCreationOptions {\r\n    /**\r\n     * Attributes that will be used in the shader.\r\n     */\r\n    attributes: string[];\r\n    /**\r\n     * Uniform variable names that will be set in the shader.\r\n     */\r\n    uniformsNames: string[];\r\n    /**\r\n     * Uniform buffer variable names that will be set in the shader.\r\n     */\r\n    uniformBuffersNames: string[];\r\n    /**\r\n     * Sampler texture variable names that will be set in the shader.\r\n     */\r\n    samplers: string[];\r\n    /**\r\n     * Define statements that will be set in the shader.\r\n     */\r\n    defines: any;\r\n    /**\r\n     * Possible fallbacks for this effect to improve performance when needed.\r\n     */\r\n    fallbacks: Nullable<IEffectFallbacks>;\r\n    /**\r\n     * Callback that will be called when the shader is compiled.\r\n     */\r\n    onCompiled: Nullable<(effect: Effect) => void>;\r\n    /**\r\n     * Callback that will be called if an error occurs during shader compilation.\r\n     */\r\n    onError: Nullable<(effect: Effect, errors: string) => void>;\r\n    /**\r\n     * Parameters to be used with Babylons include syntax to iterate over an array (eg. \\{lights: 10\\})\r\n     */\r\n    indexParameters?: any;\r\n    /**\r\n     * Max number of lights that can be used in the shader.\r\n     */\r\n    maxSimultaneousLights?: number;\r\n    /**\r\n     * See https://developer.mozilla.org/en-US/docs/Web/API/WebGL2RenderingContext/transformFeedbackVaryings\r\n     */\r\n    transformFeedbackVaryings?: Nullable<string[]>;\r\n    /**\r\n     * If provided, will be called two times with the vertex and fragment code so that this code can be updated before it is compiled by the GPU\r\n     */\r\n    processFinalCode?: Nullable<ShaderCustomProcessingFunction>;\r\n    /**\r\n     * If provided, will be called two times with the vertex and fragment code so that this code can be updated after the #include have been processed\r\n     */\r\n    processCodeAfterIncludes?: Nullable<ShaderCustomProcessingFunction>;\r\n    /**\r\n     * Is this effect rendering to several color attachments ?\r\n     */\r\n    multiTarget?: boolean;\r\n    /**\r\n     * The language the shader is written in (default: GLSL)\r\n     */\r\n    shaderLanguage?: ShaderLanguage;\r\n}\r\n\r\n/**\r\n * Effect containing vertex and fragment shader that can be executed on an object.\r\n */\r\nexport class Effect implements IDisposable {\r\n    /**\r\n     * Gets or sets the relative url used to load shaders if using the engine in non-minified mode\r\n     */\r\n    public static get ShadersRepository(): string {\r\n        return EngineShaderStore.ShadersRepository;\r\n    }\r\n    public static set ShadersRepository(repo: string) {\r\n        EngineShaderStore.ShadersRepository = repo;\r\n    }\r\n    /**\r\n     * Enable logging of the shader code when a compilation error occurs\r\n     */\r\n    public static LogShaderCodeOnCompilationError = true;\r\n    /**\r\n     * Name of the effect.\r\n     */\r\n    public name: any = null;\r\n    /**\r\n     * String container all the define statements that should be set on the shader.\r\n     */\r\n    public defines: string = \"\";\r\n    /**\r\n     * Callback that will be called when the shader is compiled.\r\n     */\r\n    public onCompiled: Nullable<(effect: Effect) => void> = null;\r\n    /**\r\n     * Callback that will be called if an error occurs during shader compilation.\r\n     */\r\n    public onError: Nullable<(effect: Effect, errors: string) => void> = null;\r\n    /**\r\n     * Callback that will be called when effect is bound.\r\n     */\r\n    public onBind: Nullable<(effect: Effect) => void> = null;\r\n    /**\r\n     * Unique ID of the effect.\r\n     */\r\n    public uniqueId = 0;\r\n    /**\r\n     * Observable that will be called when the shader is compiled.\r\n     * It is recommended to use executeWhenCompile() or to make sure that scene.isReady() is called to get this observable raised.\r\n     */\r\n    public onCompileObservable = new Observable<Effect>();\r\n    /**\r\n     * Observable that will be called if an error occurs during shader compilation.\r\n     */\r\n    public onErrorObservable = new Observable<Effect>();\r\n\r\n    /** @internal */\r\n    public _onBindObservable: Nullable<Observable<Effect>> = null;\r\n\r\n    /**\r\n     * @internal\r\n     * Specifies if the effect was previously ready\r\n     */\r\n    public _wasPreviouslyReady = false;\r\n\r\n    /**\r\n     * @internal\r\n     * Forces the code from bindForSubMesh to be fully run the next time it is called\r\n     * It is used in frozen mode to make sure the effect is properly rebound when a new effect is created\r\n     */\r\n    public _forceRebindOnNextCall = false;\r\n\r\n    /**\r\n     * @internal\r\n     * Specifies if the effect was previously using instances\r\n     */\r\n    public _wasPreviouslyUsingInstances: Nullable<boolean> = null;\r\n\r\n    private _isDisposed = false;\r\n\r\n    /**\r\n     * Observable that will be called when effect is bound.\r\n     */\r\n    public get onBindObservable(): Observable<Effect> {\r\n        if (!this._onBindObservable) {\r\n            this._onBindObservable = new Observable<Effect>();\r\n        }\r\n\r\n        return this._onBindObservable;\r\n    }\r\n\r\n    /** @internal */\r\n    public _bonesComputationForcedToCPU = false;\r\n    /** @internal */\r\n    public _uniformBuffersNames: { [key: string]: number } = {};\r\n    /** @internal */\r\n    public _samplerList: string[];\r\n    /** @internal */\r\n    public _multiTarget: boolean = false;\r\n\r\n    private static _UniqueIdSeed = 0;\r\n    /** @internal */\r\n    public _engine: Engine;\r\n    private _uniformBuffersNamesList: string[];\r\n    private _uniformsNames: string[];\r\n    private _samplers: { [key: string]: number } = {};\r\n    private _isReady = false;\r\n    private _compilationError = \"\";\r\n    private _allFallbacksProcessed = false;\r\n    private _attributesNames: string[];\r\n    private _attributes: number[];\r\n    private _attributeLocationByName: { [name: string]: number };\r\n    private _uniforms: { [key: string]: Nullable<WebGLUniformLocation> } = {};\r\n    /**\r\n     * Key for the effect.\r\n     * @internal\r\n     */\r\n    public _key: string = \"\";\r\n    private _indexParameters: any;\r\n    private _fallbacks: Nullable<IEffectFallbacks> = null;\r\n    private _vertexSourceCodeOverride: string = \"\";\r\n    private _fragmentSourceCodeOverride: string = \"\";\r\n    private _transformFeedbackVaryings: Nullable<string[]> = null;\r\n    private _shaderLanguage: ShaderLanguage;\r\n    /**\r\n     * Compiled shader to webGL program.\r\n     * @internal\r\n     */\r\n    public _pipelineContext: Nullable<IPipelineContext> = null;\r\n    /** @internal */\r\n    public _vertexSourceCode: string = \"\";\r\n    /** @internal */\r\n    public _fragmentSourceCode: string = \"\";\r\n\r\n    /** @internal */\r\n    private _vertexSourceCodeBeforeMigration: string = \"\";\r\n    /** @internal */\r\n    private _fragmentSourceCodeBeforeMigration: string = \"\";\r\n\r\n    /** @internal */\r\n    private _rawVertexSourceCode: string = \"\";\r\n    /** @internal */\r\n    private _rawFragmentSourceCode: string = \"\";\r\n\r\n    private static _BaseCache: { [key: number]: DataBuffer } = {};\r\n    private _processingContext: Nullable<ShaderProcessingContext>;\r\n\r\n    private _processCodeAfterIncludes: ShaderCustomProcessingFunction | undefined = undefined;\r\n    private _processFinalCode: Nullable<ShaderCustomProcessingFunction> = null;\r\n\r\n    /**\r\n     * Instantiates an effect.\r\n     * An effect can be used to create/manage/execute vertex and fragment shaders.\r\n     * @param baseName Name of the effect.\r\n     * @param attributesNamesOrOptions List of attribute names that will be passed to the shader or set of all options to create the effect.\r\n     * @param uniformsNamesOrEngine List of uniform variable names that will be passed to the shader or the engine that will be used to render effect.\r\n     * @param samplers List of sampler variables that will be passed to the shader.\r\n     * @param engine Engine to be used to render the effect\r\n     * @param defines Define statements to be added to the shader.\r\n     * @param fallbacks Possible fallbacks for this effect to improve performance when needed.\r\n     * @param onCompiled Callback that will be called when the shader is compiled.\r\n     * @param onError Callback that will be called if an error occurs during shader compilation.\r\n     * @param indexParameters Parameters to be used with Babylons include syntax to iterate over an array (eg. \\{lights: 10\\})\r\n     * @param key Effect Key identifying uniquely compiled shader variants\r\n     * @param shaderLanguage the language the shader is written in (default: GLSL)\r\n     */\r\n    constructor(\r\n        baseName: any,\r\n        attributesNamesOrOptions: string[] | IEffectCreationOptions,\r\n        uniformsNamesOrEngine: string[] | ThinEngine,\r\n        samplers: Nullable<string[]> = null,\r\n        engine?: ThinEngine,\r\n        defines: Nullable<string> = null,\r\n        fallbacks: Nullable<IEffectFallbacks> = null,\r\n        onCompiled: Nullable<(effect: Effect) => void> = null,\r\n        onError: Nullable<(effect: Effect, errors: string) => void> = null,\r\n        indexParameters?: any,\r\n        key: string = \"\",\r\n        shaderLanguage = ShaderLanguage.GLSL\r\n    ) {\r\n        this.name = baseName;\r\n        this._key = key;\r\n\r\n        if ((<IEffectCreationOptions>attributesNamesOrOptions).attributes) {\r\n            const options = <IEffectCreationOptions>attributesNamesOrOptions;\r\n            this._engine = <Engine>uniformsNamesOrEngine;\r\n\r\n            this._attributesNames = options.attributes;\r\n            this._uniformsNames = options.uniformsNames.concat(options.samplers);\r\n            this._samplerList = options.samplers.slice();\r\n            this.defines = options.defines;\r\n            this.onError = options.onError;\r\n            this.onCompiled = options.onCompiled;\r\n            this._fallbacks = options.fallbacks;\r\n            this._indexParameters = options.indexParameters;\r\n            this._transformFeedbackVaryings = options.transformFeedbackVaryings || null;\r\n            this._multiTarget = !!options.multiTarget;\r\n            this._shaderLanguage = options.shaderLanguage ?? ShaderLanguage.GLSL;\r\n\r\n            if (options.uniformBuffersNames) {\r\n                this._uniformBuffersNamesList = options.uniformBuffersNames.slice();\r\n                for (let i = 0; i < options.uniformBuffersNames.length; i++) {\r\n                    this._uniformBuffersNames[options.uniformBuffersNames[i]] = i;\r\n                }\r\n            }\r\n\r\n            this._processFinalCode = options.processFinalCode ?? null;\r\n            this._processCodeAfterIncludes = options.processCodeAfterIncludes ?? undefined;\r\n        } else {\r\n            this._engine = <Engine>engine;\r\n            this.defines = defines == null ? \"\" : defines;\r\n            this._uniformsNames = (<string[]>uniformsNamesOrEngine).concat(<string[]>samplers);\r\n            this._samplerList = samplers ? <string[]>samplers.slice() : [];\r\n            this._attributesNames = <string[]>attributesNamesOrOptions;\r\n            this._uniformBuffersNamesList = [];\r\n            this._shaderLanguage = shaderLanguage;\r\n\r\n            this.onError = onError;\r\n            this.onCompiled = onCompiled;\r\n\r\n            this._indexParameters = indexParameters;\r\n            this._fallbacks = fallbacks;\r\n        }\r\n\r\n        this._attributeLocationByName = {};\r\n\r\n        this.uniqueId = Effect._UniqueIdSeed++;\r\n\r\n        this._processShaderCode();\r\n    }\r\n\r\n    /** @internal */\r\n    public _processShaderCode(shaderProcessor: Nullable<IShaderProcessor> = null, keepExistingPipelineContext = false) {\r\n        let vertexSource: any;\r\n        let fragmentSource: any;\r\n\r\n        const baseName = this.name;\r\n        const hostDocument = IsWindowObjectExist() ? this._engine.getHostDocument() : null;\r\n\r\n        if (baseName.vertexSource) {\r\n            vertexSource = \"source:\" + baseName.vertexSource;\r\n        } else if (baseName.vertexElement) {\r\n            vertexSource = hostDocument ? hostDocument.getElementById(baseName.vertexElement) : null;\r\n\r\n            if (!vertexSource) {\r\n                vertexSource = baseName.vertexElement;\r\n            }\r\n        } else {\r\n            vertexSource = baseName.vertex || baseName;\r\n        }\r\n\r\n        if (baseName.fragmentSource) {\r\n            fragmentSource = \"source:\" + baseName.fragmentSource;\r\n        } else if (baseName.fragmentElement) {\r\n            fragmentSource = hostDocument ? hostDocument.getElementById(baseName.fragmentElement) : null;\r\n\r\n            if (!fragmentSource) {\r\n                fragmentSource = baseName.fragmentElement;\r\n            }\r\n        } else {\r\n            fragmentSource = baseName.fragment || baseName;\r\n        }\r\n\r\n        this._processingContext = this._engine._getShaderProcessingContext(this._shaderLanguage);\r\n\r\n        let processorOptions: ProcessingOptions = {\r\n            defines: this.defines.split(\"\\n\"),\r\n            indexParameters: this._indexParameters,\r\n            isFragment: false,\r\n            shouldUseHighPrecisionShader: this._engine._shouldUseHighPrecisionShader,\r\n            processor: shaderProcessor ?? this._engine._getShaderProcessor(this._shaderLanguage),\r\n            supportsUniformBuffers: this._engine.supportsUniformBuffers,\r\n            shadersRepository: EngineShaderStore.GetShadersRepository(this._shaderLanguage),\r\n            includesShadersStore: EngineShaderStore.GetIncludesShadersStore(this._shaderLanguage),\r\n            version: (this._engine.version * 100).toString(),\r\n            platformName: this._engine.shaderPlatformName,\r\n            processingContext: this._processingContext,\r\n            isNDCHalfZRange: this._engine.isNDCHalfZRange,\r\n            useReverseDepthBuffer: this._engine.useReverseDepthBuffer,\r\n            processCodeAfterIncludes: this._processCodeAfterIncludes,\r\n        };\r\n\r\n        const shaderCodes: [string | undefined, string | undefined] = [undefined, undefined];\r\n        const shadersLoaded = () => {\r\n            if (shaderCodes[0] && shaderCodes[1]) {\r\n                processorOptions.isFragment = true;\r\n                const [migratedVertexCode, fragmentCode] = shaderCodes;\r\n                ShaderProcessor.Process(\r\n                    fragmentCode,\r\n                    processorOptions,\r\n                    (migratedFragmentCode, codeBeforeMigration) => {\r\n                        this._fragmentSourceCodeBeforeMigration = codeBeforeMigration;\r\n                        if (this._processFinalCode) {\r\n                            migratedFragmentCode = this._processFinalCode(\"fragment\", migratedFragmentCode);\r\n                        }\r\n                        const finalShaders = ShaderProcessor.Finalize(migratedVertexCode, migratedFragmentCode, processorOptions);\r\n                        processorOptions = null as any;\r\n                        this._useFinalCode(finalShaders.vertexCode, finalShaders.fragmentCode, baseName, keepExistingPipelineContext);\r\n                    },\r\n                    this._engine\r\n                );\r\n            }\r\n        };\r\n        this._loadShader(vertexSource, \"Vertex\", \"\", (vertexCode) => {\r\n            ShaderProcessor.Initialize(processorOptions);\r\n            ShaderProcessor.Process(\r\n                vertexCode,\r\n                processorOptions,\r\n                (migratedVertexCode, codeBeforeMigration) => {\r\n                    this._rawVertexSourceCode = vertexCode;\r\n                    this._vertexSourceCodeBeforeMigration = codeBeforeMigration;\r\n                    if (this._processFinalCode) {\r\n                        migratedVertexCode = this._processFinalCode(\"vertex\", migratedVertexCode);\r\n                    }\r\n                    shaderCodes[0] = migratedVertexCode;\r\n                    shadersLoaded();\r\n                },\r\n                this._engine\r\n            );\r\n        });\r\n        this._loadShader(fragmentSource, \"Fragment\", \"Pixel\", (fragmentCode) => {\r\n            this._rawFragmentSourceCode = fragmentCode;\r\n            shaderCodes[1] = fragmentCode;\r\n            shadersLoaded();\r\n        });\r\n    }\r\n\r\n    private _useFinalCode(migratedVertexCode: string, migratedFragmentCode: string, baseName: any, keepExistingPipelineContext = false) {\r\n        if (baseName) {\r\n            const vertex = baseName.vertexElement || baseName.vertex || baseName.spectorName || baseName;\r\n            const fragment = baseName.fragmentElement || baseName.fragment || baseName.spectorName || baseName;\r\n\r\n            this._vertexSourceCode = (this._shaderLanguage === ShaderLanguage.WGSL ? \"//\" : \"\") + \"#define SHADER_NAME vertex:\" + vertex + \"\\n\" + migratedVertexCode;\r\n            this._fragmentSourceCode = (this._shaderLanguage === ShaderLanguage.WGSL ? \"//\" : \"\") + \"#define SHADER_NAME fragment:\" + fragment + \"\\n\" + migratedFragmentCode;\r\n        } else {\r\n            this._vertexSourceCode = migratedVertexCode;\r\n            this._fragmentSourceCode = migratedFragmentCode;\r\n        }\r\n        this._prepareEffect(keepExistingPipelineContext);\r\n    }\r\n\r\n    /**\r\n     * Unique key for this effect\r\n     */\r\n    public get key(): string {\r\n        return this._key;\r\n    }\r\n\r\n    /**\r\n     * If the effect has been compiled and prepared.\r\n     * @returns if the effect is compiled and prepared.\r\n     */\r\n    public isReady(): boolean {\r\n        try {\r\n            return this._isReadyInternal();\r\n        } catch {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    private _isReadyInternal(): boolean {\r\n        if (this._isReady) {\r\n            return true;\r\n        }\r\n        if (this._pipelineContext) {\r\n            return this._pipelineContext.isReady;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * The engine the effect was initialized with.\r\n     * @returns the engine.\r\n     */\r\n    public getEngine(): Engine {\r\n        return this._engine;\r\n    }\r\n\r\n    /**\r\n     * The pipeline context for this effect\r\n     * @returns the associated pipeline context\r\n     */\r\n    public getPipelineContext(): Nullable<IPipelineContext> {\r\n        return this._pipelineContext;\r\n    }\r\n\r\n    /**\r\n     * The set of names of attribute variables for the shader.\r\n     * @returns An array of attribute names.\r\n     */\r\n    public getAttributesNames(): string[] {\r\n        return this._attributesNames;\r\n    }\r\n\r\n    /**\r\n     * Returns the attribute at the given index.\r\n     * @param index The index of the attribute.\r\n     * @returns The location of the attribute.\r\n     */\r\n    public getAttributeLocation(index: number): number {\r\n        return this._attributes[index];\r\n    }\r\n\r\n    /**\r\n     * Returns the attribute based on the name of the variable.\r\n     * @param name of the attribute to look up.\r\n     * @returns the attribute location.\r\n     */\r\n    public getAttributeLocationByName(name: string): number {\r\n        return this._attributeLocationByName[name];\r\n    }\r\n\r\n    /**\r\n     * The number of attributes.\r\n     * @returns the number of attributes.\r\n     */\r\n    public getAttributesCount(): number {\r\n        return this._attributes.length;\r\n    }\r\n\r\n    /**\r\n     * Gets the index of a uniform variable.\r\n     * @param uniformName of the uniform to look up.\r\n     * @returns the index.\r\n     */\r\n    public getUniformIndex(uniformName: string): number {\r\n        return this._uniformsNames.indexOf(uniformName);\r\n    }\r\n\r\n    /**\r\n     * Returns the attribute based on the name of the variable.\r\n     * @param uniformName of the uniform to look up.\r\n     * @returns the location of the uniform.\r\n     */\r\n    public getUniform(uniformName: string): Nullable<WebGLUniformLocation> {\r\n        return this._uniforms[uniformName];\r\n    }\r\n\r\n    /**\r\n     * Returns an array of sampler variable names\r\n     * @returns The array of sampler variable names.\r\n     */\r\n    public getSamplers(): string[] {\r\n        return this._samplerList;\r\n    }\r\n\r\n    /**\r\n     * Returns an array of uniform variable names\r\n     * @returns The array of uniform variable names.\r\n     */\r\n    public getUniformNames(): string[] {\r\n        return this._uniformsNames;\r\n    }\r\n\r\n    /**\r\n     * Returns an array of uniform buffer variable names\r\n     * @returns The array of uniform buffer variable names.\r\n     */\r\n    public getUniformBuffersNames(): string[] {\r\n        return this._uniformBuffersNamesList;\r\n    }\r\n\r\n    /**\r\n     * Returns the index parameters used to create the effect\r\n     * @returns The index parameters object\r\n     */\r\n    public getIndexParameters(): any {\r\n        return this._indexParameters;\r\n    }\r\n\r\n    /**\r\n     * The error from the last compilation.\r\n     * @returns the error string.\r\n     */\r\n    public getCompilationError(): string {\r\n        return this._compilationError;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating that all fallbacks were used during compilation\r\n     * @returns true if all fallbacks were used\r\n     */\r\n    public allFallbacksProcessed(): boolean {\r\n        return this._allFallbacksProcessed;\r\n    }\r\n\r\n    /**\r\n     * Adds a callback to the onCompiled observable and call the callback immediately if already ready.\r\n     * @param func The callback to be used.\r\n     */\r\n    public executeWhenCompiled(func: (effect: Effect) => void): void {\r\n        if (this.isReady()) {\r\n            func(this);\r\n            return;\r\n        }\r\n\r\n        this.onCompileObservable.add((effect) => {\r\n            func(effect);\r\n        });\r\n\r\n        if (!this._pipelineContext || this._pipelineContext.isAsync) {\r\n            setTimeout(() => {\r\n                this._checkIsReady(null);\r\n            }, 16);\r\n        }\r\n    }\r\n\r\n    private _checkIsReady(previousPipelineContext: Nullable<IPipelineContext>) {\r\n        try {\r\n            if (this._isReadyInternal()) {\r\n                return;\r\n            }\r\n        } catch (e) {\r\n            this._processCompilationErrors(e, previousPipelineContext);\r\n            return;\r\n        }\r\n\r\n        if (this._isDisposed) {\r\n            return;\r\n        }\r\n\r\n        setTimeout(() => {\r\n            this._checkIsReady(previousPipelineContext);\r\n        }, 16);\r\n    }\r\n\r\n    private _loadShader(shader: any, key: string, optionalKey: string, callback: (data: any) => void): void {\r\n        if (typeof HTMLElement !== \"undefined\") {\r\n            // DOM element ?\r\n            if (shader instanceof HTMLElement) {\r\n                const shaderCode = GetDOMTextContent(shader);\r\n                callback(shaderCode);\r\n                return;\r\n            }\r\n        }\r\n\r\n        // Direct source ?\r\n        if (shader.substr(0, 7) === \"source:\") {\r\n            callback(shader.substr(7));\r\n            return;\r\n        }\r\n\r\n        // Base64 encoded ?\r\n        if (shader.substr(0, 7) === \"base64:\") {\r\n            const shaderBinary = window.atob(shader.substr(7));\r\n            callback(shaderBinary);\r\n            return;\r\n        }\r\n\r\n        const shaderStore = EngineShaderStore.GetShadersStore(this._shaderLanguage);\r\n\r\n        // Is in local store ?\r\n        if (shaderStore[shader + key + \"Shader\"]) {\r\n            callback(shaderStore[shader + key + \"Shader\"]);\r\n            return;\r\n        }\r\n\r\n        if (optionalKey && shaderStore[shader + optionalKey + \"Shader\"]) {\r\n            callback(shaderStore[shader + optionalKey + \"Shader\"]);\r\n            return;\r\n        }\r\n\r\n        let shaderUrl;\r\n\r\n        if (shader[0] === \".\" || shader[0] === \"/\" || shader.indexOf(\"http\") > -1) {\r\n            shaderUrl = shader;\r\n        } else {\r\n            shaderUrl = EngineShaderStore.GetShadersRepository(this._shaderLanguage) + shader;\r\n        }\r\n\r\n        // Vertex shader\r\n        this._engine._loadFile(shaderUrl + \".\" + key.toLowerCase() + \".fx\", callback);\r\n    }\r\n\r\n    /**\r\n     * Gets the vertex shader source code of this effect\r\n     * This is the final source code that will be compiled, after all the processing has been done (pre-processing applied, code injection/replacement, etc)\r\n     */\r\n    public get vertexSourceCode(): string {\r\n        return this._vertexSourceCodeOverride && this._fragmentSourceCodeOverride\r\n            ? this._vertexSourceCodeOverride\r\n            : this._pipelineContext?._getVertexShaderCode() ?? this._vertexSourceCode;\r\n    }\r\n\r\n    /**\r\n     * Gets the fragment shader source code of this effect\r\n     * This is the final source code that will be compiled, after all the processing has been done (pre-processing applied, code injection/replacement, etc)\r\n     */\r\n    public get fragmentSourceCode(): string {\r\n        return this._vertexSourceCodeOverride && this._fragmentSourceCodeOverride\r\n            ? this._fragmentSourceCodeOverride\r\n            : this._pipelineContext?._getFragmentShaderCode() ?? this._fragmentSourceCode;\r\n    }\r\n\r\n    /**\r\n     * Gets the vertex shader source code before migration.\r\n     * This is the source code after the include directives have been replaced by their contents but before the code is migrated, i.e. before ShaderProcess._ProcessShaderConversion is executed.\r\n     * This method is, among other things, responsible for parsing #if/#define directives as well as converting GLES2 syntax to GLES3 (in the case of WebGL).\r\n     */\r\n    public get vertexSourceCodeBeforeMigration(): string {\r\n        return this._vertexSourceCodeBeforeMigration;\r\n    }\r\n\r\n    /**\r\n     * Gets the fragment shader source code before migration.\r\n     * This is the source code after the include directives have been replaced by their contents but before the code is migrated, i.e. before ShaderProcess._ProcessShaderConversion is executed.\r\n     * This method is, among other things, responsible for parsing #if/#define directives as well as converting GLES2 syntax to GLES3 (in the case of WebGL).\r\n     */\r\n    public get fragmentSourceCodeBeforeMigration(): string {\r\n        return this._fragmentSourceCodeBeforeMigration;\r\n    }\r\n\r\n    /**\r\n     * Gets the vertex shader source code before it has been modified by any processing\r\n     */\r\n    public get rawVertexSourceCode(): string {\r\n        return this._rawVertexSourceCode;\r\n    }\r\n\r\n    /**\r\n     * Gets the fragment shader source code before it has been modified by any processing\r\n     */\r\n    public get rawFragmentSourceCode(): string {\r\n        return this._rawFragmentSourceCode;\r\n    }\r\n\r\n    /**\r\n     * Recompiles the webGL program\r\n     * @param vertexSourceCode The source code for the vertex shader.\r\n     * @param fragmentSourceCode The source code for the fragment shader.\r\n     * @param onCompiled Callback called when completed.\r\n     * @param onError Callback called on error.\r\n     * @internal\r\n     */\r\n    public _rebuildProgram(vertexSourceCode: string, fragmentSourceCode: string, onCompiled: (pipelineContext: IPipelineContext) => void, onError: (message: string) => void) {\r\n        this._isReady = false;\r\n\r\n        this._vertexSourceCodeOverride = vertexSourceCode;\r\n        this._fragmentSourceCodeOverride = fragmentSourceCode;\r\n        this.onError = (effect, error) => {\r\n            if (onError) {\r\n                onError(error);\r\n            }\r\n        };\r\n        this.onCompiled = () => {\r\n            const scenes = this.getEngine().scenes;\r\n            if (scenes) {\r\n                for (let i = 0; i < scenes.length; i++) {\r\n                    scenes[i].markAllMaterialsAsDirty(Constants.MATERIAL_AllDirtyFlag);\r\n                }\r\n            }\r\n\r\n            this._pipelineContext!._handlesSpectorRebuildCallback(onCompiled);\r\n        };\r\n        this._fallbacks = null;\r\n        this._prepareEffect();\r\n    }\r\n\r\n    /**\r\n     * Prepares the effect\r\n     * @internal\r\n     */\r\n    public _prepareEffect(keepExistingPipelineContext = false) {\r\n        const attributesNames = this._attributesNames;\r\n        const defines = this.defines;\r\n\r\n        const previousPipelineContext = this._pipelineContext;\r\n\r\n        this._isReady = false;\r\n\r\n        try {\r\n            const engine = this._engine;\r\n\r\n            this._pipelineContext = (keepExistingPipelineContext ? previousPipelineContext : undefined) ?? engine.createPipelineContext(this._processingContext);\r\n            this._pipelineContext._name = this._key.replace(/\\r/g, \"\").replace(/\\n/g, \"|\");\r\n\r\n            const rebuildRebind = (\r\n                vertexSourceCode: string,\r\n                fragmentSourceCode: string,\r\n                onCompiled: (pipelineContext: IPipelineContext) => void,\r\n                onError: (message: string) => void\r\n            ) => this._rebuildProgram(vertexSourceCode, fragmentSourceCode, onCompiled, onError);\r\n            if (this._vertexSourceCodeOverride && this._fragmentSourceCodeOverride) {\r\n                engine._preparePipelineContext(\r\n                    this._pipelineContext,\r\n                    this._vertexSourceCodeOverride,\r\n                    this._fragmentSourceCodeOverride,\r\n                    true,\r\n                    this._rawVertexSourceCode,\r\n                    this._rawFragmentSourceCode,\r\n                    rebuildRebind,\r\n                    null,\r\n                    this._transformFeedbackVaryings,\r\n                    this._key\r\n                );\r\n            } else {\r\n                engine._preparePipelineContext(\r\n                    this._pipelineContext,\r\n                    this._vertexSourceCode,\r\n                    this._fragmentSourceCode,\r\n                    false,\r\n                    this._rawVertexSourceCode,\r\n                    this._rawFragmentSourceCode,\r\n                    rebuildRebind,\r\n                    defines,\r\n                    this._transformFeedbackVaryings,\r\n                    this._key\r\n                );\r\n            }\r\n\r\n            engine._executeWhenRenderingStateIsCompiled(this._pipelineContext, () => {\r\n                this._attributes = [];\r\n                this._pipelineContext!._fillEffectInformation(\r\n                    this,\r\n                    this._uniformBuffersNames,\r\n                    this._uniformsNames,\r\n                    this._uniforms,\r\n                    this._samplerList,\r\n                    this._samplers,\r\n                    attributesNames,\r\n                    this._attributes\r\n                );\r\n\r\n                // Caches attribute locations.\r\n                if (attributesNames) {\r\n                    for (let i = 0; i < attributesNames.length; i++) {\r\n                        const name = attributesNames[i];\r\n                        this._attributeLocationByName[name] = this._attributes[i];\r\n                    }\r\n                }\r\n\r\n                engine.bindSamplers(this);\r\n\r\n                this._compilationError = \"\";\r\n                this._isReady = true;\r\n                if (this.onCompiled) {\r\n                    this.onCompiled(this);\r\n                }\r\n                this.onCompileObservable.notifyObservers(this);\r\n                this.onCompileObservable.clear();\r\n\r\n                // Unbind mesh reference in fallbacks\r\n                if (this._fallbacks) {\r\n                    this._fallbacks.unBindMesh();\r\n                }\r\n\r\n                if (previousPipelineContext && !keepExistingPipelineContext) {\r\n                    this.getEngine()._deletePipelineContext(previousPipelineContext);\r\n                }\r\n            });\r\n\r\n            if (this._pipelineContext.isAsync) {\r\n                this._checkIsReady(previousPipelineContext);\r\n            }\r\n        } catch (e) {\r\n            this._processCompilationErrors(e, previousPipelineContext);\r\n        }\r\n    }\r\n\r\n    private _getShaderCodeAndErrorLine(code: Nullable<string>, error: Nullable<string>, isFragment: boolean): [Nullable<string>, Nullable<string>] {\r\n        const regexp = isFragment ? /FRAGMENT SHADER ERROR: 0:(\\d+?):/ : /VERTEX SHADER ERROR: 0:(\\d+?):/;\r\n\r\n        let errorLine = null;\r\n\r\n        if (error && code) {\r\n            const res = error.match(regexp);\r\n            if (res && res.length === 2) {\r\n                const lineNumber = parseInt(res[1]);\r\n                const lines = code.split(\"\\n\", -1);\r\n                if (lines.length >= lineNumber) {\r\n                    errorLine = `Offending line [${lineNumber}] in ${isFragment ? \"fragment\" : \"vertex\"} code: ${lines[lineNumber - 1]}`;\r\n                }\r\n            }\r\n        }\r\n\r\n        return [code, errorLine];\r\n    }\r\n\r\n    private _processCompilationErrors(e: any, previousPipelineContext: Nullable<IPipelineContext> = null) {\r\n        this._compilationError = e.message;\r\n        const attributesNames = this._attributesNames;\r\n        const fallbacks = this._fallbacks;\r\n\r\n        // Let's go through fallbacks then\r\n        Logger.Error(\"Unable to compile effect:\");\r\n        Logger.Error(\r\n            \"Uniforms: \" +\r\n                this._uniformsNames.map(function (uniform) {\r\n                    return \" \" + uniform;\r\n                })\r\n        );\r\n        Logger.Error(\r\n            \"Attributes: \" +\r\n                attributesNames.map(function (attribute) {\r\n                    return \" \" + attribute;\r\n                })\r\n        );\r\n        Logger.Error(\"Defines:\\n\" + this.defines);\r\n        if (Effect.LogShaderCodeOnCompilationError) {\r\n            let lineErrorVertex = null,\r\n                lineErrorFragment = null,\r\n                code = null;\r\n            if (this._pipelineContext?._getVertexShaderCode()) {\r\n                [code, lineErrorVertex] = this._getShaderCodeAndErrorLine(this._pipelineContext._getVertexShaderCode(), this._compilationError, false);\r\n                if (code) {\r\n                    Logger.Error(\"Vertex code:\");\r\n                    Logger.Error(code);\r\n                }\r\n            }\r\n            if (this._pipelineContext?._getFragmentShaderCode()) {\r\n                [code, lineErrorFragment] = this._getShaderCodeAndErrorLine(this._pipelineContext?._getFragmentShaderCode(), this._compilationError, true);\r\n                if (code) {\r\n                    Logger.Error(\"Fragment code:\");\r\n                    Logger.Error(code);\r\n                }\r\n            }\r\n            if (lineErrorVertex) {\r\n                Logger.Error(lineErrorVertex);\r\n            }\r\n            if (lineErrorFragment) {\r\n                Logger.Error(lineErrorFragment);\r\n            }\r\n        }\r\n        Logger.Error(\"Error: \" + this._compilationError);\r\n\r\n        const notifyErrors = () => {\r\n            if (this.onError) {\r\n                this.onError(this, this._compilationError);\r\n            }\r\n            this.onErrorObservable.notifyObservers(this);\r\n        };\r\n\r\n        // In case a previous compilation was successful, we need to restore the previous pipeline context\r\n        if (previousPipelineContext) {\r\n            this._pipelineContext = previousPipelineContext;\r\n            this._isReady = true;\r\n            notifyErrors();\r\n        }\r\n\r\n        // Lets try to compile fallbacks as long as we have some.\r\n        if (fallbacks) {\r\n            this._pipelineContext = null;\r\n            if (fallbacks.hasMoreFallbacks) {\r\n                this._allFallbacksProcessed = false;\r\n                Logger.Error(\"Trying next fallback.\");\r\n                this.defines = fallbacks.reduce(this.defines, this);\r\n                this._prepareEffect();\r\n            } else {\r\n                // Sorry we did everything we can\r\n                this._allFallbacksProcessed = true;\r\n                notifyErrors();\r\n                this.onErrorObservable.clear();\r\n\r\n                // Unbind mesh reference in fallbacks\r\n                if (this._fallbacks) {\r\n                    this._fallbacks.unBindMesh();\r\n                }\r\n            }\r\n        } else {\r\n            this._allFallbacksProcessed = true;\r\n\r\n            // In case of error, without any prior successful compilation, let s notify observers\r\n            if (!previousPipelineContext) {\r\n                notifyErrors();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Checks if the effect is supported. (Must be called after compilation)\r\n     */\r\n    public get isSupported(): boolean {\r\n        return this._compilationError === \"\";\r\n    }\r\n\r\n    /**\r\n     * Binds a texture to the engine to be used as output of the shader.\r\n     * @param channel Name of the output variable.\r\n     * @param texture Texture to bind.\r\n     * @internal\r\n     */\r\n    public _bindTexture(channel: string, texture: Nullable<InternalTexture>): void {\r\n        this._engine._bindTexture(this._samplers[channel], texture, channel);\r\n    }\r\n\r\n    /**\r\n     * Sets a texture on the engine to be used in the shader.\r\n     * @param channel Name of the sampler variable.\r\n     * @param texture Texture to set.\r\n     */\r\n    public setTexture(channel: string, texture: Nullable<ThinTexture>): void {\r\n        this._engine.setTexture(this._samplers[channel], this._uniforms[channel], texture, channel);\r\n    }\r\n\r\n    /**\r\n     * Sets a depth stencil texture from a render target on the engine to be used in the shader.\r\n     * @param channel Name of the sampler variable.\r\n     * @param texture Texture to set.\r\n     */\r\n    public setDepthStencilTexture(channel: string, texture: Nullable<RenderTargetTexture>): void {\r\n        this._engine.setDepthStencilTexture(this._samplers[channel], this._uniforms[channel], texture, channel);\r\n    }\r\n\r\n    /**\r\n     * Sets an array of textures on the engine to be used in the shader.\r\n     * @param channel Name of the variable.\r\n     * @param textures Textures to set.\r\n     */\r\n    public setTextureArray(channel: string, textures: ThinTexture[]): void {\r\n        const exName = channel + \"Ex\";\r\n        if (this._samplerList.indexOf(exName + \"0\") === -1) {\r\n            const initialPos = this._samplerList.indexOf(channel);\r\n            for (let index = 1; index < textures.length; index++) {\r\n                const currentExName = exName + (index - 1).toString();\r\n                this._samplerList.splice(initialPos + index, 0, currentExName);\r\n            }\r\n\r\n            // Reset every channels\r\n            let channelIndex = 0;\r\n            for (const key of this._samplerList) {\r\n                this._samplers[key] = channelIndex;\r\n                channelIndex += 1;\r\n            }\r\n        }\r\n\r\n        this._engine.setTextureArray(this._samplers[channel], this._uniforms[channel], textures, channel);\r\n    }\r\n\r\n    /**\r\n     * Sets a texture to be the input of the specified post process. (To use the output, pass in the next post process in the pipeline)\r\n     * @param channel Name of the sampler variable.\r\n     * @param postProcess Post process to get the input texture from.\r\n     */\r\n    public setTextureFromPostProcess(channel: string, postProcess: Nullable<PostProcess>): void {\r\n        this._engine.setTextureFromPostProcess(this._samplers[channel], postProcess, channel);\r\n    }\r\n\r\n    /**\r\n     * (Warning! setTextureFromPostProcessOutput may be desired instead)\r\n     * Sets the input texture of the passed in post process to be input of this effect. (To use the output of the passed in post process use setTextureFromPostProcessOutput)\r\n     * @param channel Name of the sampler variable.\r\n     * @param postProcess Post process to get the output texture from.\r\n     */\r\n    public setTextureFromPostProcessOutput(channel: string, postProcess: Nullable<PostProcess>): void {\r\n        this._engine.setTextureFromPostProcessOutput(this._samplers[channel], postProcess, channel);\r\n    }\r\n\r\n    /**\r\n     * Binds a buffer to a uniform.\r\n     * @param buffer Buffer to bind.\r\n     * @param name Name of the uniform variable to bind to.\r\n     */\r\n    public bindUniformBuffer(buffer: DataBuffer, name: string): void {\r\n        const bufferName = this._uniformBuffersNames[name];\r\n        if (bufferName === undefined || (Effect._BaseCache[bufferName] === buffer && this._engine._features.useUBOBindingCache)) {\r\n            return;\r\n        }\r\n        Effect._BaseCache[bufferName] = buffer;\r\n        this._engine.bindUniformBufferBase(buffer, bufferName, name);\r\n    }\r\n\r\n    /**\r\n     * Binds block to a uniform.\r\n     * @param blockName Name of the block to bind.\r\n     * @param index Index to bind.\r\n     */\r\n    public bindUniformBlock(blockName: string, index: number): void {\r\n        this._engine.bindUniformBlock(this._pipelineContext!, blockName, index);\r\n    }\r\n\r\n    /**\r\n     * Sets an integer value on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param value Value to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setInt(uniformName: string, value: number): Effect {\r\n        this._pipelineContext!.setInt(uniformName, value);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets an int2 value on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param x First int in int2.\r\n     * @param y Second int in int2.\r\n     * @returns this effect.\r\n     */\r\n    public setInt2(uniformName: string, x: number, y: number): Effect {\r\n        this._pipelineContext!.setInt2(uniformName, x, y);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets an int3 value on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param x First int in int3.\r\n     * @param y Second int in int3.\r\n     * @param z Third int in int3.\r\n     * @returns this effect.\r\n     */\r\n    public setInt3(uniformName: string, x: number, y: number, z: number): Effect {\r\n        this._pipelineContext!.setInt3(uniformName, x, y, z);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets an int4 value on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param x First int in int4.\r\n     * @param y Second int in int4.\r\n     * @param z Third int in int4.\r\n     * @param w Fourth int in int4.\r\n     * @returns this effect.\r\n     */\r\n    public setInt4(uniformName: string, x: number, y: number, z: number, w: number): Effect {\r\n        this._pipelineContext!.setInt4(uniformName, x, y, z, w);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets an int array on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setIntArray(uniformName: string, array: Int32Array): Effect {\r\n        this._pipelineContext!.setIntArray(uniformName, array);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets an int array 2 on a uniform variable. (Array is specified as single array eg. [1,2,3,4] will result in [[1,2],[3,4]] in the shader)\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setIntArray2(uniformName: string, array: Int32Array): Effect {\r\n        this._pipelineContext!.setIntArray2(uniformName, array);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets an int array 3 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6] will result in [[1,2,3],[4,5,6]] in the shader)\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setIntArray3(uniformName: string, array: Int32Array): Effect {\r\n        this._pipelineContext!.setIntArray3(uniformName, array);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets an int array 4 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6,7,8] will result in [[1,2,3,4],[5,6,7,8]] in the shader)\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setIntArray4(uniformName: string, array: Int32Array): Effect {\r\n        this._pipelineContext!.setIntArray4(uniformName, array);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets an unsigned integer value on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param value Value to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setUInt(uniformName: string, value: number): Effect {\r\n        this._pipelineContext!.setUInt(uniformName, value);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets an unsigned int2 value on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param x First unsigned int in uint2.\r\n     * @param y Second unsigned int in uint2.\r\n     * @returns this effect.\r\n     */\r\n    public setUInt2(uniformName: string, x: number, y: number): Effect {\r\n        this._pipelineContext!.setUInt2(uniformName, x, y);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets an unsigned int3 value on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param x First unsigned int in uint3.\r\n     * @param y Second unsigned int in uint3.\r\n     * @param z Third unsigned int in uint3.\r\n     * @returns this effect.\r\n     */\r\n    public setUInt3(uniformName: string, x: number, y: number, z: number): Effect {\r\n        this._pipelineContext!.setUInt3(uniformName, x, y, z);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets an unsigned int4 value on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param x First unsigned int in uint4.\r\n     * @param y Second unsigned int in uint4.\r\n     * @param z Third unsigned int in uint4.\r\n     * @param w Fourth unsigned int in uint4.\r\n     * @returns this effect.\r\n     */\r\n    public setUInt4(uniformName: string, x: number, y: number, z: number, w: number): Effect {\r\n        this._pipelineContext!.setUInt4(uniformName, x, y, z, w);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets an unsigned int array on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setUIntArray(uniformName: string, array: Uint32Array): Effect {\r\n        this._pipelineContext!.setUIntArray(uniformName, array);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets an unsigned int array 2 on a uniform variable. (Array is specified as single array eg. [1,2,3,4] will result in [[1,2],[3,4]] in the shader)\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setUIntArray2(uniformName: string, array: Uint32Array): Effect {\r\n        this._pipelineContext!.setUIntArray2(uniformName, array);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets an unsigned int array 3 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6] will result in [[1,2,3],[4,5,6]] in the shader)\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setUIntArray3(uniformName: string, array: Uint32Array): Effect {\r\n        this._pipelineContext!.setUIntArray3(uniformName, array);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets an unsigned int array 4 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6,7,8] will result in [[1,2,3,4],[5,6,7,8]] in the shader)\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setUIntArray4(uniformName: string, array: Uint32Array): Effect {\r\n        this._pipelineContext!.setUIntArray4(uniformName, array);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets an float array on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setFloatArray(uniformName: string, array: FloatArray): Effect {\r\n        this._pipelineContext!.setArray(uniformName, array);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets an float array 2 on a uniform variable. (Array is specified as single array eg. [1,2,3,4] will result in [[1,2],[3,4]] in the shader)\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setFloatArray2(uniformName: string, array: FloatArray): Effect {\r\n        this._pipelineContext!.setArray2(uniformName, array);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets an float array 3 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6] will result in [[1,2,3],[4,5,6]] in the shader)\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setFloatArray3(uniformName: string, array: FloatArray): Effect {\r\n        this._pipelineContext!.setArray3(uniformName, array);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets an float array 4 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6,7,8] will result in [[1,2,3,4],[5,6,7,8]] in the shader)\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setFloatArray4(uniformName: string, array: FloatArray): Effect {\r\n        this._pipelineContext!.setArray4(uniformName, array);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets an array on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setArray(uniformName: string, array: number[]): Effect {\r\n        this._pipelineContext!.setArray(uniformName, array);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets an array 2 on a uniform variable. (Array is specified as single array eg. [1,2,3,4] will result in [[1,2],[3,4]] in the shader)\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setArray2(uniformName: string, array: number[]): Effect {\r\n        this._pipelineContext!.setArray2(uniformName, array);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets an array 3 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6] will result in [[1,2,3],[4,5,6]] in the shader)\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setArray3(uniformName: string, array: number[]): Effect {\r\n        this._pipelineContext!.setArray3(uniformName, array);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets an array 4 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6,7,8] will result in [[1,2,3,4],[5,6,7,8]] in the shader)\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setArray4(uniformName: string, array: number[]): Effect {\r\n        this._pipelineContext!.setArray4(uniformName, array);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets matrices on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param matrices matrices to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setMatrices(uniformName: string, matrices: Float32Array | Array<number>): Effect {\r\n        this._pipelineContext!.setMatrices(uniformName, matrices as Float32Array);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets matrix on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param matrix matrix to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setMatrix(uniformName: string, matrix: IMatrixLike): Effect {\r\n        this._pipelineContext!.setMatrix(uniformName, matrix);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets a 3x3 matrix on a uniform variable. (Specified as [1,2,3,4,5,6,7,8,9] will result in [1,2,3][4,5,6][7,8,9] matrix)\r\n     * @param uniformName Name of the variable.\r\n     * @param matrix matrix to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setMatrix3x3(uniformName: string, matrix: Float32Array | Array<number>): Effect {\r\n        // the cast is ok because it is gl.uniformMatrix3fv() which is called at the end, and this function accepts Float32Array and Array<number>\r\n        this._pipelineContext!.setMatrix3x3(uniformName, matrix as Float32Array);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets a 2x2 matrix on a uniform variable. (Specified as [1,2,3,4] will result in [1,2][3,4] matrix)\r\n     * @param uniformName Name of the variable.\r\n     * @param matrix matrix to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setMatrix2x2(uniformName: string, matrix: Float32Array | Array<number>): Effect {\r\n        // the cast is ok because it is gl.uniformMatrix3fv() which is called at the end, and this function accepts Float32Array and Array<number>\r\n        this._pipelineContext!.setMatrix2x2(uniformName, matrix as Float32Array);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets a float on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param value value to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setFloat(uniformName: string, value: number): Effect {\r\n        this._pipelineContext!.setFloat(uniformName, value);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets a boolean on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param bool value to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setBool(uniformName: string, bool: boolean): Effect {\r\n        this._pipelineContext!.setInt(uniformName, bool ? 1 : 0);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets a Vector2 on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param vector2 vector2 to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setVector2(uniformName: string, vector2: IVector2Like): Effect {\r\n        this._pipelineContext!.setVector2(uniformName, vector2);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets a float2 on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param x First float in float2.\r\n     * @param y Second float in float2.\r\n     * @returns this effect.\r\n     */\r\n    public setFloat2(uniformName: string, x: number, y: number): Effect {\r\n        this._pipelineContext!.setFloat2(uniformName, x, y);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets a Vector3 on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param vector3 Value to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setVector3(uniformName: string, vector3: IVector3Like): Effect {\r\n        this._pipelineContext!.setVector3(uniformName, vector3);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets a float3 on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param x First float in float3.\r\n     * @param y Second float in float3.\r\n     * @param z Third float in float3.\r\n     * @returns this effect.\r\n     */\r\n    public setFloat3(uniformName: string, x: number, y: number, z: number): Effect {\r\n        this._pipelineContext!.setFloat3(uniformName, x, y, z);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets a Vector4 on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param vector4 Value to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setVector4(uniformName: string, vector4: IVector4Like): Effect {\r\n        this._pipelineContext!.setVector4(uniformName, vector4);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets a Quaternion on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param quaternion Value to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setQuaternion(uniformName: string, quaternion: IQuaternionLike): Effect {\r\n        this._pipelineContext!.setQuaternion(uniformName, quaternion);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets a float4 on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param x First float in float4.\r\n     * @param y Second float in float4.\r\n     * @param z Third float in float4.\r\n     * @param w Fourth float in float4.\r\n     * @returns this effect.\r\n     */\r\n    public setFloat4(uniformName: string, x: number, y: number, z: number, w: number): Effect {\r\n        this._pipelineContext!.setFloat4(uniformName, x, y, z, w);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets a Color3 on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param color3 Value to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setColor3(uniformName: string, color3: IColor3Like): Effect {\r\n        this._pipelineContext!.setColor3(uniformName, color3);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets a Color4 on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param color3 Value to be set.\r\n     * @param alpha Alpha value to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setColor4(uniformName: string, color3: IColor3Like, alpha: number): Effect {\r\n        this._pipelineContext!.setColor4(uniformName, color3, alpha);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets a Color4 on a uniform variable\r\n     * @param uniformName defines the name of the variable\r\n     * @param color4 defines the value to be set\r\n     * @returns this effect.\r\n     */\r\n    public setDirectColor4(uniformName: string, color4: IColor4Like): Effect {\r\n        this._pipelineContext!.setDirectColor4(uniformName, color4);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Release all associated resources.\r\n     **/\r\n    public dispose() {\r\n        if (this._pipelineContext) {\r\n            this._pipelineContext.dispose();\r\n        }\r\n        this._engine._releaseEffect(this);\r\n\r\n        this._isDisposed = true;\r\n    }\r\n\r\n    /**\r\n     * This function will add a new shader to the shader store\r\n     * @param name the name of the shader\r\n     * @param pixelShader optional pixel shader content\r\n     * @param vertexShader optional vertex shader content\r\n     * @param shaderLanguage the language the shader is written in (default: GLSL)\r\n     */\r\n    public static RegisterShader(name: string, pixelShader?: string, vertexShader?: string, shaderLanguage = ShaderLanguage.GLSL) {\r\n        if (pixelShader) {\r\n            EngineShaderStore.GetShadersStore(shaderLanguage)[`${name}PixelShader`] = pixelShader;\r\n        }\r\n\r\n        if (vertexShader) {\r\n            EngineShaderStore.GetShadersStore(shaderLanguage)[`${name}VertexShader`] = vertexShader;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Store of each shader (The can be looked up using effect.key)\r\n     */\r\n    public static ShadersStore: { [key: string]: string } = EngineShaderStore.ShadersStore;\r\n    /**\r\n     * Store of each included file for a shader (The can be looked up using effect.key)\r\n     */\r\n    public static IncludesShadersStore: { [key: string]: string } = EngineShaderStore.IncludesShadersStore;\r\n\r\n    /**\r\n     * Resets the cache of effects.\r\n     */\r\n    public static ResetCache() {\r\n        Effect._BaseCache = {};\r\n    }\r\n}\r\n"]}