{"version":3,"file":"cubeTexture.js","sourceRoot":"","sources":["../../../../../dev/core/src/Materials/Textures/cubeTexture.ts"],"names":[],"mappings":"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","sourcesContent":["import { serialize, serializeAsMatrix, SerializationHelper, serializeAsVector3 } from \"../../Misc/decorators\";\r\nimport { Tools } from \"../../Misc/tools\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { Matrix, TmpVectors, Vector3 } from \"../../Maths/math.vector\";\r\nimport { BaseTexture } from \"../../Materials/Textures/baseTexture\";\r\nimport { Texture } from \"../../Materials/Textures/texture\";\r\nimport { Constants } from \"../../Engines/constants\";\r\nimport { GetClass, RegisterClass } from \"../../Misc/typeStore\";\r\nimport type { ThinEngine } from \"../../Engines/thinEngine\";\r\n\r\nimport \"../../Engines/Extensions/engine.cubeTexture\";\r\nimport { Observable } from \"../../Misc/observable\";\r\n\r\n/**\r\n * Class for creating a cube texture\r\n */\r\nexport class CubeTexture extends BaseTexture {\r\n    private _delayedOnLoad: Nullable<() => void>;\r\n    private _delayedOnError: Nullable<(message?: string, exception?: any) => void>;\r\n    private _lodScale: number = 0.8;\r\n    private _lodOffset: number = 0;\r\n\r\n    /**\r\n     * Observable triggered once the texture has been loaded.\r\n     */\r\n    public onLoadObservable: Observable<CubeTexture> = new Observable<CubeTexture>();\r\n\r\n    /**\r\n     * The url of the texture\r\n     */\r\n    @serialize()\r\n    public url: string;\r\n\r\n    /**\r\n     * Gets or sets the center of the bounding box associated with the cube texture.\r\n     * It must define where the camera used to render the texture was set\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/reflectionTexture#using-local-cubemap-mode\r\n     */\r\n    @serializeAsVector3()\r\n    public boundingBoxPosition = Vector3.Zero();\r\n\r\n    private _boundingBoxSize: Vector3;\r\n\r\n    /**\r\n     * Gets or sets the size of the bounding box associated with the cube texture\r\n     * When defined, the cubemap will switch to local mode\r\n     * @see https://community.arm.com/graphics/b/blog/posts/reflections-based-on-local-cubemaps-in-unity\r\n     * @example https://www.babylonjs-playground.com/#RNASML\r\n     */\r\n    public set boundingBoxSize(value: Vector3) {\r\n        if (this._boundingBoxSize && this._boundingBoxSize.equals(value)) {\r\n            return;\r\n        }\r\n        this._boundingBoxSize = value;\r\n        const scene = this.getScene();\r\n        if (scene) {\r\n            scene.markAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag);\r\n        }\r\n    }\r\n    /**\r\n     * Returns the bounding box size\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/reflectionTexture#using-local-cubemap-mode\r\n     */\r\n    @serializeAsVector3()\r\n    public get boundingBoxSize(): Vector3 {\r\n        return this._boundingBoxSize;\r\n    }\r\n\r\n    protected _rotationY: number = 0;\r\n\r\n    /**\r\n     * Sets texture matrix rotation angle around Y axis in radians.\r\n     */\r\n    @serialize(\"rotationY\")\r\n    public set rotationY(value: number) {\r\n        this._rotationY = value;\r\n        this.setReflectionTextureMatrix(Matrix.RotationY(this._rotationY));\r\n    }\r\n    /**\r\n     * Gets texture matrix rotation angle around Y axis radians.\r\n     */\r\n    public get rotationY(): number {\r\n        return this._rotationY;\r\n    }\r\n\r\n    /**\r\n     * Are mip maps generated for this texture or not.\r\n     */\r\n    public get noMipmap(): boolean {\r\n        return this._noMipmap;\r\n    }\r\n\r\n    private _noMipmap: boolean;\r\n\r\n    /** @internal */\r\n    @serialize(\"files\")\r\n    public _files: Nullable<string[]> = null;\r\n\r\n    @serialize(\"forcedExtension\")\r\n    protected _forcedExtension: Nullable<string> = null;\r\n\r\n    /**\r\n     * Gets the forced extension (if any)\r\n     */\r\n    public get forcedExtension(): Nullable<string> {\r\n        return this._forcedExtension;\r\n    }\r\n\r\n    @serialize(\"extensions\")\r\n    private _extensions: Nullable<string[]> = null;\r\n\r\n    @serializeAsMatrix(\"textureMatrix\")\r\n    private _textureMatrix: Matrix;\r\n\r\n    @serializeAsMatrix(\"textureMatrixRefraction\")\r\n    private _textureMatrixRefraction: Matrix = new Matrix();\r\n\r\n    private _format: number;\r\n    private _createPolynomials: boolean;\r\n    private _loaderOptions: any;\r\n    private _useSRGBBuffer?: boolean;\r\n\r\n    /**\r\n     * Creates a cube texture from an array of image urls\r\n     * @param files defines an array of image urls\r\n     * @param scene defines the hosting scene\r\n     * @param noMipmap specifies if mip maps are not used\r\n     * @returns a cube texture\r\n     */\r\n    public static CreateFromImages(files: string[], scene: Scene, noMipmap?: boolean): CubeTexture {\r\n        let rootUrlKey = \"\";\r\n\r\n        files.forEach((url) => (rootUrlKey += url));\r\n\r\n        return new CubeTexture(rootUrlKey, scene, null, noMipmap, files);\r\n    }\r\n\r\n    /**\r\n     * Creates and return a texture created from prefilterd data by tools like IBL Baker or Lys.\r\n     * @param url defines the url of the prefiltered texture\r\n     * @param scene defines the scene the texture is attached to\r\n     * @param forcedExtension defines the extension of the file if different from the url\r\n     * @param createPolynomials defines whether or not to create polynomial harmonics from the texture data if necessary\r\n     * @returns the prefiltered texture\r\n     */\r\n    public static CreateFromPrefilteredData(url: string, scene: Scene, forcedExtension: any = null, createPolynomials: boolean = true) {\r\n        const oldValue = scene.useDelayedTextureLoading;\r\n        scene.useDelayedTextureLoading = false;\r\n\r\n        const result = new CubeTexture(url, scene, null, false, null, null, null, undefined, true, forcedExtension, createPolynomials);\r\n\r\n        scene.useDelayedTextureLoading = oldValue;\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Creates a cube texture to use with reflection for instance. It can be based upon dds or six images as well\r\n     * as prefiltered data.\r\n     * @param rootUrl defines the url of the texture or the root name of the six images\r\n     * @param sceneOrEngine defines the scene or engine the texture is attached to\r\n     * @param extensions defines the suffixes add to the picture name in case six images are in use like _px.jpg...\r\n     * @param noMipmap defines if mipmaps should be created or not\r\n     * @param files defines the six files to load for the different faces in that order: px, py, pz, nx, ny, nz\r\n     * @param onLoad defines a callback triggered at the end of the file load if no errors occurred\r\n     * @param onError defines a callback triggered in case of error during load\r\n     * @param format defines the internal format to use for the texture once loaded\r\n     * @param prefiltered defines whether or not the texture is created from prefiltered data\r\n     * @param forcedExtension defines the extensions to use (force a special type of file to load) in case it is different from the file name\r\n     * @param createPolynomials defines whether or not to create polynomial harmonics from the texture data if necessary\r\n     * @param lodScale defines the scale applied to environment texture. This manages the range of LOD level used for IBL according to the roughness\r\n     * @param lodOffset defines the offset applied to environment texture. This manages first LOD level used for IBL according to the roughness\r\n     * @param loaderOptions options to be passed to the loader\r\n     * @param useSRGBBuffer Defines if the texture must be loaded in a sRGB GPU buffer (if supported by the GPU) (default: false)\r\n     * @returns the cube texture\r\n     */\r\n    constructor(\r\n        rootUrl: string,\r\n        sceneOrEngine: Scene | ThinEngine,\r\n        extensions: Nullable<string[]> = null,\r\n        noMipmap: boolean = false,\r\n        files: Nullable<string[]> = null,\r\n        onLoad: Nullable<() => void> = null,\r\n        onError: Nullable<(message?: string, exception?: any) => void> = null,\r\n        format: number = Constants.TEXTUREFORMAT_RGBA,\r\n        prefiltered = false,\r\n        forcedExtension: any = null,\r\n        createPolynomials: boolean = false,\r\n        lodScale: number = 0.8,\r\n        lodOffset: number = 0,\r\n        loaderOptions?: any,\r\n        useSRGBBuffer?: boolean\r\n    ) {\r\n        super(sceneOrEngine);\r\n\r\n        this.name = rootUrl;\r\n        this.url = rootUrl;\r\n        this._noMipmap = noMipmap;\r\n        this.hasAlpha = false;\r\n        this._format = format;\r\n        this.isCube = true;\r\n        this._textureMatrix = Matrix.Identity();\r\n        this._createPolynomials = createPolynomials;\r\n        this.coordinatesMode = Texture.CUBIC_MODE;\r\n        this._extensions = extensions;\r\n        this._files = files;\r\n        this._forcedExtension = forcedExtension;\r\n        this._loaderOptions = loaderOptions;\r\n        this._useSRGBBuffer = useSRGBBuffer;\r\n        this._lodScale = lodScale;\r\n        this._lodOffset = lodOffset;\r\n\r\n        if (!rootUrl && !files) {\r\n            return;\r\n        }\r\n\r\n        this.updateURL(rootUrl, forcedExtension, onLoad, prefiltered, onError, extensions, this.getScene()?.useDelayedTextureLoading, files);\r\n    }\r\n\r\n    /**\r\n     * Get the current class name of the texture useful for serialization or dynamic coding.\r\n     * @returns \"CubeTexture\"\r\n     */\r\n    public getClassName(): string {\r\n        return \"CubeTexture\";\r\n    }\r\n\r\n    /**\r\n     * Update the url (and optional buffer) of this texture if url was null during construction.\r\n     * @param url the url of the texture\r\n     * @param forcedExtension defines the extension to use\r\n     * @param onLoad callback called when the texture is loaded  (defaults to null)\r\n     * @param prefiltered Defines whether the updated texture is prefiltered or not\r\n     * @param onError callback called if there was an error during the loading process (defaults to null)\r\n     * @param extensions defines the suffixes add to the picture name in case six images are in use like _px.jpg...\r\n     * @param delayLoad defines if the texture should be loaded now (false by default)\r\n     * @param files defines the six files to load for the different faces in that order: px, py, pz, nx, ny, nz\r\n     */\r\n    public updateURL(\r\n        url: string,\r\n        forcedExtension?: string,\r\n        onLoad: Nullable<() => void> = null,\r\n        prefiltered: boolean = false,\r\n        onError: Nullable<(message?: string, exception?: any) => void> = null,\r\n        extensions: Nullable<string[]> = null,\r\n        delayLoad = false,\r\n        files: Nullable<string[]> = null\r\n    ): void {\r\n        if (!this.name || this.name.startsWith(\"data:\")) {\r\n            this.name = url;\r\n        }\r\n        this.url = url;\r\n\r\n        if (forcedExtension) {\r\n            this._forcedExtension = forcedExtension;\r\n        }\r\n\r\n        const lastDot = url.lastIndexOf(\".\");\r\n        const extension = forcedExtension ? forcedExtension : lastDot > -1 ? url.substring(lastDot).toLowerCase() : \"\";\r\n        const isDDS = extension.indexOf(\".dds\") === 0;\r\n        const isEnv = extension.indexOf(\".env\") === 0;\r\n        const isBasis = extension.indexOf(\".basis\") === 0;\r\n\r\n        if (isEnv) {\r\n            this.gammaSpace = false;\r\n            this._prefiltered = false;\r\n            this.anisotropicFilteringLevel = 1;\r\n        } else {\r\n            this._prefiltered = prefiltered;\r\n\r\n            if (prefiltered) {\r\n                this.gammaSpace = false;\r\n                this.anisotropicFilteringLevel = 1;\r\n            }\r\n        }\r\n\r\n        if (files) {\r\n            this._files = files;\r\n        } else {\r\n            if (!isBasis && !isEnv && !isDDS && !extensions) {\r\n                extensions = [\"_px.jpg\", \"_py.jpg\", \"_pz.jpg\", \"_nx.jpg\", \"_ny.jpg\", \"_nz.jpg\"];\r\n            }\r\n\r\n            this._files = this._files || [];\r\n            this._files.length = 0;\r\n\r\n            if (extensions) {\r\n                for (let index = 0; index < extensions.length; index++) {\r\n                    this._files.push(url + extensions[index]);\r\n                }\r\n                this._extensions = extensions;\r\n            }\r\n        }\r\n\r\n        if (delayLoad) {\r\n            this.delayLoadState = Constants.DELAYLOADSTATE_NOTLOADED;\r\n            this._delayedOnLoad = onLoad;\r\n            this._delayedOnError = onError;\r\n        } else {\r\n            this._loadTexture(onLoad, onError);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Delays loading of the cube texture\r\n     * @param forcedExtension defines the extension to use\r\n     */\r\n    public delayLoad(forcedExtension?: string): void {\r\n        if (this.delayLoadState !== Constants.DELAYLOADSTATE_NOTLOADED) {\r\n            return;\r\n        }\r\n        if (forcedExtension) {\r\n            this._forcedExtension = forcedExtension;\r\n        }\r\n\r\n        this.delayLoadState = Constants.DELAYLOADSTATE_LOADED;\r\n        this._loadTexture(this._delayedOnLoad, this._delayedOnError);\r\n    }\r\n\r\n    /**\r\n     * Returns the reflection texture matrix\r\n     * @returns the reflection texture matrix\r\n     */\r\n    public getReflectionTextureMatrix(): Matrix {\r\n        return this._textureMatrix;\r\n    }\r\n\r\n    /**\r\n     * Sets the reflection texture matrix\r\n     * @param value Reflection texture matrix\r\n     */\r\n    public setReflectionTextureMatrix(value: Matrix): void {\r\n        if (value.updateFlag === this._textureMatrix.updateFlag) {\r\n            return;\r\n        }\r\n\r\n        if (value.isIdentity() !== this._textureMatrix.isIdentity()) {\r\n            this.getScene()?.markAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag, (mat) => mat.getActiveTextures().indexOf(this) !== -1);\r\n        }\r\n\r\n        this._textureMatrix = value;\r\n\r\n        if (!this.getScene()?.useRightHandedSystem) {\r\n            return;\r\n        }\r\n\r\n        const scale = TmpVectors.Vector3[0];\r\n        const quat = TmpVectors.Quaternion[0];\r\n        const trans = TmpVectors.Vector3[1];\r\n\r\n        this._textureMatrix.decompose(scale, quat, trans);\r\n\r\n        quat.z *= -1; // these two operations correspond to negating the x and y euler angles\r\n        quat.w *= -1;\r\n\r\n        Matrix.ComposeToRef(scale, quat, trans, this._textureMatrixRefraction);\r\n    }\r\n\r\n    /**\r\n     * Gets a suitable rotate/transform matrix when the texture is used for refraction.\r\n     * There's a separate function from getReflectionTextureMatrix because refraction requires a special configuration of the matrix in right-handed mode.\r\n     * @returns The refraction matrix\r\n     */\r\n    public getRefractionTextureMatrix(): Matrix {\r\n        return this.getScene()?.useRightHandedSystem ? this._textureMatrixRefraction : this._textureMatrix;\r\n    }\r\n\r\n    private _loadTexture(onLoad: Nullable<() => void> = null, onError: Nullable<(message?: string, exception?: any) => void> = null) {\r\n        const scene = this.getScene();\r\n        const oldTexture = this._texture;\r\n        this._texture = this._getFromCache(this.url, this._noMipmap, undefined, undefined, this._useSRGBBuffer, this.isCube);\r\n\r\n        const onLoadProcessing = () => {\r\n            this.onLoadObservable.notifyObservers(this);\r\n            if (oldTexture) {\r\n                oldTexture.dispose();\r\n                this.getScene()?.markAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag);\r\n            }\r\n            if (onLoad) {\r\n                onLoad();\r\n            }\r\n        };\r\n\r\n        const errorHandler = (message?: string, exception?: any) => {\r\n            this._loadingError = true;\r\n            this._errorObject = { message, exception };\r\n            if (onError) {\r\n                onError(message, exception);\r\n            }\r\n            Texture.OnTextureLoadErrorObservable.notifyObservers(this);\r\n        };\r\n\r\n        if (!this._texture) {\r\n            if (this._prefiltered) {\r\n                this._texture = this._getEngine()!.createPrefilteredCubeTexture(\r\n                    this.url,\r\n                    scene,\r\n                    this._lodScale,\r\n                    this._lodOffset,\r\n                    onLoad,\r\n                    errorHandler,\r\n                    this._format,\r\n                    this._forcedExtension,\r\n                    this._createPolynomials\r\n                );\r\n            } else {\r\n                this._texture = this._getEngine()!.createCubeTexture(\r\n                    this.url,\r\n                    scene,\r\n                    this._files,\r\n                    this._noMipmap,\r\n                    onLoad,\r\n                    errorHandler,\r\n                    this._format,\r\n                    this._forcedExtension,\r\n                    false,\r\n                    this._lodScale,\r\n                    this._lodOffset,\r\n                    null,\r\n                    this._loaderOptions,\r\n                    !!this._useSRGBBuffer\r\n                );\r\n            }\r\n\r\n            this._texture?.onLoadedObservable.add(() => this.onLoadObservable.notifyObservers(this));\r\n        } else {\r\n            if (this._texture.isReady) {\r\n                Tools.SetImmediate(() => onLoadProcessing());\r\n            } else {\r\n                this._texture.onLoadedObservable.add(() => onLoadProcessing());\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Parses text to create a cube texture\r\n     * @param parsedTexture define the serialized text to read from\r\n     * @param scene defines the hosting scene\r\n     * @param rootUrl defines the root url of the cube texture\r\n     * @returns a cube texture\r\n     */\r\n    public static Parse(parsedTexture: any, scene: Scene, rootUrl: string): CubeTexture {\r\n        const texture = SerializationHelper.Parse(\r\n            () => {\r\n                let prefiltered: boolean = false;\r\n                if (parsedTexture.prefiltered) {\r\n                    prefiltered = parsedTexture.prefiltered;\r\n                }\r\n                return new CubeTexture(\r\n                    rootUrl + (parsedTexture.url ?? parsedTexture.name),\r\n                    scene,\r\n                    parsedTexture.extensions,\r\n                    false,\r\n                    parsedTexture.files || null,\r\n                    null,\r\n                    null,\r\n                    undefined,\r\n                    prefiltered,\r\n                    parsedTexture.forcedExtension\r\n                );\r\n            },\r\n            parsedTexture,\r\n            scene\r\n        );\r\n\r\n        // Local Cubemaps\r\n        if (parsedTexture.boundingBoxPosition) {\r\n            texture.boundingBoxPosition = Vector3.FromArray(parsedTexture.boundingBoxPosition);\r\n        }\r\n        if (parsedTexture.boundingBoxSize) {\r\n            texture.boundingBoxSize = Vector3.FromArray(parsedTexture.boundingBoxSize);\r\n        }\r\n\r\n        // Animations\r\n        if (parsedTexture.animations) {\r\n            for (let animationIndex = 0; animationIndex < parsedTexture.animations.length; animationIndex++) {\r\n                const parsedAnimation = parsedTexture.animations[animationIndex];\r\n                const internalClass = GetClass(\"BABYLON.Animation\");\r\n                if (internalClass) {\r\n                    texture.animations.push(internalClass.Parse(parsedAnimation));\r\n                }\r\n            }\r\n        }\r\n\r\n        return texture;\r\n    }\r\n\r\n    /**\r\n     * Makes a clone, or deep copy, of the cube texture\r\n     * @returns a new cube texture\r\n     */\r\n    public clone(): CubeTexture {\r\n        let uniqueId = 0;\r\n\r\n        const newCubeTexture = SerializationHelper.Clone(() => {\r\n            const cubeTexture = new CubeTexture(this.url, this.getScene() || this._getEngine()!, this._extensions, this._noMipmap, this._files);\r\n            uniqueId = cubeTexture.uniqueId;\r\n\r\n            return cubeTexture;\r\n        }, this);\r\n\r\n        newCubeTexture.uniqueId = uniqueId;\r\n\r\n        return newCubeTexture;\r\n    }\r\n}\r\n\r\nTexture._CubeTextureParser = CubeTexture.Parse;\r\n// Some exporters relies on Tools.Instantiate\r\nRegisterClass(\"BABYLON.CubeTexture\", CubeTexture);\r\n"]}