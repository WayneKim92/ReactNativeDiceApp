{"version":3,"file":"externalTexture.js","sourceRoot":"","sources":["../../../../../dev/core/src/Materials/Textures/externalTexture.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,SAAS,EAAE,MAAM,yBAAyB,CAAC;AACpD,OAAO,EAAE,eAAe,EAAE,MAAM,mBAAmB,CAAC;AAEpD;;GAEG;AACH,MAAM,OAAO,eAAe;IACxB;;;;OAIG;IACI,MAAM,CAAC,iBAAiB,CAAC,OAA0C;QACtE,OAAQ,OAA2B,CAAC,kBAAkB,KAAK,SAAS,CAAC;IACzE,CAAC;IAID;;;OAGG;IACI,YAAY;QACf,OAAO,iBAAiB,CAAC;IAC7B,CAAC;IAED;;OAEG;IACH,IAAW,kBAAkB;QACzB,OAAO,IAAI,CAAC,MAAM,CAAC;IACvB,CAAC;IAsBD;;;OAGG;IACH,YAAY,KAAuB;QAxBnC;;WAEG;QACI,eAAU,GAAY,KAAK,CAAC;QAEnC;;WAEG;QACa,SAAI,GAAG,SAAS,CAAC,qBAAqB,CAAC;QAEvD;;WAEG;QACa,WAAM,GAAG,SAAS,CAAC,uBAAuB,CAAC;QAYvD,IAAI,CAAC,MAAM,GAAG,KAAK,CAAC;QACpB,IAAI,CAAC,QAAQ,GAAG,eAAe,CAAC,QAAQ,EAAE,CAAC;IAC/C,CAAC;IAED;;;OAGG;IACI,OAAO;QACV,OAAO,IAAI,CAAC,MAAM,CAAC,UAAU,IAAI,IAAI,CAAC,MAAM,CAAC,iBAAiB,CAAC;IACnE,CAAC;IAED;;OAEG;IACI,OAAO,KAAU,CAAC;CAC5B","sourcesContent":["import { Constants } from \"../../Engines/constants\";\r\nimport { InternalTexture } from \"./internalTexture\";\r\n\r\n/**\r\n * Class used to store an external texture (like GPUExternalTexture in WebGPU)\r\n */\r\nexport class ExternalTexture {\r\n    /**\r\n     * Checks if a texture is an external or internal texture\r\n     * @param texture the external or internal texture\r\n     * @returns true if the texture is an external texture, else false\r\n     */\r\n    public static IsExternalTexture(texture: ExternalTexture | InternalTexture): texture is ExternalTexture {\r\n        return (texture as ExternalTexture).underlyingResource !== undefined;\r\n    }\r\n\r\n    private _video: HTMLVideoElement;\r\n\r\n    /**\r\n     * Get the class name of the texture.\r\n     * @returns \"ExternalTexture\"\r\n     */\r\n    public getClassName(): string {\r\n        return \"ExternalTexture\";\r\n    }\r\n\r\n    /**\r\n     * Gets the underlying texture object\r\n     */\r\n    public get underlyingResource(): any {\r\n        return this._video;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if the texture uses mipmaps\r\n     */\r\n    public useMipMaps: boolean = false;\r\n\r\n    /**\r\n     * The type of the underlying texture is implementation dependent, so return \"UNDEFINED\" for the type\r\n     */\r\n    public readonly type = Constants.TEXTURETYPE_UNDEFINED;\r\n\r\n    /**\r\n     * The format of the underlying texture is implementation dependent, so return \"UNDEFINED\" for the format\r\n     */\r\n    public readonly format = Constants.TEXTUREFORMAT_UNDEFINED;\r\n\r\n    /**\r\n     * Gets the unique id of this texture\r\n     */\r\n    public readonly uniqueId: number;\r\n\r\n    /**\r\n     * Constructs the texture\r\n     * @param video The video the texture should be wrapped around\r\n     */\r\n    constructor(video: HTMLVideoElement) {\r\n        this._video = video;\r\n        this.uniqueId = InternalTexture._Counter++;\r\n    }\r\n\r\n    /**\r\n     * Get if the texture is ready to be used (downloaded, converted, mip mapped...).\r\n     * @returns true if fully ready\r\n     */\r\n    public isReady(): boolean {\r\n        return this._video.readyState >= this._video.HAVE_CURRENT_DATA;\r\n    }\r\n\r\n    /**\r\n     * Dispose the texture and release its associated resources.\r\n     */\r\n    public dispose(): void {}\r\n}\r\n"]}