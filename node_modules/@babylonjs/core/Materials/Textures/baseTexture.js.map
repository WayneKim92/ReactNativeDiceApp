{"version":3,"file":"baseTexture.js","sourceRoot":"","sources":["../../../../../dev/core/src/Materials/Textures/baseTexture.ts"],"names":[],"mappings":"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","sourcesContent":["import { serialize, SerializationHelper, serializeAsTexture } from \"../../Misc/decorators\";\r\nimport type { Observer } from \"../../Misc/observable\";\r\nimport { Observable } from \"../../Misc/observable\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { Matrix } from \"../../Maths/math.vector\";\r\nimport { EngineStore } from \"../../Engines/engineStore\";\r\nimport type { InternalTexture } from \"../../Materials/Textures/internalTexture\";\r\nimport { Constants } from \"../../Engines/constants\";\r\nimport type { IAnimatable } from \"../../Animations/animatable.interface\";\r\nimport { RandomGUID } from \"../../Misc/guid\";\r\n\r\nimport \"../../Misc/fileTools\";\r\nimport type { ThinEngine } from \"../../Engines/thinEngine\";\r\nimport { ThinTexture } from \"./thinTexture\";\r\nimport type { AbstractScene } from \"../../abstractScene\";\r\n\r\nimport type { Animation } from \"../../Animations/animation\";\r\n\r\n/**\r\n * Base class of all the textures in babylon.\r\n * It groups all the common properties the materials, post process, lights... might need\r\n * in order to make a correct use of the texture.\r\n */\r\nexport class BaseTexture extends ThinTexture implements IAnimatable {\r\n    /**\r\n     * Default anisotropic filtering level for the application.\r\n     * It is set to 4 as a good tradeoff between perf and quality.\r\n     */\r\n    public static DEFAULT_ANISOTROPIC_FILTERING_LEVEL = 4;\r\n\r\n    /**\r\n     * Gets or sets the unique id of the texture\r\n     */\r\n    @serialize()\r\n    public uniqueId: number;\r\n\r\n    /**\r\n     * Define the name of the texture.\r\n     */\r\n    @serialize()\r\n    public name: string;\r\n\r\n    /**\r\n     * Gets or sets an object used to store user defined information.\r\n     */\r\n    @serialize()\r\n    public metadata: any = null;\r\n\r\n    /** @internal */\r\n    public _internalMetadata: any;\r\n\r\n    /**\r\n     * For internal use only. Please do not use.\r\n     */\r\n    public reservedDataStore: any = null;\r\n\r\n    @serialize(\"hasAlpha\")\r\n    private _hasAlpha = false;\r\n    /**\r\n     * Define if the texture is having a usable alpha value (can be use for transparency or glossiness for instance).\r\n     */\r\n    public set hasAlpha(value: boolean) {\r\n        if (this._hasAlpha === value) {\r\n            return;\r\n        }\r\n        this._hasAlpha = value;\r\n        if (this._scene) {\r\n            this._scene.markAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag, (mat) => {\r\n                return mat.hasTexture(this);\r\n            });\r\n        }\r\n    }\r\n    public get hasAlpha(): boolean {\r\n        return this._hasAlpha;\r\n    }\r\n\r\n    @serialize(\"getAlphaFromRGB\")\r\n    private _getAlphaFromRGB = false;\r\n    /**\r\n     * Defines if the alpha value should be determined via the rgb values.\r\n     * If true the luminance of the pixel might be used to find the corresponding alpha value.\r\n     */\r\n    public set getAlphaFromRGB(value: boolean) {\r\n        if (this._getAlphaFromRGB === value) {\r\n            return;\r\n        }\r\n        this._getAlphaFromRGB = value;\r\n        if (this._scene) {\r\n            this._scene.markAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag, (mat) => {\r\n                return mat.hasTexture(this);\r\n            });\r\n        }\r\n    }\r\n    public get getAlphaFromRGB(): boolean {\r\n        return this._getAlphaFromRGB;\r\n    }\r\n\r\n    /**\r\n     * Intensity or strength of the texture.\r\n     * It is commonly used by materials to fine tune the intensity of the texture\r\n     */\r\n    @serialize()\r\n    public level = 1;\r\n\r\n    @serialize(\"coordinatesIndex\")\r\n    protected _coordinatesIndex = 0;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that the texture should try to reduce shader code if there is no UV manipulation.\r\n     * (ie. when texture.getTextureMatrix().isIdentityAs3x2() returns true)\r\n     */\r\n    @serialize()\r\n    public optimizeUVAllocation = true;\r\n\r\n    /**\r\n     * Define the UV channel to use starting from 0 and defaulting to 0.\r\n     * This is part of the texture as textures usually maps to one uv set.\r\n     */\r\n    public set coordinatesIndex(value: number) {\r\n        if (this._coordinatesIndex === value) {\r\n            return;\r\n        }\r\n        this._coordinatesIndex = value;\r\n        if (this._scene) {\r\n            this._scene.markAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag, (mat) => {\r\n                return mat.hasTexture(this);\r\n            });\r\n        }\r\n    }\r\n    public get coordinatesIndex(): number {\r\n        return this._coordinatesIndex;\r\n    }\r\n\r\n    @serialize(\"coordinatesMode\")\r\n    protected _coordinatesMode = Constants.TEXTURE_EXPLICIT_MODE;\r\n\r\n    /**\r\n     * How a texture is mapped.\r\n     *\r\n     * | Value | Type                                | Description |\r\n     * | ----- | ----------------------------------- | ----------- |\r\n     * | 0     | EXPLICIT_MODE                       |             |\r\n     * | 1     | SPHERICAL_MODE                      |             |\r\n     * | 2     | PLANAR_MODE                         |             |\r\n     * | 3     | CUBIC_MODE                          |             |\r\n     * | 4     | PROJECTION_MODE                     |             |\r\n     * | 5     | SKYBOX_MODE                         |             |\r\n     * | 6     | INVCUBIC_MODE                       |             |\r\n     * | 7     | EQUIRECTANGULAR_MODE                |             |\r\n     * | 8     | FIXED_EQUIRECTANGULAR_MODE          |             |\r\n     * | 9     | FIXED_EQUIRECTANGULAR_MIRRORED_MODE |             |\r\n     */\r\n    public set coordinatesMode(value: number) {\r\n        if (this._coordinatesMode === value) {\r\n            return;\r\n        }\r\n        this._coordinatesMode = value;\r\n        if (this._scene) {\r\n            this._scene.markAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag, (mat) => {\r\n                return mat.hasTexture(this);\r\n            });\r\n        }\r\n    }\r\n    public get coordinatesMode(): number {\r\n        return this._coordinatesMode;\r\n    }\r\n\r\n    /**\r\n     * | Value | Type               | Description |\r\n     * | ----- | ------------------ | ----------- |\r\n     * | 0     | CLAMP_ADDRESSMODE  |             |\r\n     * | 1     | WRAP_ADDRESSMODE   |             |\r\n     * | 2     | MIRROR_ADDRESSMODE |             |\r\n     */\r\n    @serialize()\r\n    public get wrapU() {\r\n        return this._wrapU;\r\n    }\r\n    public set wrapU(value: number) {\r\n        this._wrapU = value;\r\n    }\r\n\r\n    /**\r\n     * | Value | Type               | Description |\r\n     * | ----- | ------------------ | ----------- |\r\n     * | 0     | CLAMP_ADDRESSMODE  |             |\r\n     * | 1     | WRAP_ADDRESSMODE   |             |\r\n     * | 2     | MIRROR_ADDRESSMODE |             |\r\n     */\r\n    @serialize()\r\n    public get wrapV() {\r\n        return this._wrapV;\r\n    }\r\n    public set wrapV(value: number) {\r\n        this._wrapV = value;\r\n    }\r\n\r\n    /**\r\n     * | Value | Type               | Description |\r\n     * | ----- | ------------------ | ----------- |\r\n     * | 0     | CLAMP_ADDRESSMODE  |             |\r\n     * | 1     | WRAP_ADDRESSMODE   |             |\r\n     * | 2     | MIRROR_ADDRESSMODE |             |\r\n     */\r\n    @serialize()\r\n    public wrapR = Constants.TEXTURE_WRAP_ADDRESSMODE;\r\n\r\n    /**\r\n     * With compliant hardware and browser (supporting anisotropic filtering)\r\n     * this defines the level of anisotropic filtering in the texture.\r\n     * The higher the better but the slower. This defaults to 4 as it seems to be the best tradeoff.\r\n     */\r\n    @serialize()\r\n    public anisotropicFilteringLevel = BaseTexture.DEFAULT_ANISOTROPIC_FILTERING_LEVEL;\r\n\r\n    /** @internal */\r\n    public _isCube = false;\r\n    /**\r\n     * Define if the texture is a cube texture or if false a 2d texture.\r\n     */\r\n    @serialize()\r\n    public get isCube(): boolean {\r\n        if (!this._texture) {\r\n            return this._isCube;\r\n        }\r\n\r\n        return this._texture.isCube;\r\n    }\r\n\r\n    protected set isCube(value: boolean) {\r\n        if (!this._texture) {\r\n            this._isCube = value;\r\n        } else {\r\n            this._texture.isCube = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Define if the texture is a 3d texture (webgl 2) or if false a 2d texture.\r\n     */\r\n    @serialize()\r\n    public get is3D(): boolean {\r\n        if (!this._texture) {\r\n            return false;\r\n        }\r\n\r\n        return this._texture.is3D;\r\n    }\r\n\r\n    protected set is3D(value: boolean) {\r\n        if (!this._texture) {\r\n            return;\r\n        }\r\n\r\n        this._texture.is3D = value;\r\n    }\r\n\r\n    /**\r\n     * Define if the texture is a 2d array texture (webgl 2) or if false a 2d texture.\r\n     */\r\n    @serialize()\r\n    public get is2DArray(): boolean {\r\n        if (!this._texture) {\r\n            return false;\r\n        }\r\n\r\n        return this._texture.is2DArray;\r\n    }\r\n\r\n    protected set is2DArray(value: boolean) {\r\n        if (!this._texture) {\r\n            return;\r\n        }\r\n\r\n        this._texture.is2DArray = value;\r\n    }\r\n\r\n    /** @internal */\r\n    protected _gammaSpace = true;\r\n    /**\r\n     * Define if the texture contains data in gamma space (most of the png/jpg aside bump).\r\n     * HDR texture are usually stored in linear space.\r\n     * This only impacts the PBR and Background materials\r\n     */\r\n    @serialize()\r\n    public get gammaSpace(): boolean {\r\n        if (!this._texture) {\r\n            return this._gammaSpace;\r\n        } else {\r\n            if (this._texture._gammaSpace === null) {\r\n                this._texture._gammaSpace = this._gammaSpace;\r\n            }\r\n        }\r\n\r\n        return this._texture._gammaSpace && !this._texture._useSRGBBuffer;\r\n    }\r\n\r\n    public set gammaSpace(gamma: boolean) {\r\n        if (!this._texture) {\r\n            if (this._gammaSpace === gamma) {\r\n                return;\r\n            }\r\n\r\n            this._gammaSpace = gamma;\r\n        } else {\r\n            if (this._texture._gammaSpace === gamma) {\r\n                return;\r\n            }\r\n            this._texture._gammaSpace = gamma;\r\n        }\r\n\r\n        this.getScene()?.markAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag, (mat) => {\r\n            return mat.hasTexture(this);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Gets or sets whether or not the texture contains RGBD data.\r\n     */\r\n    public get isRGBD(): boolean {\r\n        return this._texture != null && this._texture._isRGBD;\r\n    }\r\n    public set isRGBD(value: boolean) {\r\n        if (value === this.isRGBD) {\r\n            return;\r\n        }\r\n\r\n        if (this._texture) {\r\n            this._texture._isRGBD = value;\r\n        }\r\n\r\n        this.getScene()?.markAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag, (mat) => {\r\n            return mat.hasTexture(this);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Is Z inverted in the texture (useful in a cube texture).\r\n     */\r\n    @serialize()\r\n    public invertZ = false;\r\n\r\n    /**\r\n     * Are mip maps generated for this texture or not.\r\n     */\r\n    public get noMipmap(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    @serialize()\r\n    public lodLevelInAlpha = false;\r\n\r\n    /**\r\n     * With prefiltered texture, defined the offset used during the prefiltering steps.\r\n     */\r\n    @serialize()\r\n    public get lodGenerationOffset(): number {\r\n        if (this._texture) {\r\n            return this._texture._lodGenerationOffset;\r\n        }\r\n\r\n        return 0.0;\r\n    }\r\n    public set lodGenerationOffset(value: number) {\r\n        if (this._texture) {\r\n            this._texture._lodGenerationOffset = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * With prefiltered texture, defined the scale used during the prefiltering steps.\r\n     */\r\n    @serialize()\r\n    public get lodGenerationScale(): number {\r\n        if (this._texture) {\r\n            return this._texture._lodGenerationScale;\r\n        }\r\n\r\n        return 0.0;\r\n    }\r\n    public set lodGenerationScale(value: number) {\r\n        if (this._texture) {\r\n            this._texture._lodGenerationScale = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * With prefiltered texture, defined if the specular generation is based on a linear ramp.\r\n     * By default we are using a log2 of the linear roughness helping to keep a better resolution for\r\n     * average roughness values.\r\n     */\r\n    @serialize()\r\n    public get linearSpecularLOD(): boolean {\r\n        if (this._texture) {\r\n            return this._texture._linearSpecularLOD;\r\n        }\r\n\r\n        return false;\r\n    }\r\n    public set linearSpecularLOD(value: boolean) {\r\n        if (this._texture) {\r\n            this._texture._linearSpecularLOD = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * In case a better definition than spherical harmonics is required for the diffuse part of the environment.\r\n     * You can set the irradiance texture to rely on a texture instead of the spherical approach.\r\n     * This texture need to have the same characteristics than its parent (Cube vs 2d, coordinates mode, Gamma/Linear, RGBD).\r\n     */\r\n    @serializeAsTexture()\r\n    public get irradianceTexture(): Nullable<BaseTexture> {\r\n        if (this._texture) {\r\n            return this._texture._irradianceTexture;\r\n        }\r\n\r\n        return null;\r\n    }\r\n    public set irradianceTexture(value: Nullable<BaseTexture>) {\r\n        if (this._texture) {\r\n            this._texture._irradianceTexture = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Define if the texture is a render target.\r\n     */\r\n    @serialize()\r\n    public isRenderTarget = false;\r\n\r\n    /**\r\n     * Define the unique id of the texture in the scene.\r\n     */\r\n    public get uid(): string {\r\n        if (!this._uid) {\r\n            this._uid = RandomGUID();\r\n        }\r\n        return this._uid;\r\n    }\r\n\r\n    /** @internal */\r\n    public _prefiltered: boolean = false;\r\n    /** @internal */\r\n    public _forceSerialize: boolean = false;\r\n\r\n    /**\r\n     * Return a string representation of the texture.\r\n     * @returns the texture as a string\r\n     */\r\n    public toString(): string {\r\n        return this.name;\r\n    }\r\n\r\n    /**\r\n     * Get the class name of the texture.\r\n     * @returns \"BaseTexture\"\r\n     */\r\n    public getClassName(): string {\r\n        return \"BaseTexture\";\r\n    }\r\n\r\n    /**\r\n     * Define the list of animation attached to the texture.\r\n     */\r\n    public animations: Animation[] = [];\r\n\r\n    /**\r\n     * An event triggered when the texture is disposed.\r\n     */\r\n    public onDisposeObservable = new Observable<BaseTexture>();\r\n\r\n    private _onDisposeObserver: Nullable<Observer<BaseTexture>> = null;\r\n    /**\r\n     * Callback triggered when the texture has been disposed.\r\n     * Kept for back compatibility, you can use the onDisposeObservable instead.\r\n     */\r\n    public set onDispose(callback: () => void) {\r\n        if (this._onDisposeObserver) {\r\n            this.onDisposeObservable.remove(this._onDisposeObserver);\r\n        }\r\n        this._onDisposeObserver = this.onDisposeObservable.add(callback);\r\n    }\r\n\r\n    protected _scene: Nullable<Scene> = null;\r\n\r\n    /** @internal */\r\n    private _uid: Nullable<string> = null;\r\n\r\n    /**\r\n     * Define if the texture is preventing a material to render or not.\r\n     * If not and the texture is not ready, the engine will use a default black texture instead.\r\n     */\r\n    public get isBlocking(): boolean {\r\n        return true;\r\n    }\r\n\r\n    /** @internal */\r\n    public _parentContainer: Nullable<AbstractScene> = null;\r\n\r\n    protected _loadingError: boolean = false;\r\n    protected _errorObject?: {\r\n        message?: string;\r\n        exception?: any;\r\n    };\r\n\r\n    /**\r\n     * Was there any loading error?\r\n     */\r\n    public get loadingError(): boolean {\r\n        return this._loadingError;\r\n    }\r\n\r\n    /**\r\n     * If a loading error occurred this object will be populated with information about the error.\r\n     */\r\n    public get errorObject():\r\n        | {\r\n              message?: string;\r\n              exception?: any;\r\n          }\r\n        | undefined {\r\n        return this._errorObject;\r\n    }\r\n\r\n    /**\r\n     * Instantiates a new BaseTexture.\r\n     * Base class of all the textures in babylon.\r\n     * It groups all the common properties the materials, post process, lights... might need\r\n     * in order to make a correct use of the texture.\r\n     * @param sceneOrEngine Define the scene or engine the texture belongs to\r\n     * @param internalTexture Define the internal texture associated with the texture\r\n     */\r\n    constructor(sceneOrEngine?: Nullable<Scene | ThinEngine>, internalTexture: Nullable<InternalTexture> = null) {\r\n        super(null);\r\n\r\n        if (sceneOrEngine) {\r\n            if (BaseTexture._IsScene(sceneOrEngine)) {\r\n                this._scene = sceneOrEngine;\r\n            } else {\r\n                this._engine = sceneOrEngine;\r\n            }\r\n        } else {\r\n            this._scene = EngineStore.LastCreatedScene;\r\n        }\r\n\r\n        if (this._scene) {\r\n            this.uniqueId = this._scene.getUniqueId();\r\n            this._scene.addTexture(this);\r\n            this._engine = this._scene.getEngine();\r\n        }\r\n\r\n        this._texture = internalTexture;\r\n\r\n        this._uid = null;\r\n    }\r\n\r\n    /**\r\n     * Get the scene the texture belongs to.\r\n     * @returns the scene or null if undefined\r\n     */\r\n    public getScene(): Nullable<Scene> {\r\n        return this._scene;\r\n    }\r\n\r\n    /** @internal */\r\n    protected _getEngine(): Nullable<ThinEngine> {\r\n        return this._engine;\r\n    }\r\n\r\n    /**\r\n     * Checks if the texture has the same transform matrix than another texture\r\n     * @param texture texture to check against\r\n     * @returns true if the transforms are the same, else false\r\n     */\r\n    public checkTransformsAreIdentical(texture: Nullable<BaseTexture>): boolean {\r\n        return texture !== null;\r\n    }\r\n\r\n    /**\r\n     * Get the texture transform matrix used to offset tile the texture for instance.\r\n     * @returns the transformation matrix\r\n     */\r\n    public getTextureMatrix(): Matrix {\r\n        return <Matrix>Matrix.IdentityReadOnly;\r\n    }\r\n\r\n    /**\r\n     * Get the texture reflection matrix used to rotate/transform the reflection.\r\n     * @returns the reflection matrix\r\n     */\r\n    public getReflectionTextureMatrix(): Matrix {\r\n        return <Matrix>Matrix.IdentityReadOnly;\r\n    }\r\n\r\n    /**\r\n     * Gets a suitable rotate/transform matrix when the texture is used for refraction.\r\n     * There's a separate function from getReflectionTextureMatrix because refraction requires a special configuration of the matrix in right-handed mode.\r\n     * @returns The refraction matrix\r\n     */\r\n    public getRefractionTextureMatrix(): Matrix {\r\n        return this.getReflectionTextureMatrix();\r\n    }\r\n\r\n    /**\r\n     * Get if the texture is ready to be consumed (either it is ready or it is not blocking)\r\n     * @returns true if ready, not blocking or if there was an error loading the texture\r\n     */\r\n    public isReadyOrNotBlocking(): boolean {\r\n        return !this.isBlocking || this.isReady() || this.loadingError;\r\n    }\r\n\r\n    /**\r\n     * Scales the texture if is `canRescale()`\r\n     * @param ratio the resize factor we want to use to rescale\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public scale(ratio: number): void {}\r\n\r\n    /**\r\n     * Get if the texture can rescale.\r\n     */\r\n    public get canRescale(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _getFromCache(url: Nullable<string>, noMipmap: boolean, sampling?: number, invertY?: boolean, useSRGBBuffer?: boolean, isCube?: boolean): Nullable<InternalTexture> {\r\n        const engine = this._getEngine();\r\n        if (!engine) {\r\n            return null;\r\n        }\r\n\r\n        const correctedUseSRGBBuffer = engine._getUseSRGBBuffer(!!useSRGBBuffer, noMipmap);\r\n\r\n        const texturesCache = engine.getLoadedTexturesCache();\r\n        for (let index = 0; index < texturesCache.length; index++) {\r\n            const texturesCacheEntry = texturesCache[index];\r\n\r\n            if (useSRGBBuffer === undefined || correctedUseSRGBBuffer === texturesCacheEntry._useSRGBBuffer) {\r\n                if (invertY === undefined || invertY === texturesCacheEntry.invertY) {\r\n                    if (texturesCacheEntry.url === url && texturesCacheEntry.generateMipMaps === !noMipmap) {\r\n                        if (!sampling || sampling === texturesCacheEntry.samplingMode) {\r\n                            if (isCube === undefined || isCube === texturesCacheEntry.isCube) {\r\n                                texturesCacheEntry.incrementReferences();\r\n                                return texturesCacheEntry;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /** @internal */\r\n    public _rebuild(): void {}\r\n\r\n    /**\r\n     * Clones the texture.\r\n     * @returns the cloned texture\r\n     */\r\n    public clone(): Nullable<BaseTexture> {\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Get the texture underlying type (INT, FLOAT...)\r\n     */\r\n    public get textureType(): number {\r\n        if (!this._texture) {\r\n            return Constants.TEXTURETYPE_UNSIGNED_INT;\r\n        }\r\n\r\n        return this._texture.type !== undefined ? this._texture.type : Constants.TEXTURETYPE_UNSIGNED_INT;\r\n    }\r\n\r\n    /**\r\n     * Get the texture underlying format (RGB, RGBA...)\r\n     */\r\n    public get textureFormat(): number {\r\n        if (!this._texture) {\r\n            return Constants.TEXTUREFORMAT_RGBA;\r\n        }\r\n\r\n        return this._texture.format !== undefined ? this._texture.format : Constants.TEXTUREFORMAT_RGBA;\r\n    }\r\n\r\n    /**\r\n     * Indicates that textures need to be re-calculated for all materials\r\n     */\r\n    protected _markAllSubMeshesAsTexturesDirty() {\r\n        const scene = this.getScene();\r\n\r\n        if (!scene) {\r\n            return;\r\n        }\r\n\r\n        scene.markAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag);\r\n    }\r\n\r\n    /**\r\n     * Reads the pixels stored in the webgl texture and returns them as an ArrayBuffer.\r\n     * This will returns an RGBA array buffer containing either in values (0-255) or\r\n     * float values (0-1) depending of the underlying buffer type.\r\n     * @param faceIndex defines the face of the texture to read (in case of cube texture)\r\n     * @param level defines the LOD level of the texture to read (in case of Mip Maps)\r\n     * @param buffer defines a user defined buffer to fill with data (can be null)\r\n     * @param flushRenderer true to flush the renderer from the pending commands before reading the pixels\r\n     * @param noDataConversion false to convert the data to Uint8Array (if texture type is UNSIGNED_BYTE) or to Float32Array (if texture type is anything but UNSIGNED_BYTE). If true, the type of the generated buffer (if buffer==null) will depend on the type of the texture\r\n     * @param x defines the region x coordinates to start reading from (default to 0)\r\n     * @param y defines the region y coordinates to start reading from (default to 0)\r\n     * @param width defines the region width to read from (default to the texture size at level)\r\n     * @param height defines the region width to read from (default to the texture size at level)\r\n     * @returns The Array buffer promise containing the pixels data.\r\n     */\r\n    public readPixels(\r\n        faceIndex = 0,\r\n        level = 0,\r\n        buffer: Nullable<ArrayBufferView> = null,\r\n        flushRenderer = true,\r\n        noDataConversion = false,\r\n        x = 0,\r\n        y = 0,\r\n        width = Number.MAX_VALUE,\r\n        height = Number.MAX_VALUE\r\n    ): Nullable<Promise<ArrayBufferView>> {\r\n        if (!this._texture) {\r\n            return null;\r\n        }\r\n\r\n        const engine = this._getEngine();\r\n        if (!engine) {\r\n            return null;\r\n        }\r\n\r\n        const size = this.getSize();\r\n        let maxWidth = size.width;\r\n        let maxHeight = size.height;\r\n        if (level !== 0) {\r\n            maxWidth = maxWidth / Math.pow(2, level);\r\n            maxHeight = maxHeight / Math.pow(2, level);\r\n            maxWidth = Math.round(maxWidth);\r\n            maxHeight = Math.round(maxHeight);\r\n        }\r\n\r\n        width = Math.min(maxWidth, width);\r\n        height = Math.min(maxHeight, height);\r\n\r\n        try {\r\n            if (this._texture.isCube) {\r\n                return engine._readTexturePixels(this._texture, width, height, faceIndex, level, buffer, flushRenderer, noDataConversion, x, y);\r\n            }\r\n\r\n            return engine._readTexturePixels(this._texture, width, height, -1, level, buffer, flushRenderer, noDataConversion, x, y);\r\n        } catch (e) {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _readPixelsSync(faceIndex = 0, level = 0, buffer: Nullable<ArrayBufferView> = null, flushRenderer = true, noDataConversion = false): Nullable<ArrayBufferView> {\r\n        if (!this._texture) {\r\n            return null;\r\n        }\r\n\r\n        const size = this.getSize();\r\n        let width = size.width;\r\n        let height = size.height;\r\n\r\n        const engine = this._getEngine();\r\n        if (!engine) {\r\n            return null;\r\n        }\r\n\r\n        if (level != 0) {\r\n            width = width / Math.pow(2, level);\r\n            height = height / Math.pow(2, level);\r\n\r\n            width = Math.round(width);\r\n            height = Math.round(height);\r\n        }\r\n\r\n        try {\r\n            if (this._texture.isCube) {\r\n                return engine._readTexturePixelsSync(this._texture, width, height, faceIndex, level, buffer, flushRenderer, noDataConversion);\r\n            }\r\n\r\n            return engine._readTexturePixelsSync(this._texture, width, height, -1, level, buffer, flushRenderer, noDataConversion);\r\n        } catch (e) {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /** @internal */\r\n    public get _lodTextureHigh(): Nullable<BaseTexture> {\r\n        if (this._texture) {\r\n            return this._texture._lodTextureHigh;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /** @internal */\r\n    public get _lodTextureMid(): Nullable<BaseTexture> {\r\n        if (this._texture) {\r\n            return this._texture._lodTextureMid;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /** @internal */\r\n    public get _lodTextureLow(): Nullable<BaseTexture> {\r\n        if (this._texture) {\r\n            return this._texture._lodTextureLow;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Dispose the texture and release its associated resources.\r\n     */\r\n    public dispose(): void {\r\n        if (this._scene) {\r\n            // Animations\r\n            if (this._scene.stopAnimation) {\r\n                this._scene.stopAnimation(this);\r\n            }\r\n\r\n            // Remove from scene\r\n            this._scene.removePendingData(this);\r\n            const index = this._scene.textures.indexOf(this);\r\n\r\n            if (index >= 0) {\r\n                this._scene.textures.splice(index, 1);\r\n            }\r\n            this._scene.onTextureRemovedObservable.notifyObservers(this);\r\n            this._scene = null;\r\n\r\n            if (this._parentContainer) {\r\n                const index = this._parentContainer.textures.indexOf(this);\r\n                if (index > -1) {\r\n                    this._parentContainer.textures.splice(index, 1);\r\n                }\r\n                this._parentContainer = null;\r\n            }\r\n        }\r\n\r\n        // Callback\r\n        this.onDisposeObservable.notifyObservers(this);\r\n        this.onDisposeObservable.clear();\r\n\r\n        this.metadata = null;\r\n\r\n        super.dispose();\r\n    }\r\n\r\n    /**\r\n     * Serialize the texture into a JSON representation that can be parsed later on.\r\n     * @param allowEmptyName True to force serialization even if name is empty. Default: false\r\n     * @returns the JSON representation of the texture\r\n     */\r\n    public serialize(allowEmptyName = false): any {\r\n        if (!this.name && !allowEmptyName) {\r\n            return null;\r\n        }\r\n\r\n        const serializationObject = SerializationHelper.Serialize(this);\r\n\r\n        // Animations\r\n        SerializationHelper.AppendSerializedAnimations(this, serializationObject);\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Helper function to be called back once a list of texture contains only ready textures.\r\n     * @param textures Define the list of textures to wait for\r\n     * @param callback Define the callback triggered once the entire list will be ready\r\n     */\r\n    public static WhenAllReady(textures: BaseTexture[], callback: () => void): void {\r\n        let numRemaining = textures.length;\r\n        if (numRemaining === 0) {\r\n            callback();\r\n            return;\r\n        }\r\n\r\n        for (let i = 0; i < textures.length; i++) {\r\n            const texture = textures[i];\r\n\r\n            if (texture.isReady()) {\r\n                if (--numRemaining === 0) {\r\n                    callback();\r\n                }\r\n            } else {\r\n                const onLoadObservable = (texture as any).onLoadObservable as Observable<BaseTexture>;\r\n\r\n                if (onLoadObservable) {\r\n                    onLoadObservable.addOnce(() => {\r\n                        if (--numRemaining === 0) {\r\n                            callback();\r\n                        }\r\n                    });\r\n                } else {\r\n                    if (--numRemaining === 0) {\r\n                        callback();\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private static _IsScene(sceneOrEngine: Scene | ThinEngine): sceneOrEngine is Scene {\r\n        return sceneOrEngine.getClassName() === \"Scene\";\r\n    }\r\n}\r\n"]}