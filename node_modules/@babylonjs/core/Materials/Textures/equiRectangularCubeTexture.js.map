{"version":3,"file":"equiRectangularCubeTexture.js","sourceRoot":"","sources":["../../../../../dev/core/src/Materials/Textures/equiRectangularCubeTexture.ts"],"names":[],"mappings":"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","sourcesContent":["import { PanoramaToCubeMapTools } from \"../../Misc/HighDynamicRange/panoramaToCubemap\";\r\nimport { BaseTexture } from \"./baseTexture\";\r\nimport { Texture } from \"./texture\";\r\nimport type { Scene } from \"../../scene\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { Tools } from \"../../Misc/tools\";\r\nimport \"../../Engines/Extensions/engine.rawTexture\";\r\nimport { Constants } from \"../../Engines/constants\";\r\nimport { LoadImage } from \"../../Misc/fileTools\";\r\n\r\n/**\r\n * This represents a texture coming from an equirectangular image supported by the web browser canvas.\r\n */\r\nexport class EquiRectangularCubeTexture extends BaseTexture {\r\n    /** The six faces of the cube. */\r\n    private static _FacesMapping = [\"right\", \"left\", \"up\", \"down\", \"front\", \"back\"];\r\n\r\n    private _noMipmap: boolean;\r\n    private _onLoad: Nullable<() => void> = null;\r\n    private _onError: Nullable<() => void> = null;\r\n\r\n    /** The size of the cubemap. */\r\n    private _size: number;\r\n\r\n    /** Whether to supersample the input image */\r\n    private _supersample: boolean;\r\n\r\n    /** The buffer of the image. */\r\n    private _buffer: ArrayBuffer;\r\n\r\n    /** The width of the input image. */\r\n    private _width: number;\r\n\r\n    /** The height of the input image. */\r\n    private _height: number;\r\n\r\n    /** The URL to the image. */\r\n    public url: string;\r\n\r\n    /**\r\n     * Instantiates an EquiRectangularCubeTexture from the following parameters.\r\n     * @param url The location of the image\r\n     * @param scene The scene the texture will be used in\r\n     * @param size The cubemap desired size (the more it increases the longer the generation will be)\r\n     * @param noMipmap Forces to not generate the mipmap if true\r\n     * @param gammaSpace Specifies if the texture will be used in gamma or linear space\r\n     * (the PBR material requires those textures in linear space, but the standard material would require them in Gamma space)\r\n     * @param onLoad — defines a callback called when texture is loaded\r\n     * @param onError — defines a callback called if there is an error\r\n     */\r\n    constructor(\r\n        url: string,\r\n        scene: Scene,\r\n        size: number,\r\n        noMipmap: boolean = false,\r\n        gammaSpace: boolean = true,\r\n        onLoad: Nullable<() => void> = null,\r\n        onError: Nullable<(message?: string, exception?: any) => void> = null,\r\n        supersample = false\r\n    ) {\r\n        super(scene);\r\n\r\n        if (!url) {\r\n            throw new Error(\"Image url is not set\");\r\n        }\r\n\r\n        this._coordinatesMode = Texture.CUBIC_MODE;\r\n        this.name = url;\r\n        this.url = url;\r\n        this._size = size;\r\n        this._supersample = supersample;\r\n        this._noMipmap = noMipmap;\r\n        this.gammaSpace = gammaSpace;\r\n        this._onLoad = onLoad;\r\n        this._onError = onError;\r\n\r\n        this.hasAlpha = false;\r\n        this.isCube = true;\r\n\r\n        this._texture = this._getFromCache(url, this._noMipmap, undefined, undefined, undefined, this.isCube);\r\n\r\n        if (!this._texture) {\r\n            if (!scene.useDelayedTextureLoading) {\r\n                this._loadImage(() => this._loadTexture(), this._onError);\r\n            } else {\r\n                this.delayLoadState = Constants.DELAYLOADSTATE_NOTLOADED;\r\n            }\r\n        } else if (onLoad) {\r\n            if (this._texture.isReady) {\r\n                Tools.SetImmediate(() => onLoad());\r\n            } else {\r\n                this._texture.onLoadedObservable.add(onLoad);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Load the image data, by putting the image on a canvas and extracting its buffer.\r\n     * @param loadTextureCallback\r\n     * @param onError\r\n     */\r\n    private _loadImage(loadTextureCallback: () => void, onError: Nullable<(message?: string, exception?: any) => void>): void {\r\n        const scene = this.getScene();\r\n        if (!scene) {\r\n            return;\r\n        }\r\n\r\n        // Create texture before loading\r\n        const texture = scene\r\n            .getEngine()\r\n            .createRawCubeTexture(\r\n                null,\r\n                this._size,\r\n                Constants.TEXTUREFORMAT_RGB,\r\n                scene.getEngine().getCaps().textureFloat ? Constants.TEXTURETYPE_FLOAT : Constants.TEXTURETYPE_UNSIGNED_INTEGER,\r\n                this._noMipmap,\r\n                false,\r\n                Constants.TEXTURE_TRILINEAR_SAMPLINGMODE\r\n            );\r\n        texture.generateMipMaps = !this._noMipmap;\r\n        scene.addPendingData(texture);\r\n        texture.url = this.url;\r\n        texture.isReady = false;\r\n        scene.getEngine()._internalTexturesCache.push(texture);\r\n        this._texture = texture;\r\n\r\n        const canvas = document.createElement(\"canvas\");\r\n        LoadImage(\r\n            this.url,\r\n            (image) => {\r\n                this._width = image.width;\r\n                this._height = image.height;\r\n                canvas.width = this._width;\r\n                canvas.height = this._height;\r\n\r\n                const ctx = canvas.getContext(\"2d\") as CanvasRenderingContext2D;\r\n                ctx.drawImage(image, 0, 0);\r\n\r\n                const imageData = ctx.getImageData(0, 0, image.width, image.height);\r\n                this._buffer = imageData.data.buffer as ArrayBuffer;\r\n\r\n                canvas.remove();\r\n                loadTextureCallback();\r\n            },\r\n            (_, e) => {\r\n                scene.removePendingData(texture);\r\n                if (onError) {\r\n                    onError(`${this.getClassName()} could not be loaded`, e);\r\n                }\r\n            },\r\n            scene ? scene.offlineProvider : null\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Convert the image buffer into a cubemap and create a CubeTexture.\r\n     */\r\n    private _loadTexture(): void {\r\n        const scene = this.getScene();\r\n        const callback = (): ArrayBufferView[] => {\r\n            const imageData = this._getFloat32ArrayFromArrayBuffer(this._buffer);\r\n\r\n            // Extract the raw linear data.\r\n            const data = PanoramaToCubeMapTools.ConvertPanoramaToCubemap(imageData, this._width, this._height, this._size, this._supersample);\r\n\r\n            const results = [];\r\n\r\n            // Push each faces.\r\n            for (let i = 0; i < 6; i++) {\r\n                const dataFace = (data as any)[EquiRectangularCubeTexture._FacesMapping[i]];\r\n                results.push(dataFace);\r\n            }\r\n\r\n            return results;\r\n        };\r\n\r\n        if (!scene) {\r\n            return;\r\n        }\r\n        const faceDataArrays = callback();\r\n\r\n        const texture = this._texture!;\r\n        scene.getEngine().updateRawCubeTexture(texture, faceDataArrays, texture.format, texture.type, texture.invertY);\r\n        texture.isReady = true;\r\n        scene.removePendingData(texture);\r\n\r\n        texture.onLoadedObservable.notifyObservers(texture);\r\n        texture.onLoadedObservable.clear();\r\n\r\n        if (this._onLoad) {\r\n            this._onLoad();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Convert the ArrayBuffer into a Float32Array and drop the transparency channel.\r\n     * @param buffer The ArrayBuffer that should be converted.\r\n     * @returns The buffer as Float32Array.\r\n     */\r\n    private _getFloat32ArrayFromArrayBuffer(buffer: ArrayBuffer): Float32Array {\r\n        const dataView = new DataView(buffer);\r\n        const floatImageData = new Float32Array((buffer.byteLength * 3) / 4);\r\n\r\n        let k = 0;\r\n        for (let i = 0; i < buffer.byteLength; i++) {\r\n            // We drop the transparency channel, because we do not need/want it\r\n            if ((i + 1) % 4 !== 0) {\r\n                floatImageData[k++] = dataView.getUint8(i) / 255;\r\n            }\r\n        }\r\n\r\n        return floatImageData;\r\n    }\r\n\r\n    /**\r\n     * Get the current class name of the texture useful for serialization or dynamic coding.\r\n     * @returns \"EquiRectangularCubeTexture\"\r\n     */\r\n    public getClassName(): string {\r\n        return \"EquiRectangularCubeTexture\";\r\n    }\r\n\r\n    /**\r\n     * Create a clone of the current EquiRectangularCubeTexture and return it.\r\n     * @returns A clone of the current EquiRectangularCubeTexture.\r\n     */\r\n    public clone(): EquiRectangularCubeTexture {\r\n        const scene = this.getScene();\r\n        if (!scene) {\r\n            return this;\r\n        }\r\n\r\n        const newTexture = new EquiRectangularCubeTexture(this.url, scene, this._size, this._noMipmap, this.gammaSpace);\r\n\r\n        // Base texture\r\n        newTexture.level = this.level;\r\n        newTexture.wrapU = this.wrapU;\r\n        newTexture.wrapV = this.wrapV;\r\n        newTexture.coordinatesIndex = this.coordinatesIndex;\r\n        newTexture.coordinatesMode = this.coordinatesMode;\r\n\r\n        return newTexture;\r\n    }\r\n}\r\n"]}