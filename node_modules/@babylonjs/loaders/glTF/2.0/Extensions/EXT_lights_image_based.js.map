{"version":3,"file":"EXT_lights_image_based.js","sourceRoot":"","sources":["../../../../../../dev/loaders/src/glTF/2.0/Extensions/EXT_lights_image_based.ts"],"names":[],"mappings":"AACA,OAAO,EAAE,MAAM,EAAE,6CAA+B;AAChD,OAAO,EAAE,kBAAkB,EAAE,mBAAmB,EAAE,qDAAuC;AACzF,OAAO,EAAE,UAAU,EAAE,MAAM,EAAE,6CAA+B;AAE5D,OAAO,EAAE,cAAc,EAAE,6DAA+C;AAKxE,OAAO,EAAE,UAAU,EAAE,SAAS,EAAE,MAAM,eAAe,CAAC;AAEtD,MAAM,IAAI,GAAG,wBAAwB,CAAC;AAWtC;;GAEG;AACH,gEAAgE;AAChE,MAAM,OAAO,sBAAsB;IAc/B;;OAEG;IACH,YAAY,MAAkB;QAhB9B;;WAEG;QACa,SAAI,GAAG,IAAI,CAAC;QAcxB,IAAI,CAAC,OAAO,GAAG,MAAM,CAAC;QACtB,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC,OAAO,CAAC,eAAe,CAAC,IAAI,CAAC,CAAC;IACtD,CAAC;IAED,gBAAgB;IACT,OAAO;QACT,IAAI,CAAC,OAAe,GAAG,IAAI,CAAC;QAC7B,OAAO,IAAI,CAAC,OAAO,CAAC;IACxB,CAAC;IAED,gBAAgB;IACT,SAAS;QACZ,MAAM,UAAU,GAAG,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,UAAU,CAAC;QAChD,IAAI,UAAU,IAAI,UAAU,CAAC,IAAI,CAAC,IAAI,CAAC,EAAE;YACrC,MAAM,SAAS,GAAG,UAAU,CAAC,IAAI,CAAC,IAAI,CAAyB,CAAC;YAChE,IAAI,CAAC,OAAO,GAAG,SAAS,CAAC,MAAM,CAAC;SACnC;IACL,CAAC;IAED;;OAEG;IACI,cAAc,CAAC,OAAe,EAAE,KAAa;QAChD,OAAO,UAAU,CAAC,kBAAkB,CAAgD,OAAO,EAAE,KAAK,EAAE,IAAI,CAAC,IAAI,EAAE,CAAC,gBAAgB,EAAE,SAAS,EAAE,EAAE;YAC3I,IAAI,CAAC,OAAO,CAAC,0BAA0B,GAAG,IAAI,CAAC;YAE/C,MAAM,QAAQ,GAAG,IAAI,KAAK,EAAgB,CAAC;YAE3C,QAAQ,CAAC,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,cAAc,CAAC,OAAO,EAAE,KAAK,CAAC,CAAC,CAAC;YAE3D,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,GAAG,gBAAgB,EAAE,CAAC,CAAC;YAE5C,MAAM,KAAK,GAAG,SAAS,CAAC,GAAG,CAAC,GAAG,gBAAgB,QAAQ,EAAE,IAAI,CAAC,OAAO,EAAE,SAAS,CAAC,KAAK,CAAC,CAAC;YACxF,QAAQ,CAAC,IAAI,CACT,IAAI,CAAC,eAAe,CAAC,eAAe,IAAI,CAAC,IAAI,WAAW,SAAS,CAAC,KAAK,EAAE,EAAE,KAAK,CAAC,CAAC,IAAI,CAAC,CAAC,OAAO,EAAE,EAAE;gBAC/F,IAAI,CAAC,OAAO,CAAC,YAAY,CAAC,kBAAkB,GAAG,OAAO,CAAC;YAC3D,CAAC,CAAC,CACL,CAAC;YAEF,IAAI,CAAC,OAAO,CAAC,QAAQ,EAAE,CAAC;YAExB,OAAO,OAAO,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC,IAAI,CAAC,GAAG,EAAE,GAAE,CAAC,CAAC,CAAC;QAChD,CAAC,CAAC,CAAC;IACP,CAAC;IAEO,eAAe,CAAC,OAAe,EAAE,KAA2C;QAChF,IAAI,CAAC,KAAK,CAAC,OAAO,EAAE;YAChB,MAAM,QAAQ,GAAG,IAAI,KAAK,EAAgB,CAAC;YAE3C,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,GAAG,OAAO,EAAE,CAAC,CAAC;YAEnC,MAAM,SAAS,GAAG,IAAI,KAAK,CAAyB,KAAK,CAAC,cAAc,CAAC,MAAM,CAAC,CAAC;YACjF,KAAK,IAAI,MAAM,GAAG,CAAC,EAAE,MAAM,GAAG,KAAK,CAAC,cAAc,CAAC,MAAM,EAAE,MAAM,EAAE,EAAE;gBACjE,MAAM,KAAK,GAAG,KAAK,CAAC,cAAc,CAAC,MAAM,CAAC,CAAC;gBAC3C,SAAS,CAAC,MAAM,CAAC,GAAG,IAAI,KAAK,CAAkB,KAAK,CAAC,MAAM,CAAC,CAAC;gBAC7D,KAAK,IAAI,IAAI,GAAG,CAAC,EAAE,IAAI,GAAG,KAAK,CAAC,MAAM,EAAE,IAAI,EAAE,EAAE;oBAC5C,MAAM,oBAAoB,GAAG,GAAG,OAAO,mBAAmB,MAAM,IAAI,IAAI,EAAE,CAAC;oBAC3E,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,GAAG,oBAAoB,EAAE,CAAC,CAAC;oBAEhD,MAAM,KAAK,GAAG,KAAK,CAAC,IAAI,CAAC,CAAC;oBAC1B,MAAM,KAAK,GAAG,SAAS,CAAC,GAAG,CAAC,oBAAoB,EAAE,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,MAAM,EAAE,KAAK,CAAC,CAAC;oBACnF,QAAQ,CAAC,IAAI,CACT,IAAI,CAAC,OAAO,CAAC,cAAc,CAAC,WAAW,KAAK,EAAE,EAAE,KAAK,CAAC,CAAC,IAAI,CAAC,CAAC,IAAI,EAAE,EAAE;wBACjE,SAAS,CAAC,MAAM,CAAC,CAAC,IAAI,CAAC,GAAG,IAAI,CAAC;oBACnC,CAAC,CAAC,CACL,CAAC;oBAEF,IAAI,CAAC,OAAO,CAAC,QAAQ,EAAE,CAAC;iBAC3B;aACJ;YAED,IAAI,CAAC,OAAO,CAAC,QAAQ,EAAE,CAAC;YAExB,KAAK,CAAC,OAAO,GAAG,OAAO,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC,IAAI,CAAC,GAAG,EAAE;gBAC5C,MAAM,cAAc,GAAG,IAAI,cAAc,CAAC,IAAI,CAAC,OAAO,CAAC,YAAY,EAAE,IAAI,EAAE,KAAK,CAAC,iBAAiB,CAAC,CAAC;gBACpG,cAAc,CAAC,IAAI,GAAG,KAAK,CAAC,IAAI,IAAI,aAAa,CAAC;gBAClD,KAAK,CAAC,eAAe,GAAG,cAAc,CAAC;gBAEvC,IAAI,KAAK,CAAC,SAAS,IAAI,SAAS,EAAE;oBAC9B,cAAc,CAAC,KAAK,GAAG,KAAK,CAAC,SAAS,CAAC;iBAC1C;gBAED,IAAI,KAAK,CAAC,QAAQ,EAAE;oBAChB,IAAI,QAAQ,GAAG,UAAU,CAAC,SAAS,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC;oBAEpD,sEAAsE;oBACtE,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,YAAY,CAAC,oBAAoB,EAAE;wBACjD,QAAQ,GAAG,UAAU,CAAC,OAAO,CAAC,QAAQ,CAAC,CAAC;qBAC3C;oBAED,MAAM,CAAC,mBAAmB,CAAC,QAAQ,EAAE,cAAc,CAAC,0BAA0B,EAAE,CAAC,CAAC;iBACrF;gBAED,IAAI,CAAC,KAAK,CAAC,sBAAsB,EAAE;oBAC/B,MAAM,IAAI,KAAK,CAAC,GAAG,OAAO,uCAAuC,CAAC,CAAC;iBACtE;gBAED,MAAM,kBAAkB,GAAG,kBAAkB,CAAC,SAAS,CAAC,KAAK,CAAC,sBAAsB,CAAC,CAAC;gBACtF,kBAAkB,CAAC,YAAY,CAAC,KAAK,CAAC,SAAS,CAAC,CAAC;gBAEjD,kBAAkB,CAAC,qCAAqC,EAAE,CAAC;gBAC3D,MAAM,mBAAmB,GAAG,mBAAmB,CAAC,aAAa,CAAC,kBAAkB,CAAC,CAAC;gBAElF,qFAAqF;gBACrF,MAAM,kBAAkB,GAAG,CAAC,SAAS,CAAC,MAAM,GAAG,CAAC,CAAC,GAAG,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,iBAAiB,CAAC,CAAC;gBACzF,OAAO,cAAc,CAAC,eAAe,CAAC,SAAS,EAAE,mBAAmB,EAAE,kBAAkB,CAAC,CAAC;YAC9F,CAAC,CAAC,CAAC;SACN;QAED,OAAO,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,GAAG,EAAE;YAC3B,OAAO,KAAK,CAAC,eAAgB,CAAC;QAClC,CAAC,CAAC,CAAC;IACP,CAAC;CACJ;AAED,UAAU,CAAC,iBAAiB,CAAC,IAAI,EAAE,CAAC,MAAM,EAAE,EAAE,CAAC,IAAI,sBAAsB,CAAC,MAAM,CAAC,CAAC,CAAC","sourcesContent":["import type { Nullable } from \"core/types\";\r\nimport { Scalar } from \"core/Maths/math.scalar\";\r\nimport { SphericalHarmonics, SphericalPolynomial } from \"core/Maths/sphericalPolynomial\";\r\nimport { Quaternion, Matrix } from \"core/Maths/math.vector\";\r\nimport type { BaseTexture } from \"core/Materials/Textures/baseTexture\";\r\nimport { RawCubeTexture } from \"core/Materials/Textures/rawCubeTexture\";\r\n\r\nimport type { IEXTLightsImageBased_LightReferenceImageBased, IEXTLightsImageBased_LightImageBased, IEXTLightsImageBased } from \"babylonjs-gltf2interface\";\r\nimport type { IScene } from \"../glTFLoaderInterfaces\";\r\nimport type { IGLTFLoaderExtension } from \"../glTFLoaderExtension\";\r\nimport { GLTFLoader, ArrayItem } from \"../glTFLoader\";\r\n\r\nconst NAME = \"EXT_lights_image_based\";\r\n\r\ndeclare module \"babylonjs-gltf2interface\" {\r\n    /** @internal */\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    interface IEXTLightsImageBased_LightImageBased {\r\n        _babylonTexture?: BaseTexture;\r\n        _loaded?: Promise<void>;\r\n    }\r\n}\r\n\r\n/**\r\n * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Vendor/EXT_lights_image_based/README.md)\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class EXT_lights_image_based implements IGLTFLoaderExtension {\r\n    /**\r\n     * The name of this extension.\r\n     */\r\n    public readonly name = NAME;\r\n\r\n    /**\r\n     * Defines whether this extension is enabled.\r\n     */\r\n    public enabled: boolean;\r\n\r\n    private _loader: GLTFLoader;\r\n    private _lights?: IEXTLightsImageBased_LightImageBased[];\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    constructor(loader: GLTFLoader) {\r\n        this._loader = loader;\r\n        this.enabled = this._loader.isExtensionUsed(NAME);\r\n    }\r\n\r\n    /** @internal */\r\n    public dispose() {\r\n        (this._loader as any) = null;\r\n        delete this._lights;\r\n    }\r\n\r\n    /** @internal */\r\n    public onLoading(): void {\r\n        const extensions = this._loader.gltf.extensions;\r\n        if (extensions && extensions[this.name]) {\r\n            const extension = extensions[this.name] as IEXTLightsImageBased;\r\n            this._lights = extension.lights;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public loadSceneAsync(context: string, scene: IScene): Nullable<Promise<void>> {\r\n        return GLTFLoader.LoadExtensionAsync<IEXTLightsImageBased_LightReferenceImageBased>(context, scene, this.name, (extensionContext, extension) => {\r\n            this._loader._allMaterialsDirtyRequired = true;\r\n\r\n            const promises = new Array<Promise<any>>();\r\n\r\n            promises.push(this._loader.loadSceneAsync(context, scene));\r\n\r\n            this._loader.logOpen(`${extensionContext}`);\r\n\r\n            const light = ArrayItem.Get(`${extensionContext}/light`, this._lights, extension.light);\r\n            promises.push(\r\n                this._loadLightAsync(`/extensions/${this.name}/lights/${extension.light}`, light).then((texture) => {\r\n                    this._loader.babylonScene.environmentTexture = texture;\r\n                })\r\n            );\r\n\r\n            this._loader.logClose();\r\n\r\n            return Promise.all(promises).then(() => {});\r\n        });\r\n    }\r\n\r\n    private _loadLightAsync(context: string, light: IEXTLightsImageBased_LightImageBased): Promise<BaseTexture> {\r\n        if (!light._loaded) {\r\n            const promises = new Array<Promise<any>>();\r\n\r\n            this._loader.logOpen(`${context}`);\r\n\r\n            const imageData = new Array<Array<ArrayBufferView>>(light.specularImages.length);\r\n            for (let mipmap = 0; mipmap < light.specularImages.length; mipmap++) {\r\n                const faces = light.specularImages[mipmap];\r\n                imageData[mipmap] = new Array<ArrayBufferView>(faces.length);\r\n                for (let face = 0; face < faces.length; face++) {\r\n                    const specularImageContext = `${context}/specularImages/${mipmap}/${face}`;\r\n                    this._loader.logOpen(`${specularImageContext}`);\r\n\r\n                    const index = faces[face];\r\n                    const image = ArrayItem.Get(specularImageContext, this._loader.gltf.images, index);\r\n                    promises.push(\r\n                        this._loader.loadImageAsync(`/images/${index}`, image).then((data) => {\r\n                            imageData[mipmap][face] = data;\r\n                        })\r\n                    );\r\n\r\n                    this._loader.logClose();\r\n                }\r\n            }\r\n\r\n            this._loader.logClose();\r\n\r\n            light._loaded = Promise.all(promises).then(() => {\r\n                const babylonTexture = new RawCubeTexture(this._loader.babylonScene, null, light.specularImageSize);\r\n                babylonTexture.name = light.name || \"environment\";\r\n                light._babylonTexture = babylonTexture;\r\n\r\n                if (light.intensity != undefined) {\r\n                    babylonTexture.level = light.intensity;\r\n                }\r\n\r\n                if (light.rotation) {\r\n                    let rotation = Quaternion.FromArray(light.rotation);\r\n\r\n                    // Invert the rotation so that positive rotation is counter-clockwise.\r\n                    if (!this._loader.babylonScene.useRightHandedSystem) {\r\n                        rotation = Quaternion.Inverse(rotation);\r\n                    }\r\n\r\n                    Matrix.FromQuaternionToRef(rotation, babylonTexture.getReflectionTextureMatrix());\r\n                }\r\n\r\n                if (!light.irradianceCoefficients) {\r\n                    throw new Error(`${context}: Irradiance coefficients are missing`);\r\n                }\r\n\r\n                const sphericalHarmonics = SphericalHarmonics.FromArray(light.irradianceCoefficients);\r\n                sphericalHarmonics.scaleInPlace(light.intensity);\r\n\r\n                sphericalHarmonics.convertIrradianceToLambertianRadiance();\r\n                const sphericalPolynomial = SphericalPolynomial.FromHarmonics(sphericalHarmonics);\r\n\r\n                // Compute the lod generation scale to fit exactly to the number of levels available.\r\n                const lodGenerationScale = (imageData.length - 1) / Scalar.Log2(light.specularImageSize);\r\n                return babylonTexture.updateRGBDAsync(imageData, sphericalPolynomial, lodGenerationScale);\r\n            });\r\n        }\r\n\r\n        return light._loaded.then(() => {\r\n            return light._babylonTexture!;\r\n        });\r\n    }\r\n}\r\n\r\nGLTFLoader.RegisterExtension(NAME, (loader) => new EXT_lights_image_based(loader));\r\n"]}